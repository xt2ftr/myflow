import { A as ApiKey$1, a as ApiKeyCreate, b as ApiKeyUpdate, D as DataSinkCreate, c as DataSink$1, d as DataSinkUpdate, e as DataSourceCreate, f as DataSource$1, g as DataSourceUpdate, h as DataSourceLoadJobRecord, L as ListProjectsApiProjectGetRequest, P as Project$1, i as ProjectCreate, j as ProjectUpdate, k as PipelineCreate, l as Pipeline$1, E as EvalDataset, m as EvalDatasetCreate, n as LocalEvalSetCreate, o as LocalEvalResults, p as LocalEvalSets, q as PromptMixinPrompts, S as SearchPipelinesApiPipelineGetRequest, G as GetPipelineForProjectApiPipelinePipelineIdGetRequest, r as PipelineUpdate, s as LoadedFile, t as LoadedFilePayload, u as DeployPlaygroundPipelineApiPipelinePipelineIdDeployPostRequest, C as CreatePlaygroundPipelineApiPipelinePipelineIdPlaygroundPostRequest, v as PlaygroundJobRecord, w as CreatePlaygroundJobApiPipelinePipelineIdPlaygroundJobPostRequest, x as GetPlaygroundJobResultApiPipelinePipelineIdPlaygroundJobResultGetRequest, y as PlatformTextNode, z as EvalDatasetJobRecord, B as EvalExecutionCreate, F as EvalQuestionResult, R as RawFileManagedIngestionJobRecord, H as DataSourceManagedIngestionJobRecord, I as PipelineManagedIngestionJobRecord, J as RetrievalParams, K as RetrieveResults, M as RawFile, N as EvalDatasetUpdate, O as EvalQuestion, Q as EvalQuestionCreate, T as SupportedEvalLlmModel, U as LlamaParseSupportedFileExtensions, V as BodyUploadFileApiParsingUploadPost, W as ParsingJob, X as ParsingUsage, Y as ParsingJobTextResult, Z as ParsingJobMarkdownResult, _ as ConfigurableTransformationDefinition, $ as DataSourceDefinition, a0 as DataSinkDefinition, a1 as CheckoutSessionCreatePayload, a2 as CustomerPortalSessionCreatePayload, a3 as StripeWebhookApiBillingWebhookPostRequest } from './index-DnAm2uXq.cjs';
export { a4 as PlatformApi, a5 as PlatformApiError } from './index-DnAm2uXq.cjs';
import * as fs from 'fs';

/**
 * This file was auto-generated by Fern from our API Definition.
 */
declare class PlatformApiTimeoutError extends Error {
    constructor();
}

type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
declare const Supplier: {
    get: <T>(supplier: Supplier<T>) => Promise<T>;
};

type BearerToken = string;
declare const BearerToken: {
    toAuthorizationHeader: (token: BearerToken | undefined) => string | undefined;
    fromAuthorizationHeader: (header: string) => BearerToken;
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Health {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Health {
    protected readonly _options: Health.Options;
    constructor(_options: Health.Options);
    /**
     * Health check endpoint.
     *
     * @example
     *     await platformApi.health.health()
     */
    health(requestOptions?: Health.RequestOptions): Promise<Record<string, string>>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace ApiKey {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class ApiKey {
    protected readonly _options: ApiKey.Options;
    constructor(_options: ApiKey.Options);
    /**
     * Get all API Keys for a user.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.apiKey.getKeys()
     */
    getKeys(requestOptions?: ApiKey.RequestOptions): Promise<ApiKey$1[]>;
    /**
     * Generate a new API Key.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.apiKey.generateKey({})
     */
    generateKey(request?: ApiKeyCreate, requestOptions?: ApiKey.RequestOptions): Promise<ApiKey$1>;
    /**
     * Update name of an existing API Key.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.apiKey.updateExistingApiKey("string", {})
     */
    updateExistingApiKey(apiKeyId: string, request?: ApiKeyUpdate, requestOptions?: ApiKey.RequestOptions): Promise<ApiKey$1>;
    /**
     * Delete an API Key by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.apiKey.deleteApiKey("string")
     */
    deleteApiKey(apiKeyId: string, requestOptions?: ApiKey.RequestOptions): Promise<void>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace DataSink {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class DataSink {
    protected readonly _options: DataSink.Options;
    constructor(_options: DataSink.Options);
    /**
     * Create a new data sink.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSink.createDataSink({
     *         name: "string",
     *         sinkType: PlatformApi.ConfigurableDataSinkNames.Chroma
     *     })
     */
    createDataSink(request: DataSinkCreate, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Upserts a data sink.
     * Updates if a data sink with the same name and user_id already exists. Otherwise, creates a new data sink.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSink.upsertDataSink({
     *         name: "string",
     *         sinkType: PlatformApi.ConfigurableDataSinkNames.Chroma
     *     })
     */
    upsertDataSink(request: DataSinkCreate, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Get a data sink by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSink.getDataSink("string")
     */
    getDataSink(dataSinkId: string, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Update a data sink by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSink.updateDataSink("string", {
     *         sinkType: PlatformApi.ConfigurableDataSinkNames.Chroma
     *     })
     */
    updateDataSink(dataSinkId: string, request: DataSinkUpdate, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Delete a data sink by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSink.deleteDataSink("string")
     */
    deleteDataSink(dataSinkId: string, requestOptions?: DataSink.RequestOptions): Promise<void>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace DataSource {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class DataSource {
    protected readonly _options: DataSource.Options;
    constructor(_options: DataSource.Options);
    /**
     * Create a new data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.createDataSource({
     *         name: "string",
     *         sourceType: PlatformApi.ConfigurableDataSourceNames.Discord
     *     })
     */
    createDataSource(request: DataSourceCreate, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Upserts a data source.
     * Updates if a data source with the same name and user_id already exists.Otherwise, creates a new data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.upsertDataSource({
     *         name: "string",
     *         sourceType: PlatformApi.ConfigurableDataSourceNames.Discord
     *     })
     */
    upsertDataSource(request: DataSourceCreate, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Get a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.getDataSource("string")
     */
    getDataSource(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Update a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.updateDataSource("string", {
     *         sourceType: PlatformApi.ConfigurableDataSourceNames.Discord
     *     })
     */
    updateDataSource(dataSourceId: string, request: DataSourceUpdate, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Delete a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.deleteDataSource("string")
     */
    deleteDataSource(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<void>;
    /**
     * Get all data source executions for a given data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.getDataSourceExecutions("string")
     */
    getDataSourceExecutions(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSourceLoadJobRecord[]>;
    /**
     * Create a new data source execution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.createDataSourceExecution("string")
     */
    createDataSourceExecution(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSourceLoadJobRecord>;
    /**
     * Get a data source execution by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.getDataSourceExecution("string", "string")
     */
    getDataSourceExecution(dataSourceId: string, dataSourceLoadExecutionId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSourceLoadJobRecord>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Project {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Project {
    protected readonly _options: Project.Options;
    constructor(_options: Project.Options);
    /**
     * List projects or get one by name
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.listProjects({})
     */
    listProjects(request?: ListProjectsApiProjectGetRequest, requestOptions?: Project.RequestOptions): Promise<Project$1[]>;
    /**
     * Create a new project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.createProject({
     *         name: "string"
     *     })
     */
    createProject(request: ProjectCreate, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Upsert a project.
     * Updates if a project with the same name already exists. Otherwise, creates a new project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.upsertProject({
     *         name: "string"
     *     })
     */
    upsertProject(request: ProjectCreate, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Get a project by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.getProject("string")
     */
    getProject(projectId: string, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Update an existing project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.updateExistingProject("string", {
     *         name: "string"
     *     })
     */
    updateExistingProject(projectId: string, request: ProjectUpdate, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Create a new pipeline for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.createPipelineForProject("string", {
     *         presetRetrievalParameters: {},
     *         evalParameters: {
     *             llmModel: PlatformApi.SupportedEvalLlmModelNames.Gpt35Turbo
     *         },
     *         name: "string",
     *         pipelineType: PlatformApi.PipelineType.Playground
     *     })
     */
    createPipelineForProject(projectId: string, request: PipelineCreate, requestOptions?: Project.RequestOptions): Promise<Pipeline$1>;
    /**
     * Upsert a pipeline for a project.
     * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.upsertPipelineForProject("string", {
     *         presetRetrievalParameters: {},
     *         evalParameters: {
     *             llmModel: PlatformApi.SupportedEvalLlmModelNames.Gpt35Turbo
     *         },
     *         name: "string",
     *         pipelineType: PlatformApi.PipelineType.Playground
     *     })
     */
    upsertPipelineForProject(projectId: string, request: PipelineCreate, requestOptions?: Project.RequestOptions): Promise<Pipeline$1>;
    /**
     * Get all eval datasets for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.getDatasetsForProject("string")
     */
    getDatasetsForProject(projectId: string, requestOptions?: Project.RequestOptions): Promise<EvalDataset[]>;
    /**
     * Create a new eval dataset for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.createEvalDatasetForProject("string", {
     *         name: "string"
     *     })
     */
    createEvalDatasetForProject(projectId: string, request: EvalDatasetCreate, requestOptions?: Project.RequestOptions): Promise<EvalDataset>;
    /**
     * Create a new local eval set.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.createLocalEvalSetForProject("string", {
     *         appName: "string",
     *         results: {
     *             "string": []
     *         }
     *     })
     */
    createLocalEvalSetForProject(projectId: string, request: LocalEvalSetCreate, requestOptions?: Project.RequestOptions): Promise<LocalEvalResults[]>;
    /**
     * Get all local eval results for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.getLocalEvalsForProject("string")
     */
    getLocalEvalsForProject(projectId: string, requestOptions?: Project.RequestOptions): Promise<LocalEvalResults[]>;
    /**
     * Get all local eval sets for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.getLocalEvalSetsForProject("string")
     */
    getLocalEvalSetsForProject(projectId: string, requestOptions?: Project.RequestOptions): Promise<LocalEvalSets[]>;
    /**
     * Delete a local eval set.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.deleteLocalEvalSet("string", "string")
     */
    deleteLocalEvalSet(projectId: string, localEvalSetId: string, requestOptions?: Project.RequestOptions): Promise<unknown>;
    /**
     * Get all PromptMixin prompt sets for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.getPromptmixinPrompts("string")
     */
    getPromptmixinPrompts(projectId: string, requestOptions?: Project.RequestOptions): Promise<PromptMixinPrompts[]>;
    /**
     * Create a new PromptMixin prompt set.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.createPromptMixinPrompts("string", {
     *         projectId: "string",
     *         name: "string",
     *         prompts: []
     *     })
     */
    createPromptMixinPrompts(projectId: string, request: PromptMixinPrompts, requestOptions?: Project.RequestOptions): Promise<PromptMixinPrompts>;
    /**
     * Update a PromptMixin prompt set.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.updatePromptmixinPrompts("string", "string", {
     *         projectId: "string",
     *         name: "string",
     *         prompts: []
     *     })
     */
    updatePromptmixinPrompts(projectId: string, promptSetId: string, request: PromptMixinPrompts, requestOptions?: Project.RequestOptions): Promise<PromptMixinPrompts>;
    /**
     * Delete a PromptMixin prompt set.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.deletePromptMixinPrompts("string", "string")
     */
    deletePromptMixinPrompts(projectId: string, promptSetId: string, requestOptions?: Project.RequestOptions): Promise<unknown>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Pipeline {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Pipeline {
    protected readonly _options: Pipeline.Options;
    constructor(_options: Pipeline.Options);
    /**
     * Search for pipelines by various parameters.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.searchPipelines({
     *         projectName: "string",
     *         pipelineType: PlatformApi.PipelineType.Playground
     *     })
     */
    searchPipelines(request: SearchPipelinesApiPipelineGetRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1[]>;
    /**
     * Get a pipeline by ID for a given project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getPipelineForProject("string", {})
     */
    getPipelineForProject(pipelineId: string, request?: GetPipelineForProjectApiPipelinePipelineIdGetRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Update an existing pipeline for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.updateExistingPipeline("string", {
     *         presetRetrievalParameters: {},
     *         evalParameters: {
     *             llmModel: PlatformApi.SupportedEvalLlmModelNames.Gpt35Turbo
     *         }
     *     })
     */
    updateExistingPipeline(pipelineId: string, request?: PipelineUpdate, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Delete a pipeline by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.deletePipeline("string")
     */
    deletePipeline(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<void>;
    /**
     * Get loaded files for a pipeline by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getLoadedFilesForPipeline("string")
     */
    getLoadedFilesForPipeline(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<LoadedFile[]>;
    /**
     * Get loaded files for a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getLoadedFileContent("string", "string")
     */
    getLoadedFileContent(pipelineId: string, loadedFileId: string, requestOptions?: Pipeline.RequestOptions): Promise<LoadedFilePayload>;
    /**
     * Deploy a playground pipeline to a managed pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.deployPlaygroundPipeline("string", {})
     */
    deployPlaygroundPipeline(pipelineId: string, request?: DeployPlaygroundPipelineApiPipelinePipelineIdDeployPostRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Deploy a playground pipeline to the managed pipeline it is already associated with.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.deployPlaygroundPipelineWithExistingManagedPipeline("string")
     */
    deployPlaygroundPipelineWithExistingManagedPipeline(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Create a playground pipeline from a managed pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.createPlaygroundPipeline("string", {})
     */
    createPlaygroundPipeline(pipelineId: string, request?: CreatePlaygroundPipelineApiPipelinePipelineIdPlaygroundPostRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Get all PlaygroundJobRecords for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getAllPlaygroundJobs("string")
     */
    getAllPlaygroundJobs(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<PlaygroundJobRecord[]>;
    /**
     * Kick off a new Playground execution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.createPlaygroundJob("string", {})
     */
    createPlaygroundJob(pipelineId: string, request?: CreatePlaygroundJobApiPipelinePipelineIdPlaygroundJobPostRequest, requestOptions?: Pipeline.RequestOptions): Promise<PlaygroundJobRecord>;
    /**
     * Get the result of the latest Playground job.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getPlaygroundJobResult("string", {})
     */
    getPlaygroundJobResult(pipelineId: string, request?: GetPlaygroundJobResultApiPipelinePipelineIdPlaygroundJobResultGetRequest, requestOptions?: Pipeline.RequestOptions): Promise<PlatformTextNode[]>;
    /**
     * Get status of a single pipeline PlaygroundJob for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getPlaygroundJob("string", "string")
     */
    getPlaygroundJob(pipelineId: string, playgroundJobId: string, requestOptions?: Pipeline.RequestOptions): Promise<PlaygroundJobRecord>;
    /**
     * Get the status of an EvalDatasetExecution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getEvalDatasetExecutions("string", "string")
     */
    getEvalDatasetExecutions(pipelineId: string, evalDatasetId: string, requestOptions?: Pipeline.RequestOptions): Promise<EvalDatasetJobRecord[]>;
    /**
     * Execute a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.executeEvalDataset("string", "string", {
     *         evalQuestionIds: [],
     *         params: {
     *             llmModel: PlatformApi.SupportedEvalLlmModelNames.Gpt35Turbo
     *         }
     *     })
     */
    executeEvalDataset(pipelineId: string, evalDatasetId: string, request: EvalExecutionCreate, requestOptions?: Pipeline.RequestOptions): Promise<EvalDatasetJobRecord>;
    /**
     * Get the result of an EvalDatasetExecution.
     * If eval_question_ids is specified, only the results for the specified
     * questions will be returned.
     * If any of the specified questions do not have a result, they will be ignored.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getEvalDatasetExecutionResult("string", "string")
     */
    getEvalDatasetExecutionResult(pipelineId: string, evalDatasetId: string, requestOptions?: Pipeline.RequestOptions): Promise<EvalQuestionResult[]>;
    /**
     * Get the status of an EvalDatasetExecution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getEvalDatasetExecution("string", "string", "string")
     */
    getEvalDatasetExecution(pipelineId: string, evalDatasetId: string, evalDatasetExecutionId: string, requestOptions?: Pipeline.RequestOptions): Promise<EvalDatasetJobRecord>;
    /**
     * Get all ManagedRawFileIngestionExecution for a given pipeline and raw file.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getRawFileManagedIngestionExecutions("string", "string")
     */
    getRawFileManagedIngestionExecutions(pipelineId: string, rawFileName: string, requestOptions?: Pipeline.RequestOptions): Promise<RawFileManagedIngestionJobRecord[]>;
    /**
     * Execute a ManagedRawFileIngestion.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.runRawFileManagedIngestion("string", "string")
     */
    runRawFileManagedIngestion(pipelineId: string, rawFileName: string, requestOptions?: Pipeline.RequestOptions): Promise<RawFileManagedIngestionJobRecord>;
    /**
     * Get a single ManagedRawFileIngestionExecution for a given pipeline and raw file.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getRawFileManagedIngestionExecution("string", "string", "string")
     */
    getRawFileManagedIngestionExecution(pipelineId: string, rawFileName: string, managedRawFileIngestionId: string, requestOptions?: Pipeline.RequestOptions): Promise<RawFileManagedIngestionJobRecord>;
    /**
     * Get all ManagedDataSourceIngestionExecution for a given pipeline and data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedDataSourceIngestionExecutions("string", "string")
     */
    getManagedDataSourceIngestionExecutions(pipelineId: string, dataSourceId: string, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord[]>;
    /**
     * Execute a ManagedDataSourceIngestion.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.runManagedDataSourceIngestion("string", "string")
     */
    runManagedDataSourceIngestion(pipelineId: string, dataSourceId: string, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord>;
    /**
     * Get a single ManagedDataSourceIngestionExecution for a given pipeline and data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedDataSourceIngestionExecution("string", "string", "string")
     */
    getManagedDataSourceIngestionExecution(pipelineId: string, dataSourceId: string, managedDataSourceIngestionId: string, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord>;
    /**
     * Get all ManagedPipelineIngestionExecution for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedPipelineIngestionExecutions("string")
     */
    getManagedPipelineIngestionExecutions(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<PipelineManagedIngestionJobRecord[]>;
    /**
     * Execute a ManagedPipelineIngestion.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.runManagedPipelineIngestion("string")
     */
    runManagedPipelineIngestion(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<PipelineManagedIngestionJobRecord>;
    /**
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedIngestionExecution("string", "string")
     */
    getManagedIngestionExecution(pipelineId: string, managedPipelineIngestionId: string, requestOptions?: Pipeline.RequestOptions): Promise<PipelineManagedIngestionJobRecord>;
    /**
     * Get retrieval results for a managed pipeline and a query
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.runSearch("string", {
     *         query: "string"
     *     })
     */
    runSearch(pipelineId: string, request: RetrievalParams, requestOptions?: Pipeline.RequestOptions): Promise<RetrieveResults>;
    /**
     * Read RawFile metadata objects.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.readRawFiles("string")
     */
    readRawFiles(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<RawFile[]>;
    /**
     * Uploads a raw file to S3 and returns the RawFile metadata object.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    upsertRawFile(file: File | fs.ReadStream, pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<RawFile>;
    /**
     * Redirects to a presigned url to read the raw file content.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.readRawFileContent("string", "string")
     */
    readRawFileContent(pipelineId: string, name: string, requestOptions?: Pipeline.RequestOptions): Promise<void>;
    /**
     * Delete the raw file from S3.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.deleteRawFile("string", "string")
     */
    deleteRawFile(pipelineId: string, name: string, requestOptions?: Pipeline.RequestOptions): Promise<void>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Eval {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Eval {
    protected readonly _options: Eval.Options;
    constructor(_options: Eval.Options);
    /**
     * Get a dataset by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.getDataset("string")
     */
    getDataset(datasetId: string, requestOptions?: Eval.RequestOptions): Promise<EvalDataset>;
    /**
     * Update a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.updateDataset("string", {
     *         name: "string"
     *     })
     */
    updateDataset(datasetId: string, request: EvalDatasetUpdate, requestOptions?: Eval.RequestOptions): Promise<EvalDataset>;
    /**
     * Delete a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.deleteDataset("string")
     */
    deleteDataset(datasetId: string, requestOptions?: Eval.RequestOptions): Promise<void>;
    /**
     * Get all questions for a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.getQuestions("string")
     */
    getQuestions(datasetId: string, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion[]>;
    /**
     * Create a new question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.createQuestion("string", {
     *         content: "string"
     *     })
     */
    createQuestion(datasetId: string, request: EvalQuestionCreate, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion>;
    /**
     * Create a new question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.createQuestions("string", [])
     */
    createQuestions(datasetId: string, request: EvalQuestionCreate[], requestOptions?: Eval.RequestOptions): Promise<EvalQuestion[]>;
    /**
     * Get a question by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.getQuestion("string")
     */
    getQuestion(questionId: string, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion>;
    /**
     * Replace a question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.replaceQuestion("string", {
     *         content: "string"
     *     })
     */
    replaceQuestion(questionId: string, request: EvalQuestionCreate, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion>;
    /**
     * Delete a question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.deleteQuestion("string")
     */
    deleteQuestion(questionId: string, requestOptions?: Eval.RequestOptions): Promise<void>;
    /**
     * Get all supported models.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.getSupportedModels()
     */
    getSupportedModels(requestOptions?: Eval.RequestOptions): Promise<SupportedEvalLlmModel[]>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Parsing {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Parsing {
    protected readonly _options: Parsing.Options;
    constructor(_options: Parsing.Options);
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.parsing.getJobImageResult("string", "string")
     */
    getJobImageResult(jobId: string, name: string, requestOptions?: Parsing.RequestOptions): Promise<void>;
    /**
     * Get a list of supported file extensions
     *
     * @example
     *     await platformApi.parsing.getSupportedFileExtensions()
     */
    getSupportedFileExtensions(requestOptions?: Parsing.RequestOptions): Promise<LlamaParseSupportedFileExtensions[]>;
    /**
     * Upload a file to s3 and create a job. return a job id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    uploadFile(file: File | fs.ReadStream, request: BodyUploadFileApiParsingUploadPost, requestOptions?: Parsing.RequestOptions): Promise<ParsingJob>;
    /**
     * Get parsing usage for user
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.parsing.usage()
     */
    usage(requestOptions?: Parsing.RequestOptions): Promise<ParsingUsage>;
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.parsing.getJob("string")
     */
    getJob(jobId: string, requestOptions?: Parsing.RequestOptions): Promise<ParsingJob>;
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.parsing.getJobTextResult("string")
     */
    getJobTextResult(jobId: string, requestOptions?: Parsing.RequestOptions): Promise<ParsingJobTextResult>;
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.parsing.getJobResult("string")
     */
    getJobResult(jobId: string, requestOptions?: Parsing.RequestOptions): Promise<ParsingJobMarkdownResult>;
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.parsing.getJobJsonResult("string")
     */
    getJobJsonResult(jobId: string, requestOptions?: Parsing.RequestOptions): Promise<unknown>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace ComponentDefinition {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class ComponentDefinition {
    protected readonly _options: ComponentDefinition.Options;
    constructor(_options: ComponentDefinition.Options);
    /**
     * Get all configurable transformation component definitions.
     *
     * @example
     *     await platformApi.componentDefinition.getAllTransformationDefinitions()
     */
    getAllTransformationDefinitions(requestOptions?: ComponentDefinition.RequestOptions): Promise<ConfigurableTransformationDefinition[]>;
    /**
     * Get all data source component definitions.
     *
     * @example
     *     await platformApi.componentDefinition.getAllDataSourceDefinitions()
     */
    getAllDataSourceDefinitions(requestOptions?: ComponentDefinition.RequestOptions): Promise<DataSourceDefinition[]>;
    /**
     * Get all data sink component definitions.
     *
     * @example
     *     await platformApi.componentDefinition.getAllDataSinkDefinitions()
     */
    getAllDataSinkDefinitions(requestOptions?: ComponentDefinition.RequestOptions): Promise<DataSinkDefinition[]>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Billing {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Billing {
    protected readonly _options: Billing.Options;
    constructor(_options: Billing.Options);
    /**
     * Create a new checkout session.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.billing.createCheckoutSession({
     *         successUrl: "string",
     *         cancelUrl: "string"
     *     })
     */
    createCheckoutSession(request: CheckoutSessionCreatePayload, requestOptions?: Billing.RequestOptions): Promise<string>;
    /**
     * Create a new customer portal session.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.billing.createCustomerPortalSession({
     *         returnUrl: "string"
     *     })
     */
    createCustomerPortalSession(request: CustomerPortalSessionCreatePayload, requestOptions?: Billing.RequestOptions): Promise<string>;
    /**
     * Stripe webhook endpoint.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.billing.stripeWebhook({})
     */
    stripeWebhook(request?: StripeWebhookApiBillingWebhookPostRequest, requestOptions?: Billing.RequestOptions): Promise<unknown>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace PlatformApiClient {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class PlatformApiClient {
    protected readonly _options: PlatformApiClient.Options;
    constructor(_options: PlatformApiClient.Options);
    protected _health: Health | undefined;
    get health(): Health;
    protected _apiKey: ApiKey | undefined;
    get apiKey(): ApiKey;
    protected _dataSink: DataSink | undefined;
    get dataSink(): DataSink;
    protected _dataSource: DataSource | undefined;
    get dataSource(): DataSource;
    protected _project: Project | undefined;
    get project(): Project;
    protected _pipeline: Pipeline | undefined;
    get pipeline(): Pipeline;
    protected _eval: Eval | undefined;
    get eval(): Eval;
    protected _parsing: Parsing | undefined;
    get parsing(): Parsing;
    protected _componentDefinition: ComponentDefinition | undefined;
    get componentDefinition(): ComponentDefinition;
    protected _billing: Billing | undefined;
    get billing(): Billing;
}

export { PlatformApiClient, PlatformApiTimeoutError };
