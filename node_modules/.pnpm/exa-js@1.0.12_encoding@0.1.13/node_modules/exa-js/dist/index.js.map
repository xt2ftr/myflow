{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import fetch, { Headers } from 'cross-fetch';\n\n/**\n * Search options for performing a search query.\n * @typedef {Object} SearchOptions\n * @property {number} [numResults] - Number of search results to return. Default 10. Max 10 for basic plans.\n * @property {string[]} [includeDomains] - List of domains to include in the search.\n * @property {string[]} [excludeDomains] - List of domains to exclude in the search.\n * @property {string} [startCrawlDate] - Start date for results based on crawl date.\n * @property {string} [endCrawlDate] - End date for results based on crawl date.\n * @property {string} [startPublishedDate] - Start date for results based on published date.\n * @property {string} [endPublishedDate] - End date for results based on published date.\n * @property {boolean} [useAutoprompt] - If true, converts query to a Metaphor query.\n * @property {string} [type] - Type of search, 'keyword' or 'neural'.\n * @property {string} [category] - A data category to focus on, with higher comprehensivity and data cleanliness. Currently, the only category is company.\n */\nexport type BaseSearchOptions = {\n  numResults?: number;\n  includeDomains?: string[];\n  excludeDomains?: string[];\n  startCrawlDate?: string;\n  endCrawlDate?: string;\n  startPublishedDate?: string;\n  endPublishedDate?: string;\n  category?: string;\n};\n\n/**\n * Search options for performing a search query.\n * @typedef {Object} ContentsOptions\n * @property {string[]} [formats] - An array of format types asked for. Currently supports `extract` (first 1000 tokens) and `text` (full parsed HTML text). If this isn't specified, defaults to `extract`.\n */\nexport type RegularSearchOptions = BaseSearchOptions & {\n  useAutoprompt?: boolean;\n  type?: string;\n}\n\n/**\n * Options for finding similar links.\n * @typedef {Object} FindSimilarOptions\n * @property {number} [numResults] - Number of search results to return. Default 10. Max 10 for basic plans.\n * @property {string[]} [includeDomains] - List of domains to include in the search.\n * @property {string[]} [excludeDomains] - List of domains to exclude from the search.\n * @property {string} [startCrawlDate] - Start date for results based on crawl date.\n * @property {string} [endCrawlDate] - End date for results based on crawl date.\n * @property {string} [startPublishedDate] - Start date for results based on published date.\n * @property {string} [endPublishedDate] - End date for results based on published date.\n * @property {boolean} [excludeSourceDomain] - If true, excludes links from the base domain of the input.\n * @property {string} [category] - A data category to focus on, with higher comprehensivity and data cleanliness. Currently, the only category is company.\n */\nexport type FindSimilarOptions = BaseSearchOptions & {\n  excludeSourceDomain?: boolean;\n}\n\n/**\n * Search options for performing a search query.\n * @typedef {Object} ContentsOptions\n * @property {TextContentsOptions | boolean} [text] - Options for retrieving text contents.\n * @property {HighlightsContentsOptions | boolean} [highlights] - Options for retrieving highlights.\n */\nexport type ContentsOptions = {\n  text?: TextContentsOptions | true;\n  highlights?: HighlightsContentsOptions | true;\n};\n\n/**\n * Options for retrieving text from page.\n * @typedef {Object} TextContentsOptions\n * @property {number} [maxCharacters] - The maximum number of characters to return.\n * @property {boolean} [includeHtmlTags] - If true, includes HTML tags in the returned text. Default: false\n */\nexport type TextContentsOptions = {\n  maxCharacters?: number;\n  includeHtmlTags?: boolean;\n}\n\n/**\n * Options for retrieving highlights from page.\n * @typedef {Object} HighlightsContentsOptions\n * @property {string} [query] - The query string to use for highlights search.\n * @property {number} [numSentences] - The number of sentences to return for each highlight.\n * @property {number} [highlightsPerUrl] - The number of highlights to return for each URL.\n */\nexport type HighlightsContentsOptions = {\n  query?: string;\n  numSentences?: number;\n  highlightsPerUrl?: number;\n}\n\n\n/**\n * @typedef {Object} TextResponse\n * @property {string} text - Text from page\n */\nexport type TextResponse = { text: string };\n\n/**\n * @typedef {Object} HighlightsResponse\n * @property {string[]} highlights - The highlights as an array of strings.\n * @property {number[]} highlightScores - The corresponding scores as an array of floats, 0 to 1\n */\nexport type HighlightsResponse = { highlights: string[], highlightScores: number[] };\n\nexport type Default<T extends {}, U> = [keyof T] extends [never] ? U : T;\n\n/**\n * @typedef {Object} ContentsResultComponent\n * Depending on 'ContentsOptions', this yields either a 'TextResponse', a 'HighlightsResponse', both, or an empty object.\n *\n * @template T - A type extending from 'ContentsOptions'.\n */\nexport type ContentsResultComponent<T extends ContentsOptions> =\n  Default<(T['text'] extends (object | true) ? TextResponse : {}) &\n    (T['highlights'] extends (object | true) ? HighlightsResponse : {}), TextResponse>;\n\n\n/**\n * Represents a search result object.\n * @typedef {Object} Result\n * @property {string} title - The title of the search result.\n * @property {string} url - The URL of the search result.\n * @property {string} [publishedDate] - The estimated creation date of the content.\n * @property {string} [author] - The author of the content, if available.\n * @property {number} [score] - Similarity score between the query/url and the result.\n * @property {string} id - The temporary ID for the document.\n */\nexport type SearchResult<T extends ContentsOptions = {}> = {\n  title: string | null;\n  url: string;\n  publishedDate?: string;\n  author?: string;\n  score?: number;\n  id: string;\n} & ContentsResultComponent<T>;\n\n/**\n * Represents a search response object.\n * @typedef {Object} SearchResponse\n * @property {Result[]} results - The list of search results.\n * @property {string} [autopromptString] - The autoprompt string, if applicable.\n */\nexport type SearchResponse<T extends ContentsOptions = {}> = {\n  results: SearchResult<T>[];\n  autopromptString?: string;\n}\n\n/**\n * The Exa class encapsulates the API's endpoints.\n */\nclass Exa {\n  private baseURL: string;\n  private headers: Headers;\n\n  /**\n   * Constructs the Exa API client.\n   * @param {string} apiKey - The API key for authentication.\n   * @param {string} [baseURL] - The base URL of the Exa API.\n   */\n  constructor(\n    apiKey?: string,\n    baseURL: string = \"https://api.exa.ai\"\n  ) {\n    this.baseURL = baseURL;\n    if (!apiKey) {\n      apiKey = process.env.EXASEARCH_API_KEY;\n      if (!apiKey) {\n        throw new Error(\"API key must be provided as an argument or as an environment variable (EXASEARCH_API_KEY)\");\n      }\n    }\n    this.headers = new Headers({\n      \"x-api-key\": apiKey,\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": \"exa-node 1.0.27\",\n    });\n  }\n\n  /**\n* Makes a request to the Exa API.\n* @param {string} endpoint - The API endpoint to call.\n* @param {string} method - The HTTP method to use.\n* @param {any} [body] - The request body for POST requests.\n* @returns {Promise<any>} The response from the API.\n*/\n  private async request(\n    endpoint: string,\n    method: string,\n    body?: any\n  ): Promise<any> {\n    const response = await fetch(this.baseURL + endpoint, {\n      method,\n      headers: this.headers,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const message = (await response.json()).error;\n      throw new Error(\n        `Request failed with status ${response.status}. ${message}`\n      );\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Performs a search with a Exa prompt-engineered query.\n   * @param {string} query - The query string.\n   * @param {SearchOptions} [options] - Additional search options.\n   * @returns {Promise<SearchResponse>} A list of relevant search results.\n   */\n  async search(query: string, options?: RegularSearchOptions): Promise<SearchResponse> {\n    return await this.request(\"/search\", 'POST', { query, ...options });\n  }\n\n  /**\n   * Performs a search with a Exa prompt-engineered query and returns the contents of the documents.\n   * @param {string} query - The query string.\n   * @param {SearchOptions} [options] - Additional search options.\n   * @returns {Promise<SearchResponse>} A list of relevant search results.\n   */\n  async searchAndContents<T extends ContentsOptions>(query: string, options?: RegularSearchOptions & T): Promise<SearchResponse<T>> {\n    const { text, highlights, ...rest } = options || {};\n    return await this.request(\"/search\", 'POST', {\n      query,\n      contents: (!text && !highlights) ? { text: true } : {\n        ...(text ? { text } : {}),\n        ...(highlights ? { highlights } : {})\n      },\n      ...rest\n    });\n  }\n\n  /**\n   * Finds similar links to the provided URL.\n   * @param {string} url - The URL for which to find similar links.\n   * @param {FindSimilarOptions} [options] - Additional options for finding similar links.\n   * @returns {Promise<SearchResponse>} A list of similar search results.\n   */\n  async findSimilar(\n    url: string,\n    options?: FindSimilarOptions\n  ): Promise<SearchResponse> {\n    return await this.request(\"/findSimilar\", 'POST', { url, ...options });\n  }\n\n  /**\n   * Finds similar links to the provided URL and returns the contents of the documents.\n   * @param {string} url - The URL for which to find similar links.\n   * @param {FindSimilarOptions} [options] - Additional options for finding similar links.\n   * @returns {Promise<SearchResponse>} A list of similar search results.\n   */\n  async findSimilarAndContents<T extends ContentsOptions>(url: string, options?: FindSimilarOptions & T): Promise<SearchResponse<T>> {\n    const { text, highlights, ...rest } = options || {};\n    return await this.request(\"/findSimilar\", 'POST', {\n      url,\n      contents: (!text && !highlights) ? { text: true } : {\n        ...(text ? { text } : {}),\n        ...(highlights ? { highlights } : {})\n      },\n      ...rest\n    });\n  }\n\n  /**\n   * Retrieves contents of documents based on a list of document IDs.\n   * @param {string | string[] | SearchResult[]} ids - An array of document IDs.\n   * @param {ContentsOptions} [options] - Additional options for retrieving document contents.\n   * @returns {Promise<GetContentsResponse>} A list of document contents.\n   */\n  async getContents<T extends ContentsOptions>(ids: string | string[] | SearchResult[], options?: T): Promise<SearchResponse<T>> {\n    if (ids.length === 0) {\n      throw new Error(\"Must provide at least one ID\");\n    }\n    let requestIds: string[];\n    if (typeof ids === \"string\") {\n      requestIds = [ids];\n    } else if (typeof ids[0] === \"string\") {\n      requestIds = ids as string[];\n    } else {\n      requestIds = (ids as SearchResult[]).map((result) => result.id);\n    }\n    return await this.request(`/contents`, 'POST', { ids: requestIds, ...options, });\n  }\n}\n\nexport default Exa;\n"],"mappings":"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","names":["fetch"]}