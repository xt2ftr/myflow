/**
 * Polyfill implementation for `@llamaindex/env`.
 *
 * The code should be compatible with any JS runtime.
 *
 * Sometimes you should overwrite the polyfill with a native implementation.
 *
 * @module
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AsyncLocalStorage: function() {
        return _utils.AsyncLocalStorage;
    },
    CustomEvent: function() {
        return _utils.CustomEvent;
    },
    EOL: function() {
        return EOL;
    },
    ReadableStream: function() {
        return ReadableStream;
    },
    TransformStream: function() {
        return TransformStream;
    },
    WritableStream: function() {
        return WritableStream;
    },
    createSHA256: function() {
        return createSHA256;
    },
    fs: function() {
        return _memory.fs;
    },
    getEnv: function() {
        return _utils.getEnv;
    },
    ok: function() {
        return ok;
    },
    path: function() {
        return _pathe.default;
    },
    randomUUID: function() {
        return randomUUID;
    },
    setEnvs: function() {
        return _utils.setEnvs;
    }
});
const _sha256js = require("@aws-crypto/sha256-js");
const _pathe = /*#__PURE__*/ _interop_require_default(require("pathe"));
const _memory = require("./fs/memory.js");
const _utils = require("./utils.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const EOL = "\n";
function ok(value, message) {
    if (!value) {
        const error = Error(message);
        error.name = "AssertionError";
        error.message = message ?? "The expression evaluated to a falsy value.";
        throw error;
    }
}
function createSHA256() {
    const sha256 = new _sha256js.Sha256();
    return {
        update (data) {
            sha256.update(data);
        },
        digest () {
            return globalThis.btoa(sha256.digestSync().toString());
        }
    };
}
function randomUUID() {
    return crypto.randomUUID();
}
// @ts-expect-error
const ReadableStream = globalThis.ReadableStream;
// @ts-expect-error
const TransformStream = globalThis.TransformStream;
// @ts-expect-error
const WritableStream = globalThis.WritableStream;
