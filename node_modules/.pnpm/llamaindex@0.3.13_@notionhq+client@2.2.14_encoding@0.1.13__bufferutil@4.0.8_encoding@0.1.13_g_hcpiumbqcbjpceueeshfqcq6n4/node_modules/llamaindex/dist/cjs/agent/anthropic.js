"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AnthropicAgent: function() {
        return AnthropicAgent;
    },
    AnthropicAgentWorker: function() {
        return AnthropicAgentWorker;
    }
});
const _Settings = require("../Settings.js");
const _utils = require("../internal/utils.js");
const _anthropic = require("../llm/anthropic.js");
const _base = require("./base.js");
const _utils1 = require("./utils.js");
class AnthropicAgentWorker extends _base.AgentWorker {
    taskHandler = AnthropicAgent.taskHandler;
}
class AnthropicAgent extends _base.AgentRunner {
    constructor(params){
        super({
            llm: params.llm ?? (_Settings.Settings.llm instanceof _anthropic.Anthropic ? _Settings.Settings.llm : new _anthropic.Anthropic()),
            chatHistory: params.chatHistory ?? [],
            systemPrompt: params.systemPrompt ?? null,
            runner: new AnthropicAgentWorker(),
            tools: "tools" in params ? params.tools : params.toolRetriever.retrieve.bind(params.toolRetriever),
            verbose: params.verbose ?? false
        });
    }
    createStore = _base.AgentRunner.defaultCreateStore;
    async chat(params) {
        if (params.stream) {
            throw new Error("Anthropic does not support streaming");
        }
        return super.chat(params);
    }
    static taskHandler = async (step, enqueueOutput)=>{
        const { llm, getTools, stream } = step.context;
        const lastMessage = step.context.store.messages.at(-1).content;
        const tools = await getTools(lastMessage);
        if (stream === true) {
            throw new Error("Anthropic does not support streaming");
        }
        const response = await llm.chat({
            stream,
            tools,
            messages: step.context.store.messages
        });
        step.context.store.messages = [
            ...step.context.store.messages,
            response.message
        ];
        const options = response.message.options ?? {};
        enqueueOutput({
            taskStep: step,
            output: response,
            isLast: !("toolCall" in options)
        });
        if ("toolCall" in options) {
            const { toolCall } = options;
            const targetTool = tools.find((tool)=>tool.metadata.name === toolCall.name);
            const toolOutput = await (0, _utils1.callTool)(targetTool, toolCall, step.context.logger);
            step.context.store.toolOutputs.push(toolOutput);
            step.context.store.messages = [
                ...step.context.store.messages,
                {
                    content: (0, _utils.stringifyJSONToMessageContent)(toolOutput.output),
                    role: "user",
                    options: {
                        toolResult: {
                            result: toolOutput.output,
                            isError: toolOutput.isError,
                            id: toolCall.id
                        }
                    }
                }
            ];
        }
    };
}
