"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MultiModalEmbedding", {
    enumerable: true,
    get: function() {
        return MultiModalEmbedding;
    }
});
const _Node = require("../Node.js");
const _types = require("./types.js");
class MultiModalEmbedding extends _types.BaseEmbedding {
    /**
   * Optionally override this method to retrieve multiple image embeddings in a single request
   * @param texts
   */ async getImageEmbeddings(images) {
        return Promise.all(images.map((imgFilePath)=>this.getImageEmbedding(imgFilePath)));
    }
    async transform(nodes, _options) {
        const nodeMap = (0, _Node.splitNodesByType)(nodes);
        const imageNodes = nodeMap[_Node.ModalityType.IMAGE] ?? [];
        const textNodes = nodeMap[_Node.ModalityType.TEXT] ?? [];
        const embeddings = await (0, _types.batchEmbeddings)(textNodes.map((node)=>node.getContent(_Node.MetadataMode.EMBED)), this.getTextEmbeddings.bind(this), this.embedBatchSize, _options);
        for(let i = 0; i < textNodes.length; i++){
            textNodes[i].embedding = embeddings[i];
        }
        const imageEmbeddings = await (0, _types.batchEmbeddings)(imageNodes.map((n)=>n.image), this.getImageEmbeddings.bind(this), this.embedBatchSize, _options);
        for(let i = 0; i < imageNodes.length; i++){
            imageNodes[i].embedding = imageEmbeddings[i];
        }
        return nodes;
    }
}
