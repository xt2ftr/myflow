"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BaseEmbedding: function() {
        return BaseEmbedding;
    },
    batchEmbeddings: function() {
        return batchEmbeddings;
    }
});
const _Node = require("../Node.js");
const _utils = require("./utils.js");
const DEFAULT_EMBED_BATCH_SIZE = 10;
class BaseEmbedding {
    embedBatchSize = DEFAULT_EMBED_BATCH_SIZE;
    similarity(embedding1, embedding2, mode = _utils.SimilarityType.DEFAULT) {
        return (0, _utils.similarity)(embedding1, embedding2, mode);
    }
    /**
   * Optionally override this method to retrieve multiple embeddings in a single request
   * @param texts
   */ async getTextEmbeddings(texts) {
        const embeddings = [];
        for (const text of texts){
            const embedding = await this.getTextEmbedding(text);
            embeddings.push(embedding);
        }
        return embeddings;
    }
    /**
   * Get embeddings for a batch of texts
   * @param texts
   * @param options
   */ async getTextEmbeddingsBatch(texts, options) {
        return await batchEmbeddings(texts, this.getTextEmbeddings.bind(this), this.embedBatchSize, options);
    }
    async transform(nodes, _options) {
        const texts = nodes.map((node)=>node.getContent(_Node.MetadataMode.EMBED));
        const embeddings = await this.getTextEmbeddingsBatch(texts, _options);
        for(let i = 0; i < nodes.length; i++){
            nodes[i].embedding = embeddings[i];
        }
        return nodes;
    }
}
async function batchEmbeddings(values, embedFunc, chunkSize, options) {
    const resultEmbeddings = [];
    const queue = values;
    const curBatch = [];
    for(let i = 0; i < queue.length; i++){
        curBatch.push(queue[i]);
        if (i == queue.length - 1 || curBatch.length == chunkSize) {
            const embeddings = await embedFunc(curBatch);
            resultEmbeddings.push(...embeddings);
            if (options?.logProgress) {
                console.log(`getting embedding progress: ${i} / ${queue.length}`);
            }
            curBatch.length = 0;
        }
    }
    return resultEmbeddings;
}
