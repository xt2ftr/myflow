"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AstraDBVectorStore", {
    enumerable: true,
    get: function() {
        return AstraDBVectorStore;
    }
});
const _astradbts = require("@datastax/astra-db-ts");
const _env = require("@llamaindex/env");
const _Node = require("../../Node.js");
const _types = require("./types.js");
const _utils = require("./utils.js");
class AstraDBVectorStore extends _types.VectorStoreBase {
    storesText = true;
    flatMetadata = true;
    idKey;
    contentKey;
    astraClient;
    astraDB;
    collection;
    constructor(init){
        super(init?.embedModel);
        const token = init?.params?.token ?? (0, _env.getEnv)("ASTRA_DB_APPLICATION_TOKEN");
        const endpoint = init?.params?.endpoint ?? (0, _env.getEnv)("ASTRA_DB_API_ENDPOINT");
        if (!token) {
            throw new Error("Must specify ASTRA_DB_APPLICATION_TOKEN via env variable.");
        }
        if (!endpoint) {
            throw new Error("Must specify ASTRA_DB_API_ENDPOINT via env variable.");
        }
        const namespace = init?.params?.namespace ?? (0, _env.getEnv)("ASTRA_DB_NAMESPACE") ?? "default_keyspace";
        this.astraClient = new _astradbts.DataAPIClient(token, {
            caller: [
                "LlamaIndexTS"
            ]
        });
        this.astraDB = this.astraClient.db(endpoint, {
            namespace
        });
        this.idKey = init?.idKey ?? "_id";
        this.contentKey = init?.contentKey ?? "content";
    }
    /**
   * Create a new collection in your Astra DB vector database and connects to it.
   * You must call this method or `connect` before adding, deleting, or querying.
   *
   * @param collection: your new colletion's name
   * @param options: CreateCollectionOptions used to set the number of vector dimensions and similarity metric
   * @returns Promise that resolves if the creation did not throw an error.
   */ async createAndConnect(collection, options) {
        this.collection = await this.astraDB.createCollection(collection, options);
        console.debug("Created Astra DB collection");
        return;
    }
    /**
   * Connect to an existing collection in your Astra DB vector database.
   * You must call this method or `createAndConnect` before adding, deleting, or querying.
   *
   * @param collection: your existing colletion's name
   * @returns Promise that resolves if the connection did not throw an error.
   */ async connect(collection) {
        this.collection = await this.astraDB.collection(collection);
        console.debug("Connected to Astra DB collection");
        return;
    }
    /**
   * Get an instance of your Astra DB client.
   * @returns the AstraDB client
   */ client() {
        return this.astraClient;
    }
    /**
   * Add your document(s) to your Astra DB collection.
   *
   * @returns and array of node ids which were added
   */ async add(nodes) {
        if (!this.collection) {
            throw new Error("Must connect to collection before adding.");
        }
        const collection = this.collection;
        if (!nodes || nodes.length === 0) {
            return [];
        }
        const dataToInsert = nodes.map((node)=>{
            const metadata = (0, _utils.nodeToMetadata)(node, true, this.contentKey, this.flatMetadata);
            return {
                $vector: node.getEmbedding(),
                [this.idKey]: node.id_,
                [this.contentKey]: node.getContent(_Node.MetadataMode.NONE),
                ...metadata
            };
        });
        console.debug(`Adding ${dataToInsert.length} rows to table`);
        const insertResult = await collection.insertMany(dataToInsert);
        return insertResult.insertedIds;
    }
    /**
   * Delete a document from your Astra DB collection.
   *
   * @param refDocId: the id of the document to delete
   * @param deleteOptions: DeleteOneOptions to pass to the delete query
   * @returns Promise that resolves if the delete query did not throw an error.
   */ async delete(refDocId, deleteOptions) {
        if (!this.collection) {
            throw new Error("Must connect to collection before deleting.");
        }
        const collection = this.collection;
        console.debug(`Deleting row with id ${refDocId}`);
        await collection.deleteOne({
            _id: refDocId
        }, deleteOptions);
    }
    /**
   * Query documents from your Astra DB collection to get the closest match to your embedding.
   *
   * @param query: VectorStoreQuery
   * @param options: FindOptions
   */ async query(query, options) {
        if (!this.collection) {
            throw new Error("Must connect to collection before querying.");
        }
        const collection = this.collection;
        const filters = {};
        query.filters?.filters?.forEach((f)=>{
            filters[f.key] = f.value;
        });
        const cursor = await collection.find(filters, {
            ...options,
            sort: query.queryEmbedding ? {
                $vector: query.queryEmbedding
            } : options?.sort,
            limit: query.similarityTopK,
            includeSimilarity: true
        });
        const nodes = [];
        const ids = [];
        const similarities = [];
        for await (const row of cursor){
            const { $vector: embedding, $similarity: similarity, [this.idKey]: id, [this.contentKey]: content, ...metadata } = row;
            const node = (0, _utils.metadataDictToNode)(metadata, {
                fallback: {
                    id,
                    text: content,
                    ...metadata
                }
            });
            node.setContent(content);
            ids.push(id);
            similarities.push(similarity);
            nodes.push(node);
        }
        return {
            similarities,
            ids,
            nodes
        };
    }
}
