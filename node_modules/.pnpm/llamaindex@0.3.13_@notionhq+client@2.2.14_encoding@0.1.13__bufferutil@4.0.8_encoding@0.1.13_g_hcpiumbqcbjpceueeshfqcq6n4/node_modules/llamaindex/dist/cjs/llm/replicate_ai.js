"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ALL_AVAILABLE_REPLICATE_MODELS: function() {
        return ALL_AVAILABLE_REPLICATE_MODELS;
    },
    DeuceChatStrategy: function() {
        return DeuceChatStrategy;
    },
    LlamaDeuce: function() {
        return LlamaDeuce;
    },
    ReplicateChatStrategy: function() {
        return ReplicateChatStrategy;
    },
    ReplicateLLM: function() {
        return ReplicateLLM;
    },
    ReplicateSession: function() {
        return ReplicateSession;
    }
});
const _env = require("@llamaindex/env");
const _replicate = /*#__PURE__*/ _interop_require_default(require("../internal/deps/replicate.js"));
const _base = require("./base.js");
const _utils = require("./utils.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto;
class ReplicateSession {
    replicateKey = null;
    replicate;
    constructor(replicateKey = null){
        if (replicateKey) {
            this.replicateKey = replicateKey;
        } else if ((0, _env.getEnv)("REPLICATE_API_TOKEN")) {
            this.replicateKey = (0, _env.getEnv)("REPLICATE_API_TOKEN");
        } else {
            throw new Error("Set Replicate token in REPLICATE_API_TOKEN env variable");
        }
        this.replicate = new _replicate.default({
            auth: this.replicateKey
        });
    }
}
const ALL_AVAILABLE_REPLICATE_MODELS = {
    // TODO: add more models from replicate
    "Llama-2-70b-chat-old": {
        contextWindow: 4096,
        replicateApi: "replicate/llama70b-v2-chat:e951f18578850b652510200860fc4ea62b3b16fac280f83ff32282f87bbd2e48"
    },
    "Llama-2-70b-chat-4bit": {
        contextWindow: 4096,
        replicateApi: "meta/llama-2-70b-chat:02e509c789964a7ea8736978a43525956ef40397be9033abf9fd2badfe68c9e3"
    },
    "Llama-2-13b-chat-old": {
        contextWindow: 4096,
        replicateApi: "a16z-infra/llama13b-v2-chat:df7690f1994d94e96ad9d568eac121aecf50684a0b0963b25a41cc40061269e5"
    },
    //^ Last known good 13b non-quantized model. In future versions they add the SYS and INST tags themselves
    "Llama-2-13b-chat-4bit": {
        contextWindow: 4096,
        replicateApi: "meta/llama-2-13b-chat:f4e2de70d66816a838a89eeeb621910adffb0dd0baba3976c96980970978018d"
    },
    "Llama-2-7b-chat-old": {
        contextWindow: 4096,
        replicateApi: "a16z-infra/llama7b-v2-chat:4f0a4744c7295c024a1de15e1a63c880d3da035fa1f49bfd344fe076074c8eea"
    },
    "Llama-2-7b-chat-4bit": {
        contextWindow: 4096,
        replicateApi: "meta/llama-2-7b-chat:13c3cdee13ee059ab779f0291d29054dab00a47dad8261375654de5540165fb0"
    },
    "llama-3-70b-instruct": {
        contextWindow: 8192,
        replicateApi: "meta/meta-llama-3-70b-instruct"
    },
    "llama-3-8b-instruct": {
        contextWindow: 8192,
        replicateApi: "meta/meta-llama-3-8b-instruct"
    }
};
var ReplicateChatStrategy;
(function(ReplicateChatStrategy) {
    ReplicateChatStrategy["A16Z"] = "a16z";
    ReplicateChatStrategy["META"] = "meta";
    ReplicateChatStrategy["METAWBOS"] = "metawbos";
    //^ This is not exactly right because SentencePiece puts the BOS and EOS token IDs in after tokenization
    // Unfortunately any string only API won't support these properly.
    ReplicateChatStrategy["REPLICATE4BIT"] = "replicate4bit";
    //^ To satisfy Replicate's 4 bit models' requirements where they also insert some INST tags
    ReplicateChatStrategy["REPLICATE4BITWNEWLINES"] = "replicate4bitwnewlines";
    //^ Replicate's documentation recommends using newlines: https://replicate.com/blog/how-to-prompt-llama
    ReplicateChatStrategy["LLAMA3"] = "llama3";
})(ReplicateChatStrategy || (ReplicateChatStrategy = {}));
const DeuceChatStrategy = ReplicateChatStrategy;
class ReplicateLLM extends _base.BaseLLM {
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                _utils.wrapLLMEvent,
                2,
                "chat"
            ]
        ], []));
    }
    model;
    chatStrategy;
    temperature;
    topP;
    maxTokens;
    replicateSession;
    constructor(init){
        super();
        _initProto(this);
        if (!init?.model && !init?.noWarn) {
            console.warn("The default model has been changed to llama-3-70b-instruct. Set noWarn to true to suppress this warning.");
        }
        this.model = init?.model ?? "llama-3-70b-instruct";
        this.chatStrategy = init?.chatStrategy ?? (this.model.startsWith("llama-3") ? "llama3" : this.model.endsWith("4bit") ? "replicate4bitwnewlines" : "metawbos"); // With BOS and EOS seems to work best, although they all have problems past a certain point
        this.temperature = init?.temperature ?? 0.1; // minimum temperature is 0.01 for Replicate endpoint
        this.topP = init?.topP ?? (this.model.startsWith("llama-3") ? 0.9 : 1); // llama-3 defaults to 0.9 top P
        this.maxTokens = init?.maxTokens ?? ALL_AVAILABLE_REPLICATE_MODELS[this.model].contextWindow; // For Replicate, the default is 500 tokens which is too low.
        this.replicateSession = init?.replicateSession ?? new ReplicateSession();
    }
    get metadata() {
        return {
            model: this.model,
            temperature: this.temperature,
            topP: this.topP,
            maxTokens: this.maxTokens,
            contextWindow: ALL_AVAILABLE_REPLICATE_MODELS[this.model].contextWindow,
            tokenizer: undefined
        };
    }
    mapMessagesToPrompt(messages) {
        if (this.chatStrategy === "llama3") {
            return this.mapMessagesToPromptLlama3(messages);
        } else if (this.chatStrategy === "a16z") {
            return this.mapMessagesToPromptA16Z(messages);
        } else if (this.chatStrategy === "meta") {
            return this.mapMessagesToPromptMeta(messages);
        } else if (this.chatStrategy === "metawbos") {
            return this.mapMessagesToPromptMeta(messages, {
                withBos: true
            });
        } else if (this.chatStrategy === "replicate4bit") {
            return this.mapMessagesToPromptMeta(messages, {
                replicate4Bit: true,
                withNewlines: true
            });
        } else if (this.chatStrategy === "replicate4bitwnewlines") {
            return this.mapMessagesToPromptMeta(messages, {
                replicate4Bit: true,
                withNewlines: true
            });
        } else {
            return this.mapMessagesToPromptMeta(messages);
        }
    }
    mapMessagesToPromptLlama3(messages) {
        return {
            prompt: "<|begin_of_text|>" + messages.reduce((acc, message)=>{
                let content = "";
                if (typeof message.content === "string") {
                    content = message.content;
                } else {
                    if (message.content[0].type === "text") {
                        content = message.content[0].text;
                    } else {
                        content = "";
                    }
                }
                return acc + `<|start_header_id|>${message.role}<|end_header_id|>\n\n${content}<|eot_id|>`;
            }, "") + "<|start_header_id|>assistant<|end_header_id|>\n\n",
            systemPrompt: undefined
        };
    }
    mapMessagesToPromptA16Z(messages) {
        return {
            prompt: messages.reduce((acc, message)=>{
                return (acc && `${acc}\n\n`) + `${this.mapMessageTypeA16Z(message.role)}${message.content}`;
            }, "") + "\n\nAssistant:",
            //^ Here we're differing from A16Z by omitting the space. Generally spaces at the end of prompts decrease performance due to tokenization
            systemPrompt: undefined
        };
    }
    mapMessageTypeA16Z(messageType) {
        switch(messageType){
            case "user":
                return "User: ";
            case "assistant":
                return "Assistant: ";
            case "system":
                return "";
            default:
                throw new Error("Unsupported ReplicateLLM message type");
        }
    }
    mapMessagesToPromptMeta(messages, opts) {
        const { withBos = false, replicate4Bit = false, withNewlines = false } = opts ?? {};
        const DEFAULT_SYSTEM_PROMPT = `You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`;
        const B_SYS = "<<SYS>>\n";
        const E_SYS = "\n<</SYS>>\n\n";
        const B_INST = "[INST]";
        const E_INST = "[/INST]";
        const BOS = "<s>";
        const EOS = "</s>";
        if (messages.length === 0) {
            return {
                prompt: "",
                systemPrompt: undefined
            };
        }
        messages = [
            ...messages
        ]; // so we can use shift without mutating the original array
        let systemPrompt = undefined;
        if (messages[0].role === "system") {
            const systemMessage = messages.shift();
            if (replicate4Bit) {
                systemPrompt = systemMessage.content;
            } else {
                const systemStr = `${B_SYS}${systemMessage.content}${E_SYS}`;
                // TS Bug: https://github.com/microsoft/TypeScript/issues/9998
                // @ts-ignore
                if (messages[0].role !== "user") {
                    throw new Error("ReplicateLLM: if there is a system message, the second message must be a user message.");
                }
                const userContent = messages[0].content;
                messages[0].content = `${systemStr}${userContent}`;
            }
        } else {
            if (!replicate4Bit) {
                messages[0].content = `${B_SYS}${DEFAULT_SYSTEM_PROMPT}${E_SYS}${messages[0].content}`;
            }
        }
        return {
            prompt: messages.reduce((acc, message, index)=>{
                const content = (0, _utils.extractText)(message.content);
                if (index % 2 === 0) {
                    return `${acc}${withBos ? BOS : ""}${B_INST} ${content.trim()} ${E_INST}` + (withNewlines ? "\n" : "");
                } else {
                    return `${acc} ${content.trim()}` + (withNewlines ? "\n" : " ") + (withBos ? EOS : ""); // Yes, the EOS comes after the space. This is not a mistake.
                }
            }, ""),
            systemPrompt
        };
    }
    async chat(params) {
        const { messages, stream } = params;
        const api = ALL_AVAILABLE_REPLICATE_MODELS[this.model].replicateApi;
        const { prompt, systemPrompt } = this.mapMessagesToPrompt(messages);
        const replicateOptions = {
            input: {
                prompt,
                system_prompt: systemPrompt,
                temperature: this.temperature,
                top_p: this.topP
            }
        };
        if (this.model.endsWith("4bit")) {
            replicateOptions.input.max_new_tokens = this.maxTokens;
        } else {
            replicateOptions.input.max_length = this.maxTokens;
        }
        if (this.model.startsWith("llama-3")) {
            replicateOptions.input.prompt_template = "{prompt}";
        }
        if (stream) {
            const controller = new AbortController();
            const stream = this.replicateSession.replicate.stream(api, {
                ...replicateOptions,
                signal: controller.signal
            });
            // replicate.stream is not closing if used as AsyncIterable, force closing after consumption with the AbortController
            return (0, _utils.streamCallbacks)((0, _utils.streamConverter)(stream, (chunk)=>{
                if (chunk.event === "done") {
                    return null;
                }
                return {
                    raw: chunk,
                    delta: chunk.data
                };
            }), {
                finished: ()=>controller.abort()
            });
        }
        //Non-streaming
        const response = await this.replicateSession.replicate.run(api, replicateOptions);
        return {
            raw: response,
            message: {
                content: response.join("").trimStart(),
                //^ We need to do this because Replicate returns a list of strings (for streaming functionality which is not exposed by the run function)
                role: "assistant"
            }
        };
    }
}
const LlamaDeuce = ReplicateLLM;
