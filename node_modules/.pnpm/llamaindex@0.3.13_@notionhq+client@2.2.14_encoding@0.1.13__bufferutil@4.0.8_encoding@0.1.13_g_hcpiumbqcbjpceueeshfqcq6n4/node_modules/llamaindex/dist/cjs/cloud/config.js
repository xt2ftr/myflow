"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getPipelineCreate", {
    enumerable: true,
    get: function() {
        return getPipelineCreate;
    }
});
const _Node = require("../Node.js");
const _OpenAIEmbedding = require("../embeddings/OpenAIEmbedding.js");
const _SimpleNodeParser = require("../nodeParsers/SimpleNodeParser.js");
function getTransformationConfig(transformation) {
    if (transformation instanceof _SimpleNodeParser.SimpleNodeParser) {
        return {
            configurableTransformationType: "SENTENCE_AWARE_NODE_PARSER",
            component: {
                // TODO: API doesnt accept camelCase
                chunk_size: transformation.textSplitter.chunkSize,
                chunk_overlap: transformation.textSplitter.chunkOverlap,
                include_metadata: transformation.includeMetadata,
                include_prev_next_rel: transformation.includePrevNextRel
            }
        };
    }
    if (transformation instanceof _OpenAIEmbedding.OpenAIEmbedding) {
        return {
            configurableTransformationType: "OPENAI_EMBEDDING",
            component: {
                // TODO: API doesnt accept camelCase
                model: transformation.model,
                api_key: transformation.apiKey,
                embed_batch_size: transformation.embedBatchSize,
                dimensions: transformation.dimensions
            }
        };
    }
    throw new Error(`Unsupported transformation: ${typeof transformation}`);
}
function getDataSourceConfig(node) {
    if (node instanceof _Node.Document) {
        return {
            name: node.id_,
            sourceType: "DOCUMENT",
            component: {
                id: node.id_,
                text: node.text,
                textTemplate: node.textTemplate,
                startCharIdx: node.startCharIdx,
                endCharIdx: node.endCharIdx,
                metadataSeparator: node.metadataSeparator,
                excludedEmbedMetadataKeys: node.excludedEmbedMetadataKeys,
                excludedLlmMetadataKeys: node.excludedLlmMetadataKeys,
                extraInfo: node.metadata
            }
        };
    }
    throw new Error(`Unsupported node: ${typeof node}`);
}
async function getPipelineCreate(params) {
    const { pipelineName, pipelineType, transformations = [], inputNodes = [] } = params;
    const dataSources = inputNodes.map(getDataSourceConfig);
    return {
        name: pipelineName,
        configuredTransformations: transformations.map(getTransformationConfig),
        dataSources,
        dataSinks: [],
        pipelineType
    };
}
