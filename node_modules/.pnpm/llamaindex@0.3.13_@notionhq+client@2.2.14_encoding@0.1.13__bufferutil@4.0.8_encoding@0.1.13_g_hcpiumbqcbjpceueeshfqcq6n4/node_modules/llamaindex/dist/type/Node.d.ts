export declare enum NodeRelationship {
    SOURCE = "SOURCE",
    PREVIOUS = "PREVIOUS",
    NEXT = "NEXT",
    PARENT = "PARENT",
    CHILD = "CHILD"
}
export declare enum ObjectType {
    TEXT = "TEXT",
    IMAGE = "IMAGE",
    INDEX = "INDEX",
    DOCUMENT = "DOCUMENT",
    IMAGE_DOCUMENT = "IMAGE_DOCUMENT"
}
export declare enum MetadataMode {
    ALL = "ALL",
    EMBED = "EMBED",
    LLM = "LLM",
    NONE = "NONE"
}
export type Metadata = Record<string, any>;
export interface RelatedNodeInfo<T extends Metadata = Metadata> {
    nodeId: string;
    nodeType?: ObjectType;
    metadata: T;
    hash?: string;
}
export type RelatedNodeType<T extends Metadata = Metadata> = RelatedNodeInfo<T> | RelatedNodeInfo<T>[];
export type BaseNodeParams<T extends Metadata = Metadata> = {
    id_?: string;
    metadata?: T;
    excludedEmbedMetadataKeys?: string[];
    excludedLlmMetadataKeys?: string[];
    relationships?: Partial<Record<NodeRelationship, RelatedNodeType<T>>>;
    hash?: string;
    embedding?: number[];
};
/**
 * Generic abstract class for retrievable nodes
 */
export declare abstract class BaseNode<T extends Metadata = Metadata> {
    /**
     * The unique ID of the Node/Document. The trailing underscore is here
     * to avoid collisions with the id keyword in Python.
     *
     * Set to a UUID by default.
     */
    id_: string;
    embedding?: number[];
    metadata: T;
    excludedEmbedMetadataKeys: string[];
    excludedLlmMetadataKeys: string[];
    relationships: Partial<Record<NodeRelationship, RelatedNodeType<T>>>;
    accessor hash: string;
    protected constructor(init?: BaseNodeParams<T>);
    abstract get type(): ObjectType;
    abstract getContent(metadataMode: MetadataMode): string;
    abstract getMetadataStr(metadataMode: MetadataMode): string;
    abstract setContent(value: unknown): void;
    get sourceNode(): RelatedNodeInfo<T> | undefined;
    get prevNode(): RelatedNodeInfo<T> | undefined;
    get nextNode(): RelatedNodeInfo<T> | undefined;
    get parentNode(): RelatedNodeInfo<T> | undefined;
    get childNodes(): RelatedNodeInfo<T>[] | undefined;
    abstract generateHash(): string;
    getEmbedding(): number[];
    asRelatedNodeInfo(): RelatedNodeInfo<T>;
    /**
     * Called by built in JSON.stringify (see https://javascript.info/json)
     * Properties are read-only as they are not deep-cloned (not necessary for stringification).
     * @see toMutableJSON - use to return a mutable JSON instead
     */
    toJSON(): Record<string, any>;
    clone(): BaseNode;
    /**
     * Converts the object to a JSON representation.
     * Properties can be safely modified as a deep clone of the properties are created.
     * @return {Record<string, any>} - The JSON representation of the object.
     */
    toMutableJSON(): Record<string, any>;
}
export type TextNodeParams<T extends Metadata = Metadata> = BaseNodeParams<T> & {
    text?: string;
    textTemplate?: string;
    startCharIdx?: number;
    endCharIdx?: number;
    metadataSeparator?: string;
};
/**
 * TextNode is the default node type for text. Most common node type in LlamaIndex.TS
 */
export declare class TextNode<T extends Metadata = Metadata> extends BaseNode<T> {
    text: string;
    textTemplate: string;
    startCharIdx?: number;
    endCharIdx?: number;
    metadataSeparator: string;
    constructor(init?: TextNodeParams<T>);
    /**
     * Generate a hash of the text node.
     * The ID is not part of the hash as it can change independent of content.
     * @returns
     */
    generateHash(): string;
    get type(): ObjectType;
    getContent(metadataMode?: MetadataMode): string;
    getMetadataStr(metadataMode: MetadataMode): string;
    setContent(value: string): void;
    getNodeInfo(): {
        start: number | undefined;
        end: number | undefined;
    };
    getText(): string;
}
export type IndexNodeParams<T extends Metadata = Metadata> = TextNodeParams<T> & {
    indexId: string;
};
export declare class IndexNode<T extends Metadata = Metadata> extends TextNode<T> {
    indexId: string;
    constructor(init?: IndexNodeParams<T>);
    get type(): ObjectType;
}
/**
 * A document is just a special text node with a docId.
 */
export declare class Document<T extends Metadata = Metadata> extends TextNode<T> {
    constructor(init?: TextNodeParams<T>);
    get type(): ObjectType;
}
export declare function jsonToNode(json: any, type?: ObjectType): TextNode<Metadata>;
export type ImageType = string | Blob | URL;
export type ImageNodeParams<T extends Metadata = Metadata> = TextNodeParams<T> & {
    image: ImageType;
};
export declare class ImageNode<T extends Metadata = Metadata> extends TextNode<T> {
    image: ImageType;
    constructor(init: ImageNodeParams<T>);
    get type(): ObjectType;
    getUrl(): URL;
    private generateImageHash;
    generateHash(): string;
}
export declare class ImageDocument<T extends Metadata = Metadata> extends ImageNode<T> {
    constructor(init: ImageNodeParams<T>);
    get type(): ObjectType;
}
/**
 * A node with a similarity score
 */
export interface NodeWithScore<T extends Metadata = Metadata> {
    node: BaseNode<T>;
    score?: number;
}
export declare enum ModalityType {
    TEXT = "TEXT",
    IMAGE = "IMAGE"
}
type NodesByType = {
    [P in ModalityType]?: BaseNode[];
};
export declare function splitNodesByType(nodes: BaseNode[]): NodesByType;
export {};
