import type { SummaryPrompt } from "./Prompt.js";
import type { ChatMessage, LLM } from "./llm/types.js";
/**
 * A ChatHistory is used to keep the state of back and forth chat messages
 */
export declare abstract class ChatHistory<AdditionalMessageOptions extends object = object> {
    abstract get messages(): ChatMessage<AdditionalMessageOptions>[];
    /**
     * Adds a message to the chat history.
     * @param message
     */
    abstract addMessage(message: ChatMessage<AdditionalMessageOptions>): void;
    /**
     * Returns the messages that should be used as input to the LLM.
     */
    abstract requestMessages(transientMessages?: ChatMessage<AdditionalMessageOptions>[]): Promise<ChatMessage<AdditionalMessageOptions>[]>;
    /**
     * Resets the chat history so that it's empty.
     */
    abstract reset(): void;
    /**
     * Returns the new messages since the last call to this function (or since calling the constructor)
     */
    abstract newMessages(): ChatMessage<AdditionalMessageOptions>[];
}
export declare class SimpleChatHistory extends ChatHistory {
    messages: ChatMessage[];
    private messagesBefore;
    constructor(init?: Partial<SimpleChatHistory>);
    addMessage(message: ChatMessage): void;
    requestMessages(transientMessages?: ChatMessage[]): Promise<ChatMessage[]>;
    reset(): void;
    newMessages(): ChatMessage[];
}
export declare class SummaryChatHistory extends ChatHistory {
    /**
     * Tokenizer function that converts text to tokens,
     *  this is used to calculate the number of tokens in a message.
     */
    tokenizer: (text: string) => Uint32Array;
    tokensToSummarize: number;
    messages: ChatMessage[];
    summaryPrompt: SummaryPrompt;
    llm: LLM;
    private messagesBefore;
    constructor(init?: Partial<SummaryChatHistory>);
    private summarize;
    addMessage(message: ChatMessage): void;
    private getLastSummaryIndex;
    getLastSummary(): ChatMessage | null;
    private get systemMessages();
    private get nonSystemMessages();
    /**
     * Calculates the messages that describe the conversation so far.
     * If there's no memory, all non-system messages are used.
     * If there's a memory, uses all messages after the last summary message.
     */
    private calcConversationMessages;
    private calcCurrentRequestMessages;
    requestMessages(transientMessages?: ChatMessage[]): Promise<ChatMessage[]>;
    reset(): void;
    newMessages(): ChatMessage[];
}
export declare function getHistory(chatHistory?: ChatMessage[] | ChatHistory): ChatHistory;
