import { AsyncLocalStorage, randomUUID } from "@llamaindex/env";
import { isAsyncIterable, isIterable } from "../utils.js";
const eventReasonAsyncLocalStorage = new AsyncLocalStorage();
/**
 * EventCaller is used to track the caller of an event.
 */ export class EventCaller {
    caller;
    parent;
    id;
    constructor(caller, parent){
        this.caller = caller;
        this.parent = parent;
        this.id = randomUUID();
        this.#computedCallers = null;
    }
    #computedCallers;
    get computedCallers() {
        if (this.#computedCallers != null) {
            return this.#computedCallers;
        }
        const callers = [
            this.caller
        ];
        let parent = this.parent;
        while(parent != null){
            callers.push(parent.caller);
            parent = parent.parent;
        }
        this.#computedCallers = callers;
        return callers;
    }
    static create(caller, parent) {
        return new EventCaller(caller, parent);
    }
}
export function getEventCaller() {
    return eventReasonAsyncLocalStorage.getStore() ?? null;
}
/**
 * @param caller who is calling this function, pass in `this` if it's a class method
 * @param fn
 */ function withEventCaller(caller, fn) {
    // create a chain of event callers
    const parentCaller = getEventCaller();
    return eventReasonAsyncLocalStorage.run(EventCaller.create(caller, parentCaller), fn);
}
export function wrapEventCaller(originalMethod, context) {
    const name = context.name;
    context.addInitializer(function() {
        // @ts-expect-error
        const fn = this[name].bind(this);
        // @ts-expect-error
        this[name] = (...args)=>{
            return withEventCaller(this, ()=>fn(...args));
        };
    });
    return function(...args) {
        const result = originalMethod.call(this, ...args);
        // patch for iterators because AsyncLocalStorage doesn't work with them
        if (isAsyncIterable(result)) {
            const iter = result[Symbol.asyncIterator]();
            const snapshot = AsyncLocalStorage.snapshot();
            return async function* asyncGeneratorWrapper() {
                while(true){
                    const { value, done } = await snapshot(()=>iter.next());
                    if (done) {
                        break;
                    }
                    yield value;
                }
            }();
        } else if (isIterable(result)) {
            const iter = result[Symbol.iterator]();
            const snapshot = AsyncLocalStorage.snapshot();
            return function* generatorWrapper() {
                while(true){
                    const { value, done } = snapshot(()=>iter.next());
                    if (done) {
                        break;
                    }
                    yield value;
                }
            }();
        }
        return result;
    };
}
