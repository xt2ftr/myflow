{"version":3,"sources":["../src/api/index.ts","../src/api/metadata.ts","../package.json","../src/constants.ts","../src/sandbox/terminal.ts","../src/utils/timeout.js","../src/utils/promise.ts","../src/sandbox/filesystem.ts","../src/sandbox/filesystemWatcher.ts","../src/error.ts","../src/sandbox/process.ts","../src/sandbox/index.ts","../src/utils/id.ts","../src/sandbox/codeSnippet.ts","../src/sandbox/rpc.ts","../src/utils/wait.ts","../src/utils/apiKey.ts","../src/sandbox/sandboxConnection.ts","../src/utils/filesystem.ts","../src/index.ts"],"sourcesContent":["import * as fetcher from 'openapi-typescript-fetch'\nimport type { OpArgType, TypedFetch } from 'openapi-typescript-fetch'\n\nimport type { components, paths } from './schema.gen'\nimport { defaultHeaders } from './metadata'\nimport { DEBUG, DOMAIN, SECURE } from '../constants'\n\nconst { Fetcher } = fetcher\n\nclass APIClient {\n  private client = Fetcher.for<paths>()\n\n  constructor(private opts?: {\n    secure?: boolean,\n    domain?: string,\n    debug?: boolean,\n  }\n  ) {\n    this.client.configure({\n      baseUrl: this.apiHost,\n      init: {\n        headers: defaultHeaders,\n      },\n    })\n  }\n\n  get secure() {\n    return this.opts?.secure ?? SECURE\n  }\n\n  get domain() {\n    return this.opts?.domain ?? DOMAIN\n  }\n\n  get debug() {\n    return this.opts?.debug ?? DEBUG\n  }\n\n  get apiDomain() {\n    return this.debug ? 'localhost:3000' : `api.${this.domain}`\n  }\n\n  get apiHost() {\n    return `${this.secure && !this.debug ? 'https' : 'http'}://${this.apiDomain}`\n  }\n\n  get api() {\n    return this.client\n  }\n}\n\ntype WithAccessToken<T> = (\n  accessToken: string,\n  arg: OpArgType<T>,\n  init?: RequestInit,\n) => ReturnType<TypedFetch<T>>\n\nexport function withAccessToken<T>(f: TypedFetch<T>) {\n  const wrapped = (accessToken: string, arg: OpArgType<T>, init?: RequestInit) => {\n    return f(arg, {\n      ...init,\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        ...init?.headers,\n      },\n    })\n  }\n\n  wrapped.Error = f.Error\n\n  return wrapped as WithAccessToken<T> & {\n    Error: typeof f.Error\n  }\n}\n\ntype WithAPIKey<T> = (\n  apiKey: string,\n  arg: OpArgType<T>,\n  init?: RequestInit,\n) => ReturnType<TypedFetch<T>>\n\nexport function withAPIKey<T>(f: TypedFetch<T>) {\n  const wrapped = (apiKey: string, arg: OpArgType<T>, init?: RequestInit) => {\n    return f(arg, {\n      ...init,\n      headers: {\n        'X-API-KEY': apiKey,\n        ...init?.headers,\n      },\n    })\n  }\n\n  wrapped.Error = f.Error\n\n  return wrapped as WithAPIKey<T> & {\n    Error: typeof f.Error\n  }\n}\n\nexport type { components, paths }\nexport { APIClient }\n","import platform from 'platform'\n\nimport { version } from '../../package.json'\n\ndeclare let window: any\n\nexport const defaultHeaders = {\n  browser: (typeof window !== 'undefined' && platform.name) || 'undefined',\n  lang: 'js',\n  lang_version: platform.version || 'unknown',\n  package_version: version,\n  publisher: 'e2b',\n  sdk_runtime: typeof window === 'undefined' ? 'node' : 'browser',\n  system: platform.os?.family || 'unknown',\n}\n","{\n  \"name\": \"e2b\",\n  \"version\": \"0.16.1\",\n  \"description\": \"E2B SDK that give agents cloud environments\",\n  \"homepage\": \"https://e2b.dev\",\n  \"license\": \"MIT\",\n  \"author\": {\n    \"name\": \"FoundryLabs, Inc.\",\n    \"email\": \"hello@e2b.dev\",\n    \"url\": \"https://e2b.dev\"\n  },\n  \"bugs\": \"https://github.com/e2b-dev/e2b/issues\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/e2b-dev/e2b\",\n    \"directory\": \"packages/js-sdk\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"sideEffects\": false,\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.mjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"prepublishOnly\": \"pnpm build\",\n    \"build\": \"tsc --noEmit && tsup\",\n    \"dev\": \"tsup --watch\",\n    \"measure\": \"node test/performance.mjs\",\n    \"example\": \"tsx example.mts\",\n    \"test\": \"vitest run\",\n    \"test:coverage\": \"vitest run --coverage\",\n    \"generate\": \"openapi-typescript ../../spec/openapi.yml -x api_key --support-array-length --alphabetize --output src/api/schema.gen.ts\",\n    \"check-deps\": \"knip\",\n    \"update-deps\": \"ncu -u && pnpm i\",\n    \"postPublish\": \"./scripts/post-publish.sh || true\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^18.18.6\",\n    \"@types/normalize-path\": \"^3.0.0\",\n    \"@types/path-browserify\": \"^1.0.1\",\n    \"@types/platform\": \"^1.3.4\",\n    \"@types/ws\": \"^8.5.10\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.8.0\",\n    \"@typescript-eslint/parser\": \"^6.8.0\",\n    \"dotenv\": \"^16.4.5\",\n    \"knip\": \"^2.34.0\",\n    \"npm-check-updates\": \"^16.14.6\",\n    \"openapi-typescript\": \"^5.4.1\",\n    \"tsup\": \"^6.7.0\",\n    \"typescript\": \"^5.2.2\",\n    \"vitest\": \"^0.34.6\"\n  },\n  \"files\": [\n    \"dist\",\n    \"README.md\",\n    \"package.json\"\n  ],\n  \"keywords\": [\n    \"e2b\",\n    \"ai-agents\",\n    \"agents\",\n    \"ai\",\n    \"code-interpreter\",\n    \"sandbox\",\n    \"code\",\n    \"runtime\",\n    \"vm\",\n    \"nodejs\",\n    \"javascript\",\n    \"typescript\"\n  ],\n  \"dependencies\": {\n    \"isomorphic-ws\": \"^5.0.0\",\n    \"normalize-path\": \"^3.0.0\",\n    \"openapi-typescript-fetch\": \"^1.1.3\",\n    \"path-browserify\": \"^1.0.1\",\n    \"platform\": \"^1.3.6\",\n    \"ws\": \"^8.15.1\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"browserslist\": [\n    \"defaults\"\n  ],\n  \"optionalDependencies\": {\n    \"bufferutil\": \"^4.0.8\",\n    \"utf-8-validate\": \"^6.0.3\"\n  }\n}\n","export const SANDBOX_REFRESH_PERIOD = 5_000 // 5s\nexport const WS_RECONNECT_INTERVAL = 150 // 150ms\n\nexport const TIMEOUT = 60_000 // 60s\nexport const DEBUG = process?.env?.E2B_DEBUG\nexport const DOMAIN = process?.env?.E2B_DOMAIN || 'e2b.dev'\nexport const SECURE = (process?.env?.E2B_SECURE || 'true').toLowerCase() === 'true'\nexport const API_DOMAIN = DEBUG ? 'localhost:3000' : `api.${DOMAIN}`\nexport const API_HOST = `${SECURE && !DEBUG ? 'https' : 'http'}://${API_DOMAIN}`\nexport const SANDBOX_DOMAIN = DOMAIN\n\nexport const ENVD_PORT = 49982\nexport const WS_ROUTE = '/ws'\n\nexport const FILE_ROUTE = '/file'\n","import { EnvVars } from './envVars'\nimport { SandboxConnection } from './sandboxConnection'\n\nexport const terminalService = 'terminal'\n\nexport class TerminalOutput {\n  private _data = ''\n\n  get data() {\n    return this._data\n  }\n\n  addData(data: string) {\n    this._data += data\n  }\n}\n\n/**\n * A terminal session running in the sandbox.\n *\n */\nexport class Terminal {\n  /**\n   * @deprecated use .wait() instead\n   */\n  readonly finished: Promise<TerminalOutput>\n\n  constructor(\n    readonly terminalID: string,\n    private readonly sandbox: SandboxConnection,\n    private readonly triggerExit: () => void,\n    finished: Promise<TerminalOutput>,\n    readonly output: TerminalOutput,\n  ) {\n    this.finished = finished\n  }\n\n  get data() {\n    return this.output.data\n  }\n\n  /**\n   * Kills the terminal session.\n   */\n  async kill(): Promise<void> {\n    try {\n      // TODO: Change the \"destroy\" to \"kill\" in devbookd\n      await this.sandbox._call(terminalService, 'destroy', [this.terminalID])\n    } finally {\n      this.triggerExit()\n      await this.finished\n    }\n  }\n\n  /**\n   * Waits for the terminal to finish.\n   */\n  async wait(): Promise<TerminalOutput> {\n    return this.finished\n  }\n\n  /**\n   * Sends data to the terminal standard input.\n   *\n   * @param data Data to send\n   */\n  async sendData(data: string): Promise<void> {\n    await this.sandbox._call(terminalService, 'data', [this.terminalID, data])\n  }\n\n  /**\n   * Resizes the terminal tty.\n   *\n   * @param cols Number of columns\n   * @param rows Number of rows\n   */\n  async resize({ cols, rows }: { cols: number; rows: number }): Promise<void> {\n    await this.sandbox._call(terminalService, 'resize', [\n      this.terminalID,\n      cols,\n      rows,\n    ])\n  }\n}\n\nexport type TerminalOpts = {\n  onData: (data: string) => Promise<void> | void;\n  onExit?: () => Promise<void> | void;\n  size: { cols: number; rows: number };\n  terminalID?: string;\n  /**\n   * If the `cmd` parameter is defined it will be executed as a command\n   * and this terminal session will exit when the command exits.\n   */\n  cmd?: string;\n  /**\n   * Working directory where will the terminal start.\n   */\n  cwd?: string;\n  /**\n   * @deprecated use cwd instead\n   */\n  rootDir?: string;\n  /**\n   * Environment variables that will be accessible inside of the terminal.\n   */\n  envVars?: EnvVars;\n  /**\n   * Timeout for terminal start in milliseconds (default is 60 seconds)\n   */\n  timeout?: number;\n}\n\n/**\n * Manager for starting and interacting with terminal sessions in the sandbox.\n */\nexport interface TerminalManager {\n  start(opts: TerminalOpts): Promise<Terminal>;\n}\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message)\n\t\tthis.name = 'TimeoutError'\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper()\n\t\tthis.name = 'AbortError'\n\t\tthis.message = message\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage)\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason\n\n\treturn reason instanceof Error ? reason : getDOMException(reason)\n}\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = { setTimeout, clearTimeout },\n\t} = options\n\n\tlet timer\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``)\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst { signal } = options\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal))\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal))\n\t\t\t})\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject)\n\t\t\treturn\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError()\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback())\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error)\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel()\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve()\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message)\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`\n\t\t\t\treject(timeoutError)\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise)\n\t\t\t} catch (error) {\n\t\t\t\treject(error)\n\t\t\t}\n\t\t})()\n\t})\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear()\n\t})\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer)\n\t\ttimer = undefined\n\t}\n\n\treturn cancelablePromise\n}","import pTimeout from './timeout'\n\nimport { TIMEOUT } from '../constants'\n\nexport function assertFulfilled<T>(\n  item: PromiseSettledResult<T>,\n): item is PromiseFulfilledResult<T> {\n  return item.status === 'fulfilled'\n}\n\nexport function formatSettledErrors<T>(settled: PromiseSettledResult<T>[]) {\n  if (settled.every(s => s.status === 'fulfilled')) return\n\n  return settled.reduce((prev, curr, i) => {\n    if (curr.status === 'rejected') {\n      return prev + '\\n' + `[${i}]: ` + `${JSON.stringify(curr)}`\n    }\n    return prev\n  }, 'errors:\\n')\n}\n\nexport function createDeferredPromise<T = void>() {\n  let resolve: (value: T) => void\n  let reject: (reason?: unknown) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withTimeout<T extends (...args: any[]) => any>(\n  fn: T,\n  timeout: number = TIMEOUT,\n): T {\n  if (timeout === undefined || timeout <= 0 || timeout === Number.POSITIVE_INFINITY) {\n    return fn\n  }\n\n  return ((...args: T extends (...args: infer A) => any ? A : never) =>\n    pTimeout(fn(...args), { milliseconds: timeout })) as T\n}\n","import FilesystemWatcher from './filesystemWatcher'\nimport { CallOpts } from './sandboxConnection'\n\nexport const filesystemService = 'filesystem'\n\nexport interface FileInfo {\n  isDir: boolean;\n  name: string\n}\n\n/**\n * Manager for interacting with the filesystem in the sandbox.\n */\nexport interface FilesystemManager {\n  /**\n   * Writes content to a new file on path.\n   * @param path Path to a new file. For example '/dirA/dirB/newFile.txt' when creating 'newFile.txt'\n   * @param content Content to write to a new file\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)\n   */\n  write(path: string, content: string, opts?: CallOpts): Promise<void>;\n  /**\n   * Write array of bytes to a file.\n   * This can be used when you cannot represent the data as an UTF-8 string.\n   *\n   * A new file will be created if it doesn't exist.\n   * If the file already exists, it will be overwritten.\n   * \n   * @param path path to a file\n   * @param content byte array representing the content to write\n   */\n  writeBytes(path: string, content: Uint8Array): Promise<void>;\n  /**\n   * Reads the whole content of a file.\n   * @param path Path to a file\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)\n   * @returns Content of a file\n   */\n  read(path: string, opts?: CallOpts): Promise<string>;\n  /**\n   * Reads the whole content of a file as an array of bytes.\n   * @param path path to a file\n   * @returns byte array representing the content of a file\n   */\n  readBytes(path: string): Promise<Uint8Array>;\n  /**\n   * Removes a file or a directory.\n   * @param path Path to a file or a directory\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)\n   */\n  remove(path: string, opts?: CallOpts): Promise<void>;\n  /**\n   * List files in a directory.\n   * @param path Path to a directory\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)\n   * @returns Array of files in a directory\n   */\n  list(path: string, opts?: CallOpts): Promise<FileInfo[]>;\n  /**\n   * Creates a new directory and all directories along the way if needed on the specified pth.\n   * @param path Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)\n   */\n  makeDir(path: string, opts?: CallOpts): Promise<void>;\n  /**\n   * Watches directory for filesystem events.\n   * @param path Path to a directory that will be watched\n   * @returns New watcher\n   */\n  watchDir(path: string): FilesystemWatcher;\n}\n","import { withTimeout } from '../utils/promise'\nimport { filesystemService } from './filesystem'\nimport { CallOpts, SandboxConnection } from './sandboxConnection'\n\nexport enum FilesystemOperation {\n  Create = 'Create',\n  Write = 'Write',\n  Remove = 'Remove',\n  Rename = 'Rename',\n  Chmod = 'Chmod',\n}\n\nexport interface FilesystemEvent {\n  path: string;\n  name: string;\n  operation: FilesystemOperation;\n  // Unix epoch in nanoseconds\n  timestamp: number;\n  isDir: boolean;\n}\n\nexport type FilesystemEventListener = (event: FilesystemEvent) => Promise<void> | void\n\nclass FilesystemWatcher {\n  // Listeners to filesystem events.\n  // Users of the this class can add their listeners to filesystem events\n  // via `this.addEventListeners`\n  private listeners: Set<FilesystemEventListener>\n  private rpcSubscriptionID?: string\n\n  constructor(\n    private sessConn: SandboxConnection,\n    private path: string,\n  ) {\n    this.listeners = new Set<FilesystemEventListener>()\n  }\n\n  // Starts watching the path that was passed to the contructor\n  async start(opts?: CallOpts) {\n    const start = async () => {\n      // Already started.\n      if (this.rpcSubscriptionID) return\n\n      this.handleFilesystemEvents = this.handleFilesystemEvents.bind(this)\n\n      this.rpcSubscriptionID = await this.sessConn._subscribe(\n        filesystemService,\n        this.handleFilesystemEvents,\n        'watchDir',\n        this.path,\n      )\n    }\n    return await withTimeout(start, opts?.timeout)()\n  }\n\n  // Stops watching the path and removes all listeners.\n  async stop() {\n    this.listeners.clear()\n    if (this.rpcSubscriptionID) {\n      await this.sessConn._unsubscribe(this.rpcSubscriptionID)\n    }\n  }\n\n  addEventListener(l: FilesystemEventListener) {\n    this.listeners.add(l)\n    return () => this.listeners.delete(l)\n  }\n\n  private handleFilesystemEvents(fsChange: FilesystemEvent) {\n    this.listeners.forEach((l) => {\n      l(fsChange)\n    })\n  }\n}\n\nexport default FilesystemWatcher\n","export class TimeoutError extends Error {\n  constructor(message: any) {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\nexport class AuthenticationError extends Error {\n  constructor(message: any) {\n    super(message)\n    this.name = 'AuthenticationError'\n  }\n}\n\nexport class CurrentWorkingDirectoryDoesntExistError extends Error {\n  constructor(message: any) {\n    super(message)\n    this.name = 'CurrentWorkingDirectoryDoesntExistError'\n  }\n}","import { EnvVars } from './envVars'\nimport { CallOpts, SandboxConnection } from './sandboxConnection'\nimport { withTimeout } from '../utils/promise'\n\nexport const processService = 'process'\n\n/**\n * A message from a process.\n */\nexport class ProcessMessage {\n  constructor(\n    public readonly line: string,\n    /**\n     * Unix epoch in nanoseconds\n     */\n    public readonly timestamp: number,\n    public readonly error: boolean,\n  ) {\n  }\n\n  public toString() {\n    return this.line\n  }\n}\n\n/**\n * Output from a process.\n */\nexport class ProcessOutput {\n  private readonly delimiter = '\\n'\n  private readonly messages: ProcessMessage[] = []\n  private _finished = false\n\n  private _error = false\n\n  private _exitCode?: number\n\n  /**\n   * Whether the process has errored.\n   */\n  get error(): boolean {\n    return this._error\n  }\n\n\n  /**\n   * The exit code of the process.\n   */\n  get exitCode(): number | undefined {\n    if (!this._finished) {\n      throw new Error('Process has not finished yet')\n    }\n    return this._exitCode\n  }\n\n  /**\n   * The stdout from the process.\n   */\n  get stdout(): string {\n    return this.messages\n      .filter((out) => !out.error)\n      .map((out) => out.line)\n      .join(this.delimiter)\n  }\n\n  /**\n   * The stderr from the process.\n   */\n  get stderr(): string {\n    return this.messages\n      .filter((out) => out.error)\n      .map((out) => out.line)\n      .join(this.delimiter)\n  }\n\n  addStdout(message: ProcessMessage) {\n    this.insertByTimestamp(message)\n  }\n\n  addStderr(message: ProcessMessage) {\n    this._error = true\n    this.insertByTimestamp(message)\n  }\n\n  setExitCode(exitCode: number) {\n    this._exitCode = exitCode\n    this._finished = true\n  }\n\n  private insertByTimestamp(message: ProcessMessage) {\n    let i = this.messages.length - 1\n    while (i >= 0 && this.messages[i].timestamp > message.timestamp) {\n      i -= 1\n    }\n    this.messages.splice(i + 1, 0, message)\n  }\n}\n\n/**\n * A process running in the sandbox.\n */\nexport class Process {\n  /**\n   * @deprecated use .wait() instead\n   */\n  readonly finished: Promise<ProcessOutput>\n\n  constructor(\n    readonly processID: string,\n    private readonly sandbox: SandboxConnection,\n    private readonly triggerExit: () => void,\n    finished: Promise<ProcessOutput>,\n    readonly output: ProcessOutput,\n  ) {\n    this.finished = finished\n  }\n\n  /**\n   * Kills the process.\n   */\n  async kill(): Promise<void> {\n    try {\n      await this.sandbox._call(processService, 'kill', [this.processID])\n    } finally {\n      this.triggerExit()\n      await this.finished\n    }\n  }\n\n  /**\n   * Waits for the process to finish.\n   *\n   * @param timeout Timeout for the process to finish in milliseconds\n   */\n  async wait(timeout?: number): Promise<ProcessOutput> {\n    return await withTimeout(() => this.finished, timeout)()\n  }\n\n  /**\n   * Sends data to the process stdin.\n   *\n   * @param data Data to send\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)\n   */\n  async sendStdin(data: string, opts?: CallOpts): Promise<void> {\n    await this.sandbox._call(\n      processService,\n      'stdin',\n      [this.processID, data],\n      opts,\n    )\n  }\n}\n\nexport interface ProcessOpts {\n  cmd: string;\n  onStdout?: (out: ProcessMessage) => Promise<void> | void;\n  onStderr?: (out: ProcessMessage) => Promise<void> | void;\n  onExit?: (() => Promise<void> | void) | ((exitCode: number) => Promise<void> | void);\n  envVars?: EnvVars;\n  cwd?: string;\n  /** @deprecated Use cwd instead */\n  rootDir?: string;\n  processID?: string;\n  /** Timeout for the process to start in milliseconds */\n  timeout?: number;\n}\n\n/**\n * Manager for starting and interacting with processes in the sandbox.\n */\nexport interface ProcessManager {\n  /**\n   * Starts a new process.\n   * @param cmd Command to execute\n   * @returns New process\n   */\n  start(cmd: string): Promise<Process>;\n  /**\n   * Starts a new process.\n   * @param opts Process options\n   * @returns New process\n   */\n  start(opts: ProcessOpts): Promise<Process>;\n  /**\n   * Starts a new process and wait until it finishes.\n   * @param cmd Command to execute\n   * @returns New process\n   */\n  startAndWait(cmd: string): Promise<ProcessOutput>;\n  /**\n   * Starts a new process and wait until it finishes.\n   * @param opts Process options\n   * @returns New process\n   */\n  startAndWait(opts: ProcessOpts): Promise<ProcessOutput>;\n}\n","import normalizePath from 'normalize-path'\n\nimport { ENVD_PORT, FILE_ROUTE } from '../constants'\nimport { id } from '../utils/id'\nimport { createDeferredPromise, formatSettledErrors, withTimeout } from '../utils/promise'\nimport { codeSnippetService, ScanOpenedPortsHandler as ScanOpenPortsHandler } from './codeSnippet'\nimport { FileInfo, FilesystemManager, filesystemService } from './filesystem'\nimport FilesystemWatcher from './filesystemWatcher'\nimport { Process, ProcessManager, ProcessMessage, ProcessOpts, ProcessOutput, processService } from './process'\nimport { CallOpts, SandboxConnection, SandboxConnectionOpts } from './sandboxConnection'\nimport { Terminal, TerminalManager, TerminalOpts, TerminalOutput, terminalService } from './terminal'\nimport { resolvePath } from '../utils/filesystem'\nimport { CurrentWorkingDirectoryDoesntExistError } from '../error'\n\nexport type DownloadFileFormat =\n  | 'base64'\n  | 'blob'\n  | 'buffer'\n  | 'arraybuffer'\n  | 'text'\n\nexport interface SandboxOpts extends SandboxConnectionOpts {\n  onScanPorts?: ScanOpenPortsHandler;\n  /** Timeout for sandbox to start */\n  timeout?: number;\n  onStdout?: (out: ProcessMessage) => Promise<void> | void;\n  onStderr?: (out: ProcessMessage) => Promise<void> | void;\n  onExit?: (() => Promise<void> | void) | ((exitCode: number) => Promise<void> | void);\n}\n\n\n/**\n * E2B cloud sandbox gives your agent a full cloud development environment that's sandboxed.\n *\n * That means:\n * - Access to Linux OS\n * - Using filesystem (create, list, and delete files and dirs)\n * - Run processes\n * - Sandboxed - you can run any code\n * - Access to the internet\n *\n * Check usage docs - https://e2b.dev/docs/sandbox/overview\n *\n * These cloud sandboxes are meant to be used for agents. Like a sandboxed playgrounds, where the agent can do whatever it wants.\n *\n * Use the {@link Sandbox.create} method to create a new sandbox.\n *\n * @example\n * ```ts\n * import { Sandbox } from '@e2b/sdk'\n *\n * const sandbox = await Sandbox.create()\n *\n * await sandbox.close()\n * ```\n */\nexport class Sandbox extends SandboxConnection {\n  /**\n   * Terminal manager used to create interactive terminals.\n   */\n  readonly terminal: TerminalManager\n  /**\n   * Filesystem manager used to manage files.\n   */\n  readonly filesystem: FilesystemManager\n  /**\n   * Process manager used to run commands.\n   */\n  readonly process: ProcessManager\n\n  private readonly onScanPorts?: ScanOpenPortsHandler\n\n  /**\n   * Use `Sandbox.create()` instead.\n   *\n   * @hidden\n   * @hide\n   * @internal\n   * @access protected\n   */\n  constructor(opts?: SandboxOpts, protected createCalled: boolean = false) {\n    opts = opts || {}\n    super(opts, createCalled)\n    this.onScanPorts = opts.onScanPorts\n\n    // Init Filesystem handler\n    this.filesystem = {\n      list: async (path, opts?: CallOpts) => {\n        return (await this._call(\n          filesystemService,\n          'list',\n          [_resolvePath(path)],\n          opts,\n        )) as FileInfo[]\n      },\n      read: async (path, opts?: CallOpts) => {\n        return (await this._call(\n          filesystemService,\n          'read',\n          [_resolvePath(path)],\n          opts,\n        )) as string\n      },\n      remove: async (path, opts?: CallOpts) => {\n        await this._call(\n          filesystemService,\n          'remove',\n          [_resolvePath(path)],\n          opts,\n        )\n      },\n      write: async (path, content, opts?: CallOpts) => {\n        await this._call(\n          filesystemService,\n          'write',\n          [_resolvePath(path), content],\n          opts,\n        )\n      },\n      writeBytes: async (path: string, content: Uint8Array) => {\n        // We need to convert the byte array to base64 string without using browser or node specific APIs.\n        // This should be achieved by the node polyfills.\n        const base64Content = Buffer.from(content).toString('base64')\n        await this._call(filesystemService, 'writeBase64', [\n          _resolvePath(path),\n          base64Content,\n        ])\n      },\n      readBytes: async (path: string) => {\n        const base64Content = (await this._call(\n          filesystemService,\n          'readBase64',\n          [_resolvePath(path)],\n        )) as string\n        // We need to convert the byte array to base64 string without using browser or node specific APIs.\n        // This should be achieved by the node polyfills.\n        return Buffer.from(base64Content, 'base64')\n      },\n      makeDir: async (path, opts?: CallOpts) => {\n        await this._call(\n          filesystemService,\n          'makeDir',\n          [_resolvePath(path)],\n          opts,\n        )\n      },\n      watchDir: (path: string) => {\n        this.logger.debug?.(`Watching directory \"${path}\"`)\n        const npath = normalizePath(_resolvePath(path))\n        return new FilesystemWatcher(this, npath)\n      },\n    }\n\n    // Init Terminal handler\n    this.terminal = {\n      start: async ({\n        onData,\n        size,\n        onExit,\n        envVars,\n        cmd,\n        cwd = '',\n        terminalID = id(12),\n        timeout = undefined,\n      }: TerminalOpts) => {\n        const start = async ({\n          onData,\n          size,\n          onExit,\n          envVars,\n          cmd,\n          cwd = '',\n          rootDir,\n          terminalID = id(12),\n        }: Omit<TerminalOpts, 'timeout'>) => {\n          this.logger.debug?.(`Starting terminal \"${terminalID}\"`)\n          if (!cwd && rootDir) {\n            this.logger.warn?.(\n              'The rootDir parameter is deprecated, use cwd instead.',\n            )\n            cwd = rootDir\n          }\n          if (!cwd && this.cwd) {\n            cwd = this.cwd\n          }\n          envVars = envVars || {}\n          envVars = { ...this.envVars, ...envVars }\n\n          const { promise: terminalExited, resolve: triggerExit } =\n            createDeferredPromise()\n\n          const output = new TerminalOutput()\n\n          function handleData(data: string) {\n            output.addData(data)\n            onData?.(data)\n          }\n\n          const [onDataSubID, onExitSubID] = await this._handleSubscriptions(\n            this._subscribe(terminalService, handleData, 'onData', terminalID),\n            this._subscribe(terminalService, triggerExit, 'onExit', terminalID),\n          )\n\n          const { promise: unsubscribing, resolve: handleFinishUnsubscribing } =\n            createDeferredPromise<TerminalOutput>()\n\n          terminalExited.then(async () => {\n            Promise.allSettled([\n              this._unsubscribe(onExitSubID),\n              this._unsubscribe(onDataSubID),\n            ]).then((results) => {\n              const errMsg = formatSettledErrors(results)\n              if (errMsg) {\n                this.logger.debug?.(errMsg)\n              }\n            })\n\n            this.logger.debug?.(`Terminal \"${terminalID}\" exited`)\n\n            onExit?.()\n            handleFinishUnsubscribing(output)\n          })\n\n          try {\n            await this._call(terminalService, 'start', [\n              terminalID,\n              size.cols,\n              size.rows,\n              // Handle optional args for old devbookd compatibility\n              ...(cmd !== undefined ? [envVars, cmd, cwd] : []),\n            ])\n          } catch (err) {\n            triggerExit()\n            await unsubscribing\n            throw err\n          }\n\n          return new Terminal(\n            terminalID,\n            this,\n            triggerExit,\n            unsubscribing,\n            output,\n          )\n        }\n        return await withTimeout(\n          start,\n          timeout,\n        )({\n          onData,\n          size,\n          onExit,\n          envVars,\n          cmd,\n          cwd,\n          terminalID,\n        })\n      },\n    }\n\n    // Init Process handler\n    this.process = {\n      start: async (optsOrCmd: string | ProcessOpts) => {\n        const opts = typeof optsOrCmd === 'string' ? { cmd: optsOrCmd } : optsOrCmd\n        const start = async ({\n          cmd,\n          onStdout,\n          onStderr,\n          onExit,\n          envVars = {},\n          cwd = '',\n          rootDir,\n          processID = id(12),\n        }: Omit<ProcessOpts, 'timeout'>) => {\n          if (!cwd && rootDir) {\n            this.logger.warn?.(\n              'The rootDir parameter is deprecated, use cwd instead.',\n            )\n            cwd = rootDir\n          }\n          if (!cwd && this.cwd) {\n            cwd = this.cwd\n          }\n          if (!cmd) throw new Error('cmd is required')\n\n          envVars = envVars || {}\n          envVars = { ...this.envVars, ...envVars }\n\n          this.logger.debug?.(`Starting process \"${processID}\", cmd: \"${cmd}\"`)\n\n          const { promise: processExited, resolve: triggerExit } =\n            createDeferredPromise()\n\n          const output = new ProcessOutput()\n          const handleExit = (exitCode: number) => {\n            output.setExitCode(exitCode)\n            triggerExit()\n          }\n\n          const handleStdout = (data: { line: string; timestamp: number }) => {\n            const message = new ProcessMessage(\n              data.line,\n              data.timestamp,\n              false,\n            )\n            output.addStdout(message)\n\n            if (onStdout) {\n              onStdout(message)\n            } else if ((this.opts as SandboxOpts).onStdout) {\n              // @ts-expect-error TS2339\n              this.opts.onStdout(message)\n            }\n          }\n\n          const handleStderr = (data: { line: string; timestamp: number }) => {\n            const message = new ProcessMessage(data.line, data.timestamp, true)\n            output.addStderr(message)\n\n            if (onStderr) {\n              onStderr(message)\n            } else if ((this.opts as SandboxOpts).onStderr) {\n              // @ts-expect-error TS2339\n              this.opts.onStderr(message)\n            }\n          }\n\n          const [onExitSubID, onStdoutSubID, onStderrSubID] =\n            await this._handleSubscriptions(\n              this._subscribe(processService, handleExit, 'onExit', processID),\n              this._subscribe(\n                processService,\n                handleStdout,\n                'onStdout',\n                processID,\n              ),\n              this._subscribe(\n                processService,\n                handleStderr,\n                'onStderr',\n                processID,\n              ),\n            )\n\n          const { promise: unsubscribing, resolve: handleFinishUnsubscribing } =\n            createDeferredPromise<ProcessOutput>()\n\n          processExited.then(async () => {\n            Promise.allSettled([\n              this._unsubscribe(onExitSubID),\n              onStdoutSubID ? this._unsubscribe(onStdoutSubID) : undefined,\n              onStderrSubID ? this._unsubscribe(onStderrSubID) : undefined,\n            ]).then((results) => {\n              const errMsg = formatSettledErrors(results)\n              if (errMsg) {\n                this.logger.debug?.(errMsg)\n              }\n            })\n\n            this.logger.debug?.(`Process \"${processID}\" exited`)\n\n            if (onExit) {\n              onExit(output.exitCode || 0)\n            } else if ((this.opts as SandboxOpts).onExit) {\n              // @ts-expect-error TS2339\n              this.opts.onExit()\n            }\n\n            handleFinishUnsubscribing(output)\n          })\n\n          try {\n            await this._call(processService, 'start', [\n              processID,\n              cmd,\n              envVars,\n              cwd,\n            ])\n          } catch (err) {\n            triggerExit()\n            await unsubscribing\n            if (\n              /error starting process '\\w+': fork\\/exec \\/bin\\/bash: no such file or directory/.test((err as Error)?.message)\n            ) {\n              throw new CurrentWorkingDirectoryDoesntExistError(\n                `Failed to start the process. You are trying set 'cwd' to a directory that does not exist.\\n${(err as Error)?.message}`\n              )\n            }\n            throw err\n          }\n\n          return new Process(\n            processID,\n            this,\n            triggerExit,\n            unsubscribing,\n            output,\n          )\n        }\n        const timeout = opts.timeout\n        return await withTimeout(start, timeout)(opts)\n      },\n      startAndWait: async (optsOrCmd: string | ProcessOpts) => {\n        const opts = typeof optsOrCmd === 'string' ? { cmd: optsOrCmd } : optsOrCmd\n        const process = await this.process.start(opts)\n        const out = await process.wait()\n        return out\n      }\n    }\n\n    const _resolvePath = (path: string): string =>\n      resolvePath(path, this.cwd, this.logger)\n  }\n\n  /**\n   * URL that can be used to download or upload file to the sandbox via a multipart/form-data POST request.\n   * This is useful if you're uploading files directly from the browser.\n   * The file will be uploaded to the user's home directory with the same name.\n   * If a file with the same name already exists, it will be overwritten.\n   */\n  get fileURL() {\n    const protocol = this.getProtocol('http', this.opts.__debug_devEnv !== 'local')\n    const hostname = this.getHostname(this.opts.__debug_port || ENVD_PORT)\n    return `${protocol}://${hostname}${FILE_ROUTE}`\n  }\n\n  /**\n   * Creates a new Sandbox from the default `base` sandbox template.\n   * @returns New Sandbox\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * ```\n   * @constructs Sandbox\n   */\n  static async create<S extends typeof Sandbox>(this: S): Promise<InstanceType<S>>\n  /**\n   * Creates a new Sandbox from the template with the specified ID.\n   * @param template Sandbox template ID or name\n   * @returns New Sandbox\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create(\"sandboxTemplateID\")\n   * ```\n   */\n  static async create<S extends typeof Sandbox>(this: S, template: string): Promise<InstanceType<S>>\n  /**\n   * Creates a new Sandbox from the specified options.\n   * @param opts Sandbox options\n   * @returns New Sandbox\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create({\n   *   template: \"sandboxTemplate\",\n   *   onStdout: console.log,\n   * })\n   * ```\n   */\n  static async create<S extends typeof Sandbox>(this: S, opts: SandboxOpts): Promise<InstanceType<S>>\n  static async create(optsOrTemplate?: string | SandboxOpts) {\n    const opts: SandboxOpts | undefined = typeof optsOrTemplate === 'string' ? { template: optsOrTemplate } : optsOrTemplate\n    const sandbox = new this(opts, true)\n    await sandbox._open({ timeout: opts?.timeout })\n\n    return sandbox\n  }\n\n  /**\n   * Reconnects to an existing Sandbox.\n   * @param sandboxID Sandbox ID\n   * @returns Existing Sandbox\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * const sandboxID = sandbox.id\n   *\n   * await sandbox.keepAlive(300 * 1000)\n   * await sandbox.close()\n   *\n   * const reconnectedSandbox = await Sandbox.reconnect(sandboxID)\n   * ```\n   */\n  static async reconnect<S extends typeof Sandbox>(this: S, sandboxID: string): Promise<InstanceType<S>>\n  /**\n   * Reconnects to an existing Sandbox.\n   * @param opts Sandbox options\n   * @returns Existing Sandbox\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * const sandboxID = sandbox.id\n   *\n   * await sandbox.keepAlive(300 * 1000)\n   * await sandbox.close()\n   *\n   * const reconnectedSandbox = await Sandbox.reconnect({\n   *   sandboxID,\n   * })\n   * ```\n   */\n  static async reconnect<S extends typeof Sandbox>(this: S, opts: Omit<SandboxOpts, 'id' | 'template'> & { sandboxID: string }): Promise<InstanceType<S>>\n  static async reconnect<S extends typeof Sandbox>(this: S, sandboxIDorOpts: string | Omit<SandboxOpts, 'id' | 'template'> & { sandboxID: string }): Promise<InstanceType<S>> {\n    let id: string\n    let opts: SandboxOpts\n    if (typeof sandboxIDorOpts === 'string') {\n      id = sandboxIDorOpts\n      opts = {}\n    } else {\n      id = sandboxIDorOpts.sandboxID\n      opts = sandboxIDorOpts\n    }\n\n    const sandboxIDAndClientID = id.split('-')\n    const sandboxID = sandboxIDAndClientID[0]\n    const clientID = sandboxIDAndClientID[1]\n    opts.__sandbox = { sandboxID, clientID, templateID: 'unknown' }\n\n    const sandbox = new this(opts, true) as InstanceType<S>\n    await sandbox._open({ timeout: opts?.timeout })\n\n    return sandbox\n  }\n\n  /**\n   * Uploads a file to the sandbox.\n   * The file will be uploaded to the user's home directory with the same name.\n   * If a file with the same name already exists, it will be overwritten.\n   *\n   * **You can use the {@link Sandbox.fileURL} property and upload file directly via POST multipart/form-data**\n   *\n   */\n  async uploadFile(file: Buffer | Blob, filename: string) {\n    const body = new FormData()\n\n    const blob =\n      file instanceof Blob\n        ? file\n        : new Blob([file], { type: 'application/octet-stream' })\n\n    body.append('file', blob, filename)\n\n    // TODO: Ensure the this is bound in this function\n    const response = await fetch(this.fileURL, {\n      method: 'POST',\n      body,\n    })\n\n    if (!response.ok) {\n      const text = await response.text()\n      throw new Error(\n        `Failed to upload file ${response.status} - ${response.statusText}: ${text}`,\n      )\n    }\n\n    return `/home/user/${filename}`\n  }\n\n  /**\n   * Downloads a file from the sandbox.\n   * @param remotePath Path to a file on the sandbox\n   * @param format Format of the downloaded file\n   * @returns File content\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * const content = await sandbox.downloadFile('/home/user/file.txt')\n   * ```\n   */\n  async downloadFile(remotePath: string, format?: DownloadFileFormat) {\n    remotePath = encodeURIComponent(remotePath)\n\n    // TODO: Ensure the this is bound in this function\n    const response = await fetch(`${this.fileURL}?path=${remotePath}`)\n    if (!response.ok) {\n      const text = await response.text()\n      throw new Error(`Failed to download file '${remotePath}': ${text}`)\n    }\n\n    switch (format) {\n      case 'base64':\n        return Buffer.from(await response.arrayBuffer()).toString('base64')\n      case 'blob':\n        return await response.blob()\n      case 'buffer':\n        return Buffer.from(await response.arrayBuffer())\n      case 'arraybuffer':\n        return await response.arrayBuffer()\n      case 'text':\n        return await response.text()\n      default:\n        return await response.arrayBuffer()\n    }\n  }\n\n  protected override async _open(opts: CallOpts) {\n    await super._open(opts)\n\n    const portsHandler = this.onScanPorts\n      ? (ports: { State: string; Ip: string; Port: number }[]) =>\n        this.onScanPorts?.(\n          ports.map((p) => ({ ip: p.Ip, port: p.Port, state: p.State })),\n        )\n      : undefined\n\n    await this._handleSubscriptions(\n      portsHandler\n        ? this._subscribe(codeSnippetService, portsHandler, 'scanOpenedPorts')\n        : undefined,\n    )\n\n    if (this.cwd) {\n      this.logger.debug?.(`Custom cwd for Sandbox set: \"${this.cwd}\"`)\n      await this.filesystem.makeDir(this.cwd)\n    }\n\n    if ((this.opts as SandboxOpts).onStdout || (this.opts as SandboxOpts).onStderr) {\n      this.handleStartCmdLogs()\n    }\n\n    return this\n  }\n\n  private async handleStartCmdLogs() {\n    try {\n      await this.process.startAndWait({\n        cmd: 'sudo journalctl --follow --lines=all -o cat _SYSTEMD_UNIT=start_cmd.service',\n        envVars: {},\n        cwd: '/',\n      })\n    } catch (err) {\n      this.logger.debug?.('start command not started', err)\n    }\n  }\n}\n","export function id(length: number) {\n  let result = ''\n  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  const charactersLength = characters.length\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength))\n  }\n  return result\n}\n","export const codeSnippetService = 'codeSnippet'\n\nexport interface OpenPort {\n  state: string\n  ip: string\n  port: number\n}\n\nexport type ScanOpenedPortsHandler = (ports: OpenPort[]) => Promise<void> | void\n","// Based on https://github.com/radarsu/rpc-websocket-client\n\nimport IWebSocket from 'isomorphic-ws'\n\nimport { id } from '../utils/id'\n\nexport type RpcEventFunction = (\n  // @ts-ignore\n  e: IWebSocket.OpenEvent | IWebSocket.ErrorEvent\n) => void\nexport type RpcMessageEventFunction = (e: IWebSocket.MessageEvent) => void\nexport type RpcCloseEventFunction = (e: IWebSocket.CloseEvent) => void\n\nexport type RpcNotificationEvent = (data: IRpcNotification) => void\nexport type RpcRequestEvent = (data: IRpcRequest) => void\nexport type RpcSuccessResponseEvent = (data: IRpcSuccessResponse) => void\nexport type RpcErrorResponseEvent = (data: IRpcErrorResponse) => void\n\nexport enum RpcVersions {\n  RPC_VERSION = '2.0'\n}\n\nexport type RpcId = string | number\n\nexport interface IRpcData {\n  method: string;\n  params?: any;\n}\n\nexport interface IRpcNotification extends IRpcData {\n  jsonrpc: RpcVersions.RPC_VERSION;\n}\n\nexport interface IRpcRequest extends IRpcNotification {\n  // if not included its notification\n  id: RpcId;\n}\n\nexport interface IRpcResponse {\n  id: RpcId;\n  jsonrpc: RpcVersions.RPC_VERSION;\n}\n\nexport interface IRpcSuccessResponse extends IRpcResponse {\n  // if not included its notification\n  result: any;\n}\n\nexport interface IRpcError {\n  code: number;\n  message: string;\n  data?: any;\n}\n\nexport interface IRpcErrorResponse extends IRpcResponse {\n  error: IRpcError;\n}\n\nexport interface IRpcWebSocketConfig {\n  responseTimeout: number;\n}\n\nexport type RpcUnidentifiedMessage =\n  | IRpcRequest\n  | IRpcNotification\n  | IRpcSuccessResponse\n  | IRpcErrorResponse\n\nexport class RpcWebSocketClient {\n  // native websocket\n\n  public ws: IWebSocket\n\n  public onOpenHandlers: RpcEventFunction[] = []\n  public onAnyMessageHandlers: RpcMessageEventFunction[] = []\n\n  public onNotification: RpcNotificationEvent[] = []\n  public onRequest: RpcRequestEvent[] = []\n  public onSuccessResponse: RpcSuccessResponseEvent[] = []\n  public onErrorResponse: RpcErrorResponseEvent[] = []\n\n  public onErrorHandlers: RpcEventFunction[] = []\n  public onCloseHandlers: RpcCloseEventFunction[] = []\n\n  public config: IRpcWebSocketConfig = {\n    responseTimeout: 10000\n  }\n\n  private idAwaiter: {\n    [id: string]: (data?: any) => void;\n  } = {}\n\n  // constructor\n  /**\n   * Does not start WebSocket connection!\n   * You need to call connect() method first.\n   * @memberof RpcWebSocketClient\n   */\n  public constructor() {\n    this.ws = undefined as any\n  }\n\n  // public\n  /**\n   * Starts WebSocket connection. Returns Promise when connection is established.\n   * @param {string} url\n   * @param {(string | string[])} [protocols]\n   * @memberof RpcWebSocketClient\n   */\n  public connect(url: string, protocols?: string | string[]) {\n    this.ws = new IWebSocket(url, protocols)\n    return this.listen()\n  }\n\n  // events\n  public onOpen(fn: RpcEventFunction) {\n    this.onOpenHandlers.push(fn)\n  }\n\n  /**\n   * Native onMessage event. DO NOT USE THIS unless you really have to or for debugging purposes.\n   * Proper RPC events are onRequest, onNotification, onSuccessResponse and onErrorResponse (or just awaiting response).\n   * @param {RpcMessageEventFunction} fn\n   * @memberof RpcWebSocketClient\n   */\n  public onAnyMessage(fn: RpcMessageEventFunction) {\n    this.onAnyMessageHandlers.push(fn)\n  }\n\n  public onError(fn: RpcEventFunction) {\n    this.onErrorHandlers.push(fn)\n  }\n\n  public onClose(fn: RpcCloseEventFunction) {\n    this.onCloseHandlers.push(fn)\n  }\n\n  /**\n   * Appends onmessage listener on native websocket with RPC handlers.\n   * If onmessage function was already there, it will call it on beggining.\n   * Useful if you want to use RPC WebSocket Client on already established WebSocket along with function changeSocket().\n   * @memberof RpcWebSocketClient\n   */\n  public listenMessages() {\n    let previousOnMessage: RpcMessageEventFunction | undefined\n    if (this.ws.onmessage) {\n      previousOnMessage = this.ws.onmessage.bind(this.ws)\n    }\n\n    this.ws.onmessage = (e: IWebSocket.MessageEvent) => {\n      if (previousOnMessage) {\n        previousOnMessage(e)\n      }\n\n      for (const handler of this.onAnyMessageHandlers) {\n        handler(e)\n      }\n\n      const data: RpcUnidentifiedMessage = JSON.parse(e.data.toString())\n      if (this.isNotification(data)) {\n        // notification\n        for (const handler of this.onNotification) {\n          handler(data)\n        }\n      } else if (this.isRequest(data)) {\n        // request\n        for (const handler of this.onRequest) {\n          handler(data)\n        }\n        // responses\n      } else if (this.isSuccessResponse(data)) {\n        // success\n        for (const handler of this.onSuccessResponse) {\n          handler(data)\n        }\n\n        // resolve awaiting function\n        this.idAwaiter[data.id](data.result)\n      } else if (this.isErrorResponse(data)) {\n        // error\n        for (const handler of this.onErrorResponse) {\n          handler(data)\n        }\n\n        // resolve awaiting function\n        this.idAwaiter[data.id](data.error)\n      }\n    }\n  }\n\n  // communication\n\n  /**\n   * Creates and sends RPC request. Resolves when appropirate response is returned from server or after config.responseTimeout.\n   * @param {string} method\n   * @param {*} [params]\n   * @returns\n   * @memberof RpcWebSocketClient\n   */\n  public call(method: string, params?: any) {\n    return new Promise((resolve, reject) => {\n      const data = this.buildRequest(method, params)\n\n      // give limited time for response\n      let timeout: number | NodeJS.Timeout\n      if (this.config.responseTimeout) {\n        timeout = setTimeout(() => {\n          // stop waiting for response\n          delete this.idAwaiter[data.id]\n          reject(\n            new Error(`Awaiting response to \"${method}\" with id: ${data.id} timed out.`)\n          )\n        }, this.config.responseTimeout)\n      }\n\n      // expect response\n      this.idAwaiter[data.id] = (responseData?: any) => {\n        // stop timeout\n        clearInterval(timeout as number)\n        // stop waiting for response\n        delete this.idAwaiter[data.id]\n\n        if (this.isRpcError(responseData)) {\n          reject(new Error(`RPC Error (${responseData.code}): ${responseData.message}`))\n          return\n        }\n\n        resolve(responseData)\n      }\n\n      const json = JSON.stringify(data)\n      this.ws.send(json)\n    })\n  }\n\n  /**\n   * Creates and sends RPC Notification.\n   * @param {string} method\n   * @param {*} [params]\n   * @memberof RpcWebSocketClient\n   */\n  public notify(method: string, params?: any) {\n    this.ws.send(JSON.stringify(this.buildNotification(method, params)))\n  }\n\n  // setup\n\n  /**\n   * You can provide custom id generation function to replace default uuid/v1.\n   * @param {() => string} idFn\n   * @memberof RpcWebSocketClient\n   */\n  public customId(idFn: () => string) {\n    this.idFn = idFn\n  }\n\n  /**\n   * Removed jsonrpc from sent messages. Good if you don't care about standards or need better performance.\n   * @memberof RpcWebSocketClient\n   */\n  public noRpc() {\n    this.buildRequest = this.buildRequestBase\n    this.buildNotification = this.buildNotificationBase\n    this.buildRpcSuccessResponse = this.buildRpcSuccessResponseBase\n    this.buildRpcErrorResponse = this.buildRpcErrorResponseBase\n  }\n\n  /**\n   * Allows modifying configuration.\n   * @param {IRpcWebSocketConfig} options\n   * @memberof RpcWebSocketClient\n   */\n  public configure(options: IRpcWebSocketConfig) {\n    Object.assign(this.config, options)\n  }\n\n  /**\n   * Allows you to change used native WebSocket client to another one.\n   * If you have already-connected WebSocket, use this with listenMessages().\n   * @param {WebSocket} ws\n   * @memberof RpcWebSocketClient\n   */\n  public changeSocket(ws: IWebSocket) {\n    this.ws = ws\n  }\n\n  // private\n\n  // events\n  private listen() {\n    return new Promise((resolve, reject) => {\n      // @ts-ignore\n      this.ws.onopen = (e: IWebSocket.OpenEvent) => {\n        for (const handler of this.onOpenHandlers) {\n          handler(e)\n        }\n        resolve(e)\n      }\n\n      // listen for messages\n      this.listenMessages()\n\n      // called before onclose\n      this.ws.onerror = (e: IWebSocket.ErrorEvent) => {\n        for (const handler of this.onErrorHandlers) {\n          handler(e)\n        }\n      }\n\n      this.ws.onclose = (e: IWebSocket.CloseEvent) => {\n        for (const handler of this.onCloseHandlers) {\n          handler(e)\n        }\n        reject(new Error(`WebSocket closed with code: ${e.code} and reason: ${e.reason}`))\n      }\n    })\n  }\n\n  // request\n  private buildRequest(method: string, params?: any): IRpcRequest {\n    const data = this.buildRequestBase(method, params)\n    data.jsonrpc = RpcVersions.RPC_VERSION\n    return data\n  }\n\n  private buildRequestBase(method: string, params?: any): IRpcRequest {\n    const data: IRpcRequest = {} as any\n    data.id = this.idFn()\n    data.method = method\n\n    if (params) {\n      data.params = params\n    }\n\n    return data\n  }\n\n  // notification\n  private buildNotification(method: string, params?: any): IRpcNotification {\n    const data = this.buildNotificationBase(method, params)\n    data.jsonrpc = RpcVersions.RPC_VERSION\n    return data\n  }\n\n  private buildNotificationBase(\n    method: string,\n    params?: any\n  ): IRpcNotification {\n    const data: IRpcNotification = {} as any\n    data.method = method\n\n    if (params) {\n      data.params = params\n    }\n\n    return data\n  }\n\n  // success response\n  private buildRpcSuccessResponse(\n    id: RpcId,\n    result: any\n  ): IRpcSuccessResponse {\n    const data = this.buildRpcSuccessResponseBase(id, result)\n    data.jsonrpc = RpcVersions.RPC_VERSION\n    return data\n  }\n\n  private buildRpcSuccessResponseBase(\n    id: RpcId,\n    result: any\n  ): IRpcSuccessResponse {\n    const data: IRpcSuccessResponse = {} as any\n    data.id = id\n    data.result = result\n    return data\n  }\n\n  // error response\n  private buildRpcErrorResponse(\n    id: RpcId,\n    error: IRpcError\n  ): IRpcErrorResponse {\n    const data = this.buildRpcErrorResponseBase(id, error)\n    data.jsonrpc = RpcVersions.RPC_VERSION\n    return data\n  }\n\n  private buildRpcErrorResponseBase(\n    id: RpcId,\n    error: IRpcError\n  ): IRpcErrorResponse {\n    const data: IRpcErrorResponse = {} as any\n    data.id = id\n    data.error = error\n    return data\n  }\n\n  private idFn(): RpcId {\n    return id(12)\n  }\n\n  // tests\n  private isNotification(\n    data: RpcUnidentifiedMessage\n  ): data is IRpcNotification {\n    return !(data as any).id\n  }\n\n  private isRequest(data: RpcUnidentifiedMessage): data is IRpcRequest {\n    return (data as any).method\n  }\n\n  private isSuccessResponse(\n    data: RpcUnidentifiedMessage\n  ): data is IRpcSuccessResponse {\n    // eslint-disable-next-line no-prototype-builtins\n    return data.hasOwnProperty('result')\n  }\n\n  private isErrorResponse(\n    data: RpcUnidentifiedMessage\n  ): data is IRpcErrorResponse {\n    // eslint-disable-next-line no-prototype-builtins\n    return data.hasOwnProperty('error')\n  }\n\n  private isRpcError(data: any): data is IRpcError {\n    return typeof data?.code !== 'undefined'\n  }\n}\n","function wait(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport default wait\n","import { AuthenticationError } from '../error'\n\nexport function getApiKey(apiKey?: string): string {\n  apiKey = apiKey || process?.env?.E2B_API_KEY\n\n  if (!apiKey) {\n    throw new AuthenticationError(\n      'API key is required, please visit https://e2b.dev/docs to get your API key. ' +\n      'You can either set the environment variable `E2B_API_KEY` ' +\n      \"or you can pass it directly to the sandbox like Sandbox.create({apiKey: 'e2b_...'})\",\n    )\n  }\n\n  return apiKey\n}","import { IRpcNotification, RpcWebSocketClient } from './rpc'\n\nimport { APIClient, components, withAPIKey } from '../api'\nimport {\n  ENVD_PORT,\n  SANDBOX_REFRESH_PERIOD,\n  WS_RECONNECT_INTERVAL,\n  WS_ROUTE,\n} from '../constants'\nimport {\n  assertFulfilled,\n  formatSettledErrors,\n  withTimeout,\n} from '../utils/promise'\nimport wait from '../utils/wait'\nimport { codeSnippetService } from './codeSnippet'\nimport { filesystemService } from './filesystem'\nimport { processService } from './process'\nimport { terminalService } from './terminal'\nimport { EnvVars } from './envVars'\nimport { getApiKey } from '../utils/apiKey'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype SubscriptionHandler = (result: any) => void\n\ntype Service =\n  | typeof processService\n  | typeof codeSnippetService\n  | typeof filesystemService\n  | typeof terminalService\n\ninterface Subscriber {\n  service: Service\n  subID: string\n  handler: SubscriptionHandler\n}\n\nexport interface Logger {\n  debug?: (message: string, ...args: unknown[]) => void\n  info?: (message: string, ...args: unknown[]) => void\n  warn?: (message: string, ...args: unknown[]) => void\n  error?: (message: string, ...args: unknown[]) => void\n}\n\nexport interface SandboxMetadata {\n  [key: string]: string\n}\n\nexport interface RunningSandbox {\n  sandboxID: string\n  templateID: string\n  alias?: string\n  metadata?: SandboxMetadata\n  startedAt: Date\n}\n\nexport interface SandboxConnectionOpts {\n  /**\n   * Sandbox Template ID or name.\n   *\n   * If not specified, the 'base' template will be used.\n   */\n  template?: string\n  /**\n   * @deprecated Use `template` instead.\n   *\n   * Sandbox Template ID or name.\n   */\n  id?: string\n  apiKey?: string\n  /**\n   * Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.\n   */\n  domain?: string\n  cwd?: string\n  envVars?: EnvVars\n  /**\n   * A dictionary of strings that is stored alongside the running sandbox.\n   * You can see this metadata when you list running sandboxes.\n   */\n  metadata?: SandboxMetadata\n  logger?: Logger\n  __sandbox?: components['schemas']['Sandbox']\n  __debug_hostname?: string\n  __debug_port?: number\n  __debug_devEnv?: 'remote' | 'local'\n}\n\nexport interface CallOpts {\n  /** Timeout for the call in milliseconds */\n  timeout?: number\n}\n\nexport class SandboxConnection {\n  /**\n   * Default working directory used in the sandbox.\n   *\n   * You can change the working directory by setting the `cwd` property.\n   **/\n  cwd: string | undefined\n  /**\n   * Default environment variables used in the sandbox.\n   *\n   * You can change the environment variables by setting the `envVars` property.\n   **/\n  envVars: EnvVars\n\n  protected readonly logger: Logger\n  protected sandbox?: components['schemas']['Sandbox']\n  protected isOpen = false\n\n  private readonly apiKey: string\n  private readonly rpc = new RpcWebSocketClient()\n  private subscribers: Subscriber[] = []\n  private readonly client: APIClient\n\n  // let's keep opts readonly, but public - for convenience, mainly when debugging\n  protected constructor(\n    readonly opts: SandboxConnectionOpts,\n    protected createCalled: boolean,\n  ) {\n    if (!createCalled) {\n      throw new Error(\n        \"Sandbox can't be instantiated directly, use a `.create()` method instead of calling `new` to get a new sandbox.\\n\\n\" +\n          'Example of correct usage:\\n' +\n          '```\\n' +\n          \"import { CodeInterpreter } from '@e2b/code-interpreter'\\n\" +\n          'const myCodeInterpreter = await CodeInterpreter.create()\\n' +\n          '``',\n      )\n    }\n\n    this.sandbox = opts.__sandbox\n    this.apiKey = getApiKey(opts.apiKey)\n\n    this.client = new APIClient({ domain: opts.domain })\n\n    this.cwd = opts.cwd\n    if (this.cwd && this.cwd.startsWith('~')) {\n      this.cwd = this.cwd.replace('~', '/home/user')\n    }\n\n    const defaultEnvVars = { PYTHONUNBUFFERED: '1' }\n\n    this.envVars = { ...defaultEnvVars, ...(opts.envVars || {}) }\n\n    this.logger = opts.logger ?? {\n      // by default, we log to the console\n      // we don't log debug messages by default\n      info: console.info,\n      warn: console.warn,\n      error: console.error,\n    }\n    this.logger.debug?.(`Sandbox \"${this.templateID}\" initialized`)\n  }\n\n  /**\n   * ID of the sandbox.\n   *\n   * You can use this ID to reconnect to the sandbox later.\n   */\n  get id() {\n    return `${this.sandbox?.sandboxID}-${this.sandbox?.clientID}`\n  }\n\n  private get templateID(): string {\n    return this.opts.template || this.opts.id || 'base'\n  }\n\n  private get refreshSandbox() {\n    return withAPIKey(\n      this.client.api\n        .path('/sandboxes/{sandboxID}/refreshes')\n        .method('post')\n        .create(),\n    )\n  }\n\n  private get createSandbox() {\n    return withAPIKey(\n      this.client.api.path('/sandboxes').method('post').create(),\n    )\n  }\n\n  /**\n   * List all running sandboxes\n   *\n   * @param apiKey API key to use for authentication. If not provided, the `E2B_API_KEY` environment variable will be used.\n   * @param domain Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.\n   */\n  static async list(\n    apiKey?: string,\n    domain?: string,\n  ): Promise<RunningSandbox[]> {\n    apiKey = getApiKey(apiKey)\n\n    const client = new APIClient({ domain })\n\n    const listSandboxes = withAPIKey(\n      client.api.path('/sandboxes').method('get').create(),\n    )\n\n    try {\n      const res = await listSandboxes(apiKey, {})\n\n      return res.data.map((sandbox) => ({\n        sandboxID: `${sandbox.sandboxID}-${sandbox.clientID}`,\n        templateID: sandbox.templateID,\n        cpuCount: sandbox.cpuCount,\n        memoryMB: sandbox.memoryMB,\n        ...(sandbox.alias && { alias: sandbox.alias }),\n        ...(sandbox.metadata && { metadata: sandbox.metadata }),\n        startedAt: new Date(sandbox.startedAt),\n      }))\n    } catch (e) {\n      if (e instanceof listSandboxes.Error) {\n        const error = e.getActualType()\n        if (error.status === 401) {\n          throw new Error(\n            `Error listing sandboxes - (${error.status}) unauthenticated: ${error.data.message}`,\n          )\n        }\n        if (error.status === 500) {\n          throw new Error(\n            `Error listing sandboxes - (${error.status}) server error: ${error.data.message}`,\n          )\n        }\n      }\n      throw e\n    }\n  }\n\n  /**\n   * List all running sandboxes\n   * @param sandboxID ID of the sandbox to kill\n   * @param apiKey API key to use for authentication. If not provided, the `E2B_API_KEY` environment variable will be used.\n   * @param domain Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.\n   */\n  static async kill(\n    sandboxID: string,\n    apiKey?: string,\n    domain?: string,\n  ): Promise<void> {\n    apiKey = getApiKey(apiKey)\n\n    const shortID = sandboxID.split('-')[0]\n\n    const client = new APIClient({ domain })\n    const killSandbox = withAPIKey(\n      client.api.path('/sandboxes/{sandboxID}').method('delete').create(),\n    )\n\n    try {\n      await killSandbox(apiKey, { sandboxID: shortID })\n    } catch (e) {\n      if (e instanceof killSandbox.Error) {\n        const error = e.getActualType()\n        if (error.status === 401) {\n          throw new Error(\n            `Error killing sandbox (${sandboxID}) - (${error.status}) unauthenticated: ${error.data.message}`,\n          )\n        }\n        if (error.status === 500) {\n          throw new Error(\n            `Error killing sandbox (${sandboxID}) - (${error.status}) server error: ${error.data.message}`,\n          )\n        }\n      }\n      throw e\n    }\n  }\n\n  /**\n   * Keep the sandbox alive for the specified duration.\n   *\n   * `keepAlive` method requires `this` context - you may need to bind it.\n   * @param duration Duration in milliseconds. Must be between 0 and 3600000 milliseconds\n   * @returns Promise that resolves when the sandbox is kept alive\n   */\n  public async keepAlive(duration: number) {\n    duration = Math.round(duration / 1000)\n\n    if (duration < 0 || duration > 3600) {\n      throw new Error('Duration must be between 0 and 3600 seconds')\n    }\n\n    if (!this.sandbox) {\n      throw new Error('Cannot keep alive - sandbox is not initialized')\n    }\n    await this.refreshSandbox(this.apiKey, {\n      sandboxID: this.sandbox?.sandboxID,\n      duration,\n    })\n  }\n\n  /**\n   * Get the hostname for the sandbox or for the specified sandbox's port.\n   *\n   * `getHostname` method requires `this` context - you may need to bind it.\n   *\n   * @param port Specify if you want to connect to a specific port of the sandbox\n   * @returns Hostname of the sandbox or sandbox's port\n   */\n  getHostname(port?: number) {\n    if (this.opts.__debug_hostname) {\n      // Debugging remotely (with GitPod) and on local needs different formats of the hostname.\n      if (port && this.opts.__debug_devEnv === 'remote') {\n        return `${port}-${this.opts.__debug_hostname}`\n      } else if (port) {\n        return `${this.opts.__debug_hostname}:${port}`\n      } else {\n        return this.opts.__debug_hostname\n      }\n    }\n\n    if (!this.sandbox) {\n      throw new Error(\n        \"Cannot get sandbox's hostname - sandbox is not initialized\",\n      )\n    }\n\n    const hostname = `${this.id}.${this.client.domain}`\n    if (port) {\n      return `${port}-${hostname}`\n    } else {\n      return hostname\n    }\n  }\n\n  /**\n   * The function decides whether to use the secure or insecure protocol.\n   * @param baseProtocol Specify the specific protocol you want to use. Do not include the `s` in `https` or `wss`.\n   * @param secure Specify if you want to use the secure protocol\n   * @returns Protocol for the connection to the sandbox\n   */\n  getProtocol(\n    baseProtocol: string = 'http',\n    secure: boolean = this.client.secure,\n  ) {\n    return secure ? `${baseProtocol}s` : baseProtocol\n  }\n\n  /**\n   * Close the connection to the sandbox\n   *\n   * `close` method requires `this` context - you may need to bind it.\n   */\n  async close() {\n    if (this.isOpen) {\n      this.logger.debug?.(`Closing sandbox \"${this.id}\"`)\n      this.isOpen = false\n\n      // This is `ws` way of closing connection\n      this.rpc.ws?.terminate?.()\n      // This is the browser WebSocket way of closing connection\n      this.rpc.ws?.close?.()\n      this.subscribers = []\n\n      this.logger.debug?.('Disconnected from the sandbox')\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async _call(\n    service: Service,\n    method: string,\n    params?: any[],\n    opts?: CallOpts,\n  ) {\n    this.logger.debug?.(`Calling \"${service}_${method}\" with params:`, params)\n\n    // Without the async function, the `this` context is lost.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const call = async (method: string, params?: any[]) =>\n      await this.rpc.call(method, params)\n\n    return await withTimeout(call, opts?.timeout)(\n      `${service}_${method}`,\n      params,\n    )\n  }\n\n  async _handleSubscriptions<\n    T extends (ReturnType<SandboxConnection['_subscribe']> | undefined)[],\n  >(\n    ...subs: T\n  ): Promise<{\n    [P in keyof T]: Awaited<T[P]>\n  }> {\n    const results = await Promise.allSettled(subs)\n\n    if (results.every((r) => r.status === 'fulfilled')) {\n      return results.map((r) =>\n        r.status === 'fulfilled' ? r.value : undefined,\n      ) as {\n        [P in keyof T]: Awaited<T[P]>\n      }\n    }\n\n    await Promise.all(\n      results\n        .filter(assertFulfilled)\n        .map((r) => (r.value ? this._unsubscribe(r.value) : undefined)),\n    )\n\n    throw new Error(formatSettledErrors(results))\n  }\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  async _unsubscribe(subID: string) {\n    const subscription = this.subscribers.find((s) => s.subID === subID)\n    if (!subscription) return\n\n    await this._call(subscription.service, 'unsubscribe', [subscription.subID])\n\n    this.subscribers = this.subscribers.filter((s) => s !== subscription)\n    this.logger.debug?.(\n      `Unsubscribed '${subID}' from '${subscription.service}'`,\n    )\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/member-ordering\n  async _subscribe(\n    service: Service,\n    handler: SubscriptionHandler,\n    method: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ...params: any[]\n  ) {\n    const subID = await this._call(service, 'subscribe', [method, ...params])\n\n    if (typeof subID !== 'string') {\n      throw new Error(\n        `Cannot subscribe to ${service}_${method}${\n          params.length > 0 ? ' with params [' + params.join(', ') + ']' : ''\n        }. Expected response should have been a subscription ID, instead we got ${JSON.stringify(\n          subID,\n        )}`,\n      )\n    }\n\n    this.subscribers.push({\n      handler,\n      service,\n      subID,\n    })\n    this.logger.debug?.(\n      `Subscribed to \"${service}_${method}\"${\n        params.length > 0 ? ' with params [' + params.join(', ') + '] and' : ''\n      } with id \"${subID}\"`,\n    )\n\n    return subID\n  }\n\n  /**\n   * Open a connection to a new sandbox\n   *\n   * `open` method requires `this` context - you may need to bind it.\n   * @param opts Call options\n   * @param {timeout} [opts.timeout] Timeout for sandbox to open in milliseconds (default is 60 seconds)\n   */\n  protected async _open(opts: CallOpts) {\n    const open = async () => {\n      if (this.isOpen) {\n        throw new Error('Sandbox connect was already called')\n      } else {\n        this.isOpen = true\n      }\n      this.logger.debug?.('Opening sandbox...')\n\n      if (!this.sandbox && !this.opts.__debug_hostname) {\n        try {\n          const res = await this.createSandbox(this.apiKey, {\n            templateID: this.templateID,\n            metadata: this.opts.metadata,\n          })\n\n          this.sandbox = res.data\n          this.logger.debug?.(`Acquired sandbox \"${this.id}\"`)\n        } catch (e) {\n          if (e instanceof this.createSandbox.Error) {\n            const error = e.getActualType()\n            if (error.status === 400) {\n              throw new Error(\n                `Error creating sandbox - (${error.status}) bad request: ${error.data.message}`,\n              )\n            }\n            if (error.status === 401) {\n              throw new Error(\n                `Error creating sandbox - (${error.status}) unauthenticated: ${error.data.message}`,\n              )\n            }\n            if (error.status === 500) {\n              throw new Error(\n                `Error creating sandbox - (${error.status}) server error: ${error.data.message}`,\n              )\n            }\n          }\n          throw e\n        }\n      }\n\n      if (this.sandbox && !this.opts.__debug_hostname) {\n        this.refresh(this.sandbox.sandboxID)\n      }\n\n      await this.connectRpc()\n      return this\n    }\n\n    try {\n      return await withTimeout(open, opts?.timeout)()\n    } catch (err) {\n      await this.close()\n      throw err\n    }\n  }\n\n  private async connectRpc() {\n    const hostname = this.getHostname(this.opts.__debug_port || ENVD_PORT)\n    const protocol = this.getProtocol(\n      'ws',\n      this.opts.__debug_devEnv !== 'local',\n    )\n    const sandboxURL = `${protocol}://${hostname}${WS_ROUTE}`\n\n    let isFinished = false\n    let resolveOpening: (() => void) | undefined\n    let rejectOpening: (() => void) | undefined\n\n    const openingPromise = new Promise<void>((resolve, reject) => {\n      resolveOpening = () => {\n        if (isFinished) return\n        isFinished = true\n        resolve()\n      }\n      rejectOpening = () => {\n        if (isFinished) return\n        isFinished = true\n        reject()\n      }\n    })\n\n    this.rpc.onOpen(() => {\n      this.logger.debug?.(`Connected to sandbox \"${this.id}\"`)\n      resolveOpening?.()\n    })\n\n    this.rpc.onError(async (err) => {\n      this.logger.debug?.(\n        `Error in WebSocket of sandbox \"${this.id}\": ${\n          err.message ?? err.code ?? err.toString()\n        }. Trying to reconnect...`,\n      )\n\n      if (this.isOpen) {\n        await wait(WS_RECONNECT_INTERVAL)\n        this.logger.debug?.(`Reconnecting to sandbox \"${this.id}\"`)\n        try {\n          // When the WS connection closes the subscribers in devbookd are removed.\n          // We want to delete the subscriber handlers here so there are no orphans.\n          this.subscribers = []\n          await this.rpc.connect(sandboxURL)\n          this.logger.debug?.(`Reconnected to sandbox \"${this.id}\"`)\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (err: any) {\n          // not warn, because this is somewhat expected behaviour during initialization\n          this.logger.debug?.(\n            `Failed reconnecting to sandbox \"${this.id}\": ${\n              err.message ?? err.code ?? err.toString()\n            }`,\n          )\n        }\n      } else {\n        rejectOpening?.()\n      }\n    })\n\n    this.rpc.onClose(async () => {\n      this.logger.debug?.(`WebSocket connection to sandbox \"${this.id}\" closed`)\n    })\n\n    this.rpc.onNotification.push(this.handleNotification.bind(this))\n\n    // We invoke the rpc.connect method in a separate promise because when using edge\n    // the rpc.connect does not throw or end on error.\n    ;(async () => {\n      try {\n        this.logger.debug?.(`Connecting to sandbox \"${this.id}\"`)\n        await this.rpc.connect(sandboxURL)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (err: any) {\n        // not warn, because this is somewhat expected behaviour during initialization\n        this.logger.debug?.(\n          `Error connecting to sandbox \"${this.id}\": ${\n            err.message ?? err.code ?? err.toString()\n          }`,\n        )\n      }\n    })()\n\n    await openingPromise\n  }\n\n  private handleNotification(data: IRpcNotification) {\n    this.logger.debug?.('Handling notification:', data)\n    this.subscribers\n      .filter((s) => s.subID === data.params?.subscription)\n      .forEach((s) => s.handler(data.params?.result))\n  }\n\n  private async refresh(sandboxID: string) {\n    this.logger.debug?.(`Started refreshing sandbox \"${sandboxID}\"`)\n\n    try {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if (!this.isOpen) {\n          this.logger.debug?.(\n            `Cannot refresh sandbox ${this.id} - it was closed`,\n          )\n          return\n        }\n\n        await wait(SANDBOX_REFRESH_PERIOD)\n\n        try {\n          await this.refreshSandbox(this.apiKey, {\n            sandboxID,\n            duration: 0,\n          })\n          this.logger.debug?.(`Refreshed sandbox \"${sandboxID}\"`)\n        } catch (e) {\n          if (e instanceof this.refreshSandbox.Error) {\n            const error = e.getActualType()\n            if (error.status === 404) {\n              this.logger.warn?.(\n                `Error refreshing sandbox - (${error.status}): ${error.data.message}`,\n              )\n              return\n            }\n            this.logger.warn?.(\n              `Refreshing sandbox \"${sandboxID}\" failed - (${error.status})`,\n            )\n          }\n        }\n      }\n    } finally {\n      this.logger.debug?.(`Stopped refreshing sandbox \"${sandboxID}\"`)\n      await this.close()\n    }\n  }\n}\n","import path from 'path-browserify'\n\nimport { Logger } from '../sandbox/sandboxConnection'\n\nexport const resolvePath = (\n  inputPath: string,\n  cwd: string | undefined,\n  logger: Logger,\n): string => {\n  let result: string\n  if (inputPath.startsWith('./')) {\n    result = path.posix.join(cwd || '/home/user', inputPath)\n    if (!cwd) {\n      logger.warn?.(\n        `Path starts with './' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`,\n      )\n    }\n    return result\n  }\n\n  if (inputPath.startsWith('../')) {\n    result = path.posix.join(cwd || '/home/user', inputPath)\n    if (!cwd) {\n      logger.warn?.(\n        `Path starts with '../' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`,\n      )\n    }\n    return result\n  }\n  if (inputPath.startsWith('~/')) {\n    result = path.posix.join(cwd || '/home/user', inputPath.substring(2))\n    if (!cwd) {\n      logger.warn?.(\n        `Path starts with '~/' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`,\n      )\n    }\n    return result\n  }\n\n  if (!inputPath.startsWith('/') && cwd) {\n    return path.posix.join(cwd, inputPath)\n  }\n\n  return inputPath\n}\n","export { APIClient, withAPIKey, withAccessToken } from './api'\nexport type { components, paths } from './api'\n\nexport { SANDBOX_DOMAIN, API_HOST } from './constants'\nexport type { SandboxOpts, DownloadFileFormat } from './sandbox'\nexport type { OpenPort } from './sandbox/codeSnippet'\nexport { Terminal, TerminalOutput } from './sandbox/terminal'\nexport type { TerminalManager } from './sandbox/terminal'\nexport type { FilesystemManager, FileInfo } from './sandbox/filesystem'\nexport {\n  default as FilesystemWatcher,\n  FilesystemOperation,\n} from './sandbox/filesystemWatcher'\nexport type {\n  FilesystemEvent,\n  FilesystemEventListener,\n} from './sandbox/filesystemWatcher'\n\nexport { AuthenticationError, CurrentWorkingDirectoryDoesntExistError, TimeoutError } from './error'\nexport { Process, ProcessMessage, ProcessOutput } from './sandbox/process'\nexport type { ProcessManager } from './sandbox/process'\nexport type { EnvVars } from './sandbox/envVars'\nimport { Sandbox } from './sandbox'\n\nexport type { SandboxMetadata, RunningSandbox } from './sandbox/sandboxConnection'\n\nexport { Sandbox }\nexport default Sandbox\n"],"mappings":"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","names":["_a","_a","FilesystemOperation","path","TimeoutError","id","_a","_a","method","params","err","_a","path","opts","_a","_0","onData","size","onExit","envVars","cmd","cwd","terminalID","_b","process","id"]}