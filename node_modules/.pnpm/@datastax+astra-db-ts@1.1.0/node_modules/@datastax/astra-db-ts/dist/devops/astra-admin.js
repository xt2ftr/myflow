"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AstraAdmin_defaultOpts;
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAdminOpts = exports.mkAdmin = exports.AstraAdmin = void 0;
const api_1 = require("../api");
const utils_1 = require("../data-api/utils");
const db_1 = require("../data-api/db");
/**
 * An administrative class for managing Astra databases, including creating, listing, and deleting databases.
 *
 * **Shouldn't be instantiated directly; use {@link DataAPIClient.admin} to obtain an instance of this class.**
 *
 * To perform admin tasks on a per-database basis, see the {@link AstraDbAdmin} class.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('token');
 *
 * // Create an admin instance with the default token
 * const admin1 = client.admin();
 *
 * // Create an admin instance with a custom token
 * const admin2 = client.admin({ adminToken: 'stronger-token' });
 *
 * const dbs = await admin1.listDatabases();
 * console.log(dbs);
 * ```
 *
 * @see DataAPIClient.admin
 * @see AstraDbAdmin
 *
 * @public
 */
class AstraAdmin {
    /**
     * Use {@link DataAPIClient.admin} to obtain an instance of this class.
     *
     * @internal
     */
    constructor(options) {
        _AstraAdmin_defaultOpts.set(this, void 0);
        Object.defineProperty(this, "_httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const adminOpts = options.adminOptions ?? {};
        __classPrivateFieldSet(this, _AstraAdmin_defaultOpts, options, "f");
        Object.defineProperty(this, '_httpClient', {
            value: new api_1.DevOpsAPIHttpClient({
                baseUrl: adminOpts.endpointUrl || api_1.DEFAULT_DEVOPS_API_ENDPOINT,
                applicationToken: adminOpts.adminToken,
                monitorCommands: adminOpts.monitorCommands,
                emitter: options.emitter,
                fetchCtx: options.fetchCtx,
            }),
            enumerable: false,
        });
    }
    db(endpointOrId, regionOrOptions, maybeOptions) {
        return (0, db_1.mkDb)(__classPrivateFieldGet(this, _AstraAdmin_defaultOpts, "f"), endpointOrId, regionOrOptions, maybeOptions);
    }
    dbAdmin(endpointOrId, regionOrOptions, maybeOptions) {
        // @ts-expect-error - calls internal representation of method
        return this.db(endpointOrId, regionOrOptions, maybeOptions).admin(__classPrivateFieldGet(this, _AstraAdmin_defaultOpts, "f").adminOptions);
    }
    /**
     * Fetches the complete information about the database, such as the database name, IDs, region, status, actions, and
     * other metadata.
     *
     * @example
     * ```typescript
     * const info = await admin.info('<db_id>');
     * console.log(info.info.name, info.creationTime);
     * ```
     *
     * @returns A promise that resolves to the complete database information.
     */
    async dbInfo(id, options) {
        const resp = await this._httpClient.request({
            method: api_1.HttpMethods.Get,
            path: `/databases/${id}`,
        }, options);
        return resp.data;
    }
    /**
     * Lists all databases in the current org/account, matching the optionally provided filter.
     *
     * Note that this method is paginated, but the page size is high enough that most users won't need to worry about it.
     * However, you can use the `limit` and `skip` options to control the number of results returned and the starting point
     * for the results, as needed.
     *
     * You can also filter by the database status using the `include` option, and by the database provider using the
     * `provider` option.
     *
     * See {@link ListDatabasesOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('AstraCS:...').admin();
     *
     * const activeDbs = await admin.listDatabases({ include: 'ACTIVE' });
     *
     * for (const db of activeDbs) {
     *   console.log(`Database ${db.name} is active`);
     * }
     * ```
     *
     * @param options - The options to filter the databases by.
     * @returns A list of the complete information for all the databases matching the given filter.
     */
    async listDatabases(options) {
        const resp = await this._httpClient.request({
            method: api_1.HttpMethods.Get,
            path: `/databases`,
            params: {
                include: options?.include,
                provider: options?.provider,
                limit: options?.limit,
                starting_after: options?.skip,
            },
        }, options);
        return resp.data;
    }
    /**
     * Creates a new database with the given configuration.
     *
     * **NB. this is a long-running operation. See {@link AdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 2 min to complete.
     *
     * Note that **the `name` field is non-unique** and thus creating a database, even with the same options, is **not
     * idempotent**.
     *
     * You may also provide options for the implicit {@link Db} instance that will be created with the database, which
     * will override any default options set when creating the {@link DataAPIClient} through a deep merge (i.e. unset
     * properties in the options object will just default to the default options).
     *
     * See {@link CreateDatabaseOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const newDbAdmin1 = await admin.createDatabase({
     *   name: 'my_database_1',
     *   cloudProvider: 'GCP',
     *   region: 'us-east1',
     * });
     *
     * // Prints '[]' as there are no collections in the database yet
     * console.log(newDbAdmin1.db().listCollections());
     *
     * const newDbAdmin2 = await admin.createDatabase({
     *   name: 'my_database_2',
     *   cloudProvider: 'GCP',
     *   region: 'us-east1',
     *   namespace: 'my_namespace',
     * }, {
     *   blocking: false,
     *   dbOptions: {
     *     useHttp2: false,
     *     token: '<weaker-token>',
     *   },
     * });
     *
     * // Can't do much else as the database is still initializing
     * console.log(newDbAdmin2.db().id);
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the returned {@link AstraDbAdmin} object will not be very useful until the
     * operation completes, which is up to the caller to determine.
     *
     * @param config - The configuration for the new database.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns The AstraDbAdmin instance for the newly created database.
     */
    async createDatabase(config, options) {
        const definition = {
            capacityUnits: 1,
            tier: 'serverless',
            dbType: 'vector',
            keyspace: config.namespace || api_1.DEFAULT_NAMESPACE,
            ...config,
        };
        const resp = await this._httpClient.requestLongRunning({
            method: api_1.HttpMethods.Post,
            path: '/databases',
            data: definition,
        }, {
            id: (resp) => resp.headers.get('location'),
            target: 'ACTIVE',
            legalStates: ['INITIALIZING', 'PENDING'],
            defaultPollInterval: 10000,
            options,
        });
        const db = (0, db_1.mkDb)(__classPrivateFieldGet(this, _AstraAdmin_defaultOpts, "f"), resp.headers.get('location'), definition.region, { ...options?.dbOptions, namespace: definition.keyspace });
        return db.admin(__classPrivateFieldGet(this, _AstraAdmin_defaultOpts, "f").adminOptions);
    }
    /**
     * Terminates a database by ID or by a given {@link Db} instance.
     *
     * **NB. this is a long-running operation. See {@link AdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 6-7 min to complete.
     *
     * The database info will still be accessible by ID, or by using the {@link AstraAdmin.listDatabases} method with the filter
     * set to `'ALL'` or `'TERMINATED'`. However, all of its data will very much be lost.
     *
     * @example
     * ```typescript
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     * await admin.dropDatabase(db);
     *
     * // Or just
     * await admin.dropDatabase('a6a1d8d6-31bc-4af8-be57-377566f345bf');
     * ```
     *
     * @param db - The database to drop, either by ID or by instance.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     *
     * @remarks Use with caution. Wear a harness. Don't say I didn't warn you.
     */
    async dropDatabase(db, options) {
        const id = typeof db === 'string' ? db : db.id;
        await this._httpClient.requestLongRunning({
            method: api_1.HttpMethods.Post,
            path: `/databases/${id}/terminate`,
        }, {
            id: id,
            target: 'TERMINATED',
            legalStates: ['TERMINATING'],
            defaultPollInterval: 10000,
            options,
        });
    }
}
exports.AstraAdmin = AstraAdmin;
_AstraAdmin_defaultOpts = new WeakMap();
/**
 * @internal
 */
function mkAdmin(rootOpts, options) {
    validateAdminOpts(options);
    return new AstraAdmin({
        ...rootOpts,
        adminOptions: {
            ...rootOpts?.adminOptions,
            ...options,
        },
    });
}
exports.mkAdmin = mkAdmin;
/**
 * @internal
 */
function validateAdminOpts(opts) {
    (0, utils_1.validateOption)('admin options', opts, 'object');
    if (!opts) {
        return;
    }
    (0, utils_1.validateOption)('monitorCommands option', opts.monitorCommands, 'boolean');
    (0, utils_1.validateOption)('adminToken option', opts.adminToken, 'string');
    (0, utils_1.validateOption)('endpointUrl option', opts.endpointUrl, 'string');
}
exports.validateAdminOpts = validateAdminOpts;
//# sourceMappingURL=astra-admin.js.map