"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// noinspection ExceptionCaughtLocallyJS
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DataAPIHttpClient_props;
Object.defineProperty(exports, "__esModule", { value: true });
exports.reviver = exports.replacer = exports.DataAPIHttpClient = void 0;
const api_1 = require("../api");
const data_api_1 = require("../data-api");
const timeout_managers_1 = require("../api/timeout-managers");
const events_1 = require("../data-api/events");
const errors_1 = require("../data-api/errors");
/**
 * @internal
 */
class DataAPIHttpClient extends api_1.HttpClient {
    constructor(props) {
        super({
            ...props,
            mkAuthHeader: (token) => ({ [api_1.DEFAULT_DATA_API_AUTH_HEADER]: token }),
        });
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _DataAPIHttpClient_props.set(this, void 0);
        this.namespace = props.namespace;
        __classPrivateFieldSet(this, _DataAPIHttpClient_props, props, "f");
    }
    withCollection(namespace, collection) {
        const clone = new DataAPIHttpClient(__classPrivateFieldGet(this, _DataAPIHttpClient_props, "f"));
        clone.collection = collection;
        clone.namespace = namespace;
        return clone;
    }
    timeoutManager(timeoutMs) {
        return this._mkTimeoutManager(timeoutMs);
    }
    async executeCommand(command, options) {
        const timeoutManager = options?.timeoutManager ?? this._mkTimeoutManager(options?.maxTimeMS);
        return await this._requestDataAPI({
            url: this.baseUrl,
            timeoutManager: timeoutManager,
            collection: options?.collection,
            namespace: options?.namespace,
            command: command,
        });
    }
    async _requestDataAPI(info) {
        let started = 0;
        try {
            info.collection || (info.collection = this.collection);
            info.namespace || (info.namespace = this.namespace || api_1.DEFAULT_NAMESPACE);
            const keyspacePath = `/${info.namespace}`;
            const collectionPath = info.collection ? `/${info.collection}` : '';
            info.url += keyspacePath + collectionPath;
            if (this.monitorCommands) {
                started = (0, api_1.hrTimeMs)();
                this.emitter.emit('commandStarted', new events_1.CommandStartedEvent(info));
            }
            const resp = await this._request({
                url: info.url,
                data: JSON.stringify(info.command, replacer),
                timeoutManager: info.timeoutManager,
                method: api_1.HttpMethods.Post,
            });
            if (resp.status >= 400 && resp.status !== 401) {
                throw new errors_1.DataAPIHttpError(resp);
            }
            const data = JSON.parse(resp.body, reviver);
            if (resp.status === 401 || (data.errors && data.errors?.length > 0 && data?.errors[0]?.message === 'UNAUTHENTICATED: Invalid token')) {
                const fauxResponse = mkFauxErroredResponse('Authentication failed; is your token valid?');
                throw (0, errors_1.mkRespErrorFromResponse)(data_api_1.DataAPIResponseError, info.command, fauxResponse);
            }
            if (data.errors && data?.errors?.length > 0 && data?.errors[0]?.errorCode === 'COLLECTION_NOT_EXIST') {
                const name = data?.errors[0]?.message.split(': ')[1];
                throw new errors_1.CollectionNotFoundError(info.namespace, name);
            }
            if (data?.errors && data?.errors.length > 0) {
                throw (0, errors_1.mkRespErrorFromResponse)(data_api_1.DataAPIResponseError, info.command, data);
            }
            const respData = {
                status: data?.status,
                data: data?.data,
                errors: data?.errors,
            };
            if (this.monitorCommands) {
                this.emitter.emit('commandSucceeded', new events_1.CommandSucceededEvent(info, respData, started));
            }
            return respData;
        }
        catch (e) {
            if (this.monitorCommands) {
                this.emitter.emit('commandFailed', new events_1.CommandFailedEvent(info, e, started));
            }
            throw e;
        }
    }
    _mkTimeoutManager(timeout) {
        timeout ?? (timeout = this.fetchCtx.maxTimeMS ?? api_1.DEFAULT_TIMEOUT);
        return new timeout_managers_1.TimeoutManager(timeout, () => new data_api_1.DataAPITimeoutError(timeout));
    }
}
exports.DataAPIHttpClient = DataAPIHttpClient;
_DataAPIHttpClient_props = new WeakMap();
const mkFauxErroredResponse = (message) => {
    return { errors: [{ message }] };
};
/**
 * @internal
 */
function replacer(key, value) {
    if (typeof value === 'bigint') {
        return Number(value);
    }
    if (typeof this[key] === 'object') {
        if (key === '$date') {
            return new Date(value).valueOf();
        }
        if (this[key] instanceof Date) {
            return { $date: this[key].valueOf() };
        }
    }
    return value;
}
exports.replacer = replacer;
/**
 * @internal
 */
function reviver(_, value) {
    if (!value) {
        return value;
    }
    if (value.$date) {
        return new Date(value.$date);
    }
    if (value.$objectId) {
        return new data_api_1.ObjectId(value.$objectId);
    }
    if (value.$uuid) {
        return new data_api_1.UUID(value.$uuid);
    }
    return value;
}
exports.reviver = reviver;
//# sourceMappingURL=data-api-http-client.js.map