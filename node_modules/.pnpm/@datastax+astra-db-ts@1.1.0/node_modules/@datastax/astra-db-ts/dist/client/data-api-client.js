"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// noinspection JSDeprecatedSymbols
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _DataAPIClient_options, _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataAPIClient = exports.DataAPIClientEventEmitterBase = void 0;
const db_1 = require("../data-api/db");
const astra_admin_1 = require("../devops/astra-admin");
const events_1 = __importDefault(require("events"));
const utils_1 = require("../data-api/utils");
const fetch_h2_1 = require("fetch-h2");
const api_1 = require("../api");
/**
 * The base class for the {@link DataAPIClient} event emitter to make it properly typed.
 *
 * Should probably never need to be used directly.
 *
 * @public
 */
exports.DataAPIClientEventEmitterBase = events_1.default;
/**
 * The main entrypoint into working with the Data API. It sits at the top of the
 * [conceptual hierarchy](https://github.com/datastax/astra-db-ts/tree/signature-cleanup?tab=readme-ov-file#abstraction-diagram)
 * of the SDK.
 *
 * The client takes in a default token, which can be overridden by a stronger/weaker token when spawning a new
 * {@link Db} or {@link AstraAdmin} instance.
 *
 * It also takes in a set of default options (see {@link DataAPIClientOptions}) that may also be overridden as necessary.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('AstraCS:...');
 *
 * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
 * const db2 = client.db('my-database', 'us-east1');
 *
 * const coll = await db1.collection('my-collection');
 *
 * const admin1 = client.admin();
 * const admin2 = client.admin({ adminToken: '<stronger_token>' });
 *
 * console.log(await coll.insertOne({ name: 'Lordi' }));
 * console.log(await admin1.listDatabases());
 * ```
 *
 * @public
 */
class DataAPIClient extends exports.DataAPIClientEventEmitterBase {
    /**
     * Constructs a new instance of the {@link DataAPIClient}.
     *
     * @param token - The default token to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     * @param options - The default options to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     */
    constructor(token, options) {
        super();
        _DataAPIClient_options.set(this, void 0);
        /**
         * Allows for the `await using` syntax (if your typescript version \>= 5.2) to automatically close the client when
         * it's out of scope.
         *
         * Equivalent to wrapping the client usage in a `try`/`finally` block and calling `client.close()` in the `finally`
         * block.
         *
         * @example
         * ```typescript
         * async function main() {
         *   // Will unconditionally close the client when the function exits
         *   await using client = new DataAPIClient('*TOKEN*');
         *
         *   // Using the client as normal
         *   const db = client.db('*ENDPOINT*');
         *   console.log(await db.listCollections());
         *
         *   // Or pass it to another function to run your app
         *   app(client);
         * }
         * main();
         * ```
         *
         * *This will only be defined if the `Symbol.asyncDispose` symbol is actually defined.*
         */
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!token || typeof token !== 'string') {
            throw new Error('A valid token is required to use the DataAPIClient');
        }
        validateRootOpts(options);
        const baseCtxOptions = {
            userAgent: (0, api_1.buildUserAgent)(options?.caller),
            overwriteUserAgent: true,
            http1: {
                keepAlive: options?.httpOptions?.http1?.keepAlive,
                keepAliveMsecs: options?.httpOptions?.http1?.keepAliveMS,
                maxSockets: options?.httpOptions?.http1?.maxSockets,
                maxFreeSockets: options?.httpOptions?.http1?.maxFreeSockets,
            },
        };
        const http1Ctx = (0, fetch_h2_1.context)({
            ...baseCtxOptions,
            httpsProtocols: ['http1'],
        });
        const preferHttp2 = options?.httpOptions?.preferHttp2 ?? getDeprecatedPrefersHttp2(options) ?? true;
        const preferredCtx = (preferHttp2)
            ? (0, fetch_h2_1.context)(baseCtxOptions)
            : http1Ctx;
        __classPrivateFieldSet(this, _DataAPIClient_options, {
            ...options,
            fetchCtx: {
                http1: http1Ctx,
                preferred: preferredCtx,
                preferredType: (preferHttp2)
                    ? 'http2'
                    : 'http1',
                closed: { ref: false },
                maxTimeMS: options?.httpOptions?.maxTimeMS,
            },
            dbOptions: {
                monitorCommands: false,
                token: token,
                ...options?.dbOptions,
            },
            adminOptions: {
                monitorCommands: false,
                adminToken: token,
                ...options?.adminOptions,
            },
            emitter: this,
        }, "f");
        if (Symbol.asyncDispose) {
            this[Symbol.asyncDispose] = this.close;
        }
    }
    db(endpointOrId, regionOrOptions, maybeOptions) {
        return (0, db_1.mkDb)(__classPrivateFieldGet(this, _DataAPIClient_options, "f"), endpointOrId, regionOrOptions, maybeOptions);
    }
    /**
     * Spawns a new {@link AstraAdmin} instance using the given options to work with the DevOps API (for admin
     * work such as creating/managing databases).
     *
     * **NB. This method is only available for Astra databases.**
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin1 = client.admin();
     * const admin2 = client.admin({ adminToken: '<stronger_token>' });
     *
     * const dbs = await admin1.listDatabases();
     * console.log(dbs);
     * ```
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraAdmin} instance.
     */
    admin(options) {
        return (0, astra_admin_1.mkAdmin)(__classPrivateFieldGet(this, _DataAPIClient_options, "f"), options);
    }
    /**
     * Closes the client and disconnects all underlying connections. This should be called when the client is no longer
     * needed to free up resources.
     *
     * The client will be no longer usable after this method is called.
     *
     * @remarks
     * This method is idempotent and can be called multiple times without issue.
     *
     * --
     *
     * For most users, this method isn't necessary to call, as resources will be freed up when the
     * server is shut down or the process is killed. However, it's useful in long-running processes or when you want to
     * free up resources immediately.
     *
     * --
     *
     * Think of it as using malloc or using a file descriptor. Freeing them isn't always strictly necessary for
     * long-running usages, but it's there for when you need it.
     *
     * @returns A promise that resolves when the client has been closed.
     */
    async close() {
        __classPrivateFieldGet(this, _DataAPIClient_options, "f").fetchCtx.closed.ref = true;
        await __classPrivateFieldGet(this, _DataAPIClient_options, "f").fetchCtx.preferred.disconnectAll();
        await __classPrivateFieldGet(this, _DataAPIClient_options, "f").fetchCtx.http1.disconnectAll();
    }
}
exports.DataAPIClient = DataAPIClient;
_DataAPIClient_options = new WeakMap(), _a = Symbol.asyncDispose;
// Shuts the linter up about 'preferHttp2' not being deprecated
function getDeprecatedPrefersHttp2(opts) {
    return opts?.['preferHttp2'];
}
function validateRootOpts(opts) {
    (0, utils_1.validateOption)('root client options', opts, 'object');
    if (!opts) {
        return;
    }
    (0, utils_1.validateOption)('caller', opts.caller, 'object', validateCaller);
    (0, utils_1.validateOption)('preferHttp2 option', getDeprecatedPrefersHttp2(opts), 'boolean');
    (0, db_1.validateDbOpts)(opts.dbOptions);
    (0, astra_admin_1.validateAdminOpts)(opts.adminOptions);
    validateHttpOpts(opts.httpOptions);
}
function validateHttpOpts(opts) {
    (0, utils_1.validateOption)('http options', opts, 'object');
    if (!opts) {
        return;
    }
    (0, utils_1.validateOption)('preferHttp2 option', opts.preferHttp2, 'boolean');
    (0, utils_1.validateOption)('maxTimeMS option', opts.maxTimeMS, 'number');
    (0, utils_1.validateOption)('http1 options', opts.http1, 'object', (http1) => {
        (0, utils_1.validateOption)('http1.keepAlive option', http1.keepAlive, 'boolean');
        (0, utils_1.validateOption)('http1.keepAliveMS option', http1.keepAliveMS, 'number');
        (0, utils_1.validateOption)('http1.maxSockets option', http1.maxSockets, 'number');
        (0, utils_1.validateOption)('http1.maxFreeSockets option', http1.maxFreeSockets, 'number');
    });
}
function validateCaller(caller) {
    if (!Array.isArray(caller)) {
        throw new TypeError('Invalid caller; expected an array, or undefined/null');
    }
    const isCallerArr = Array.isArray(caller[0]);
    const callers = ((isCallerArr)
        ? caller
        : [caller]);
    callers.forEach((c, i) => {
        const idxMessage = (isCallerArr)
            ? ` at index ${i}`
            : '';
        if (!Array.isArray(c)) {
            throw new TypeError(`Invalid caller; expected [name, version?], or an array of such${idxMessage}`);
        }
        if (c.length < 1 || 2 < c.length) {
            throw new Error(`Invalid caller; expected [name, version?], or an array of such${idxMessage}`);
        }
        if (typeof c[0] !== 'string') {
            throw new Error(`Invalid caller; expected a string name${idxMessage}`);
        }
        if (c.length === 2 && typeof c[1] !== 'string') {
            throw new Error(`Invalid caller; expected a string version${idxMessage}`);
        }
    });
}
//# sourceMappingURL=data-api-client.js.map