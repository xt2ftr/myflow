"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const utils_1 = require("./utils");
const cursor_1 = require("../data-api/cursor");
const errors_1 = require("../data-api/errors");
const object_hash_1 = __importDefault(require("object-hash"));
const types_1 = require("../data-api/types");
/**
 * Represents the interface to a collection in the database.
 *
 * **Shouldn't be directly instantiated, but rather created via {@link Db.createCollection},
 * or connected to using {@link Db.collection}**.
 *
 * Typed as `Collection<Schema>` where `Schema` is the type of the documents in the collection.
 * Operations on the collection will be strongly typed if a specific schema is provided, otherwise
 * remained largely weakly typed if no type is provided, which may be preferred for dynamic data
 * access & operations.
 *
 * @example
 * ```typescript
 * const collection = await db.createCollection<PersonSchema>('my_collection');
 * await collection.insertOne({ _id: '1', name: 'John Doe' });
 * await collection.drop();
 * ```
 *
 * @see SomeDoc
 * @see VectorDoc
 *
 * @public
 */
class Collection {
    /**
     * Use {@link Db.collection} to obtain an instance of this class.
     *
     * @internal
     */
    constructor(db, httpClient, name, namespace) {
        Object.defineProperty(this, "_httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_db", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The name of the collection.
         */
        Object.defineProperty(this, "collectionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The namespace (aka keyspace) that the collection lives in.
         */
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, 'collectionName', {
            value: name,
            writable: false,
        });
        Object.defineProperty(this, 'namespace', {
            value: namespace ?? db.namespace,
            writable: false,
        });
        Object.defineProperty(this, '_httpClient', {
            value: httpClient.withCollection(this.namespace, this.collectionName),
            enumerable: false,
        });
        Object.defineProperty(this, '_db', {
            value: db,
            enumerable: false,
        });
    }
    /**
     * Inserts a single document into the collection atomically.
     *
     * If the document does not contain an `_id` field, the server will generate an id for the document. The type of the
     * id may be specified in {@link CollectionOptions.defaultId} at creation, otherwise it'll just be a UUID string. This
     * generation will not mutate the documents.
     *
     * If an `_id` is provided which corresponds to a document that already exists in the collection, an error is raised,
     * and the insertion fails.
     *
     * See {@link InsertOneOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * // Insert a document with a specific ID
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     *
     * // Insert a document with an autogenerated ID
     * await collection.insertOne({ name: 'Jane Doe' });
     *
     * // Insert a document with a vector
     * await collection.insertOne({ name: 'Jane Doe' }, { vector: [.12, .52, .32] });
     * await collection.insertOne({ name: 'Jane Doe', $vector: [.12, .52, .32] });
     * ```
     *
     * @param document - The document to insert.
     * @param options - The options for this operation.
     *
     * @returns The result of the operation.
     */
    async insertOne(document, options) {
        const command = {
            insertOne: { document },
        };
        if (options?.vector && options?.vectorize) {
            throw new Error('Cannot set both vector and vectorize options');
        }
        if (options?.vector) {
            command.insertOne.document = { ...command.insertOne.document, $vector: options.vector };
        }
        if (options?.vectorize) {
            command.insertOne.document = { ...command.insertOne.document, $vectorize: options.vectorize };
        }
        const resp = await this._httpClient.executeCommand(command, options);
        return {
            insertedId: resp.status?.insertedIds[0],
        };
    }
    /**
     * Inserts many documents into the collection.
     *
     * **NB. This function paginates the insertion of documents in chunks to avoid running into insertion limits. This
     * means multiple requests may be made to the server, and the operation may not be atomic.**
     *
     * If any document does not contain an `_id` field, the server will generate an id for the document. The type of the
     * id may be specified in {@link CollectionOptions.defaultId} at creation, otherwise it'll just be a UUID string. This
     * generation will not mutate the documents.
     *
     * You may set the `ordered` option to `true` to stop the operation after the first error; otherwise all documents
     * may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
     *
     * You can set the `concurrency` option to control how many network requests are made in parallel on unordered
     * insertions. Defaults to `8`.
     *
     * If a 2XX insertion error occurs, the operation will throw an {@link InsertManyError} containing the partial result.
     *
     * See {@link InsertManyOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * try {
     *   await collection.insertMany([
     *     { _id: '1', name: 'John Doe' },
     *     { name: 'Jane Doe' },
     *   ], { ordered: true });
     *
     *   await collection.insertMany([
     *     { _id: '1', name: 'John Doe', $vector: [.12, .52, .32] },
     *     { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   ]);
     *
     *   await collection.insertMany([
     *     { _id: '1', name: 'John Doe' },
     *     { name: 'Jane Doe' },
     *   ], {
     *     vectors: [
     *       [.12, .52, .32],
     *       [.32, .52, .12],
     *     ],
     *     ordered: true,
     *   });
     * } catch (e) {
     *   if (e instanceof InsertManyError) {
     *     console.log(e.insertedIds);
     *   }
     * }
     * ```
     *
     * @remarks
     * This operation is not atomic. Depending on the amount of inserted documents, and if it's ordered or not, it can
     * keep running (in a blocking way) for a macroscopic amount of time. In that case, new documents that are inserted
     * from another concurrent process/application may be inserted during the execution of this method call, and if there
     * are duplicate keys, it's not easy to predict which application will win the race.
     *
     * --
     *
     * *If a thrown exception is not due to an insertion error, e.g. a `5xx` error or network error, the operation will throw the
     * underlying error.*
     *
     * *In case of an unordered request, if the error was a simple insertion error, a `InsertManyError` will be thrown
     * after every document has been attempted to be inserted. If it was a `5xx` or similar, the error will be thrown
     * immediately.*
     *
     * @param documents - The documents to insert.
     * @param options - The options for this operation.
     *
     * @returns The aggregated result of the operation.
     *
     * @throws InsertManyError - If the operation fails.
     */
    async insertMany(documents, options) {
        const chunkSize = options?.chunkSize ?? 20;
        if (options?.vectors) {
            if (options.vectors.length !== documents.length) {
                throw new Error('The number of vectors must match the number of documents');
            }
            for (let i = 0, n = documents.length; i < n; i++) {
                if (options.vectors[i]) {
                    documents[i] = { ...documents[i], $vector: options.vectors[i] };
                }
            }
        }
        if (options?.vectorize) {
            if (options.vectorize.length !== documents.length) {
                throw new Error('The number of vectors must match the number of documents');
            }
            for (let i = 0, n = documents.length; i < n; i++) {
                if (options.vectorize[i]) {
                    if (documents[i].$vector) {
                        throw new Error('Vector and vectorize options cannot overlap');
                    }
                    documents[i] = { ...documents[i], $vectorize: options.vectorize[i] };
                }
            }
        }
        const timeoutManager = this._httpClient.timeoutManager(options?.maxTimeMS);
        const insertedIds = (options?.ordered)
            ? await insertManyOrdered(this._httpClient, documents, chunkSize, timeoutManager)
            : await insertManyUnordered(this._httpClient, documents, options?.concurrency ?? 8, chunkSize, timeoutManager);
        return {
            insertedCount: insertedIds.length,
            insertedIds: insertedIds,
        };
    }
    /**
     * Atomically updates a single document in the collection.
     *
     * If `upsert` is set to true, it will insert the document if no match is found.
     *
     * You can also specify a sort option to determine which document to update if multiple documents match the filter.
     *
     * See {@link UpdateOneOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * // Update by ID
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     *
     * await collection.updateOne(
     *   { _id: '1' },
     *   { $set: { name: 'Jane Doe' }
     * });
     *
     * // Update by vector search
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     *
     * await collection.updateOne(
     *   {},
     *   { $set: { name: 'Jane Doe' } },
     *   { vector: [.09, .58, .21] }
     * );
     *
     * await collection.updateOne(
     *   {},
     *   { $set: { name: 'Jane Doe' } },
     *   { sort: { $vector: [.09, .58, .21] } }
     * );
     * ```
     *
     * @param filter - A filter to select the document to update.
     * @param update - The update to apply to the selected document.
     * @param options - The options for this operation.
     *
     * @returns The result of the operation.
     *
     * @see StrictFilter
     * @see StrictUpdateFilter
     */
    async updateOne(filter, update, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            updateOne: {
                filter,
                update,
                options: {
                    upsert: options?.upsert,
                },
            },
        };
        if (options?.sort) {
            command.updateOne.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        const resp = await this._httpClient.executeCommand(command, options);
        const commonResult = {
            modifiedCount: resp.status?.modifiedCount,
            matchedCount: resp.status?.matchedCount,
        };
        return (resp.status?.upsertedId)
            ? {
                ...commonResult,
                upsertedId: resp.status?.upsertedId,
                upsertedCount: 1,
            }
            : {
                ...commonResult,
                upsertedCount: 0,
            };
    }
    /**
     * Updates many documents in the collection.
     *
     * **NB. This function paginates the updating of documents in chunks to avoid running into insertion limits. This
     * means multiple requests may be made to the server, and the operation may not be atomic.**
     *
     * If `upsert` is set to true, it will insert a document if no match is found.
     *
     * You can also specify a sort option to determine which documents to update if multiple documents match the filter.
     *
     * See {@link UpdateManyOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { _id: '1', name: 'John Doe', car: 'Renault Twizy' },
     *   { _id: UUID.v4(), name: 'Jane Doe' },
     *   { name: 'Dane Joe' },
     * ]);
     *
     * // Will give 'Jane' and 'Dane' a car 'unknown'
     * await collection.updateMany({
     *   car: { $exists: false },
     * }, {
     *   $set: { car: 'unknown' },
     * });
     *
     * // Will upsert a document with name 'Anette' and car 'Volvo v90'
     * await collection.updateMany({
     *   name: 'Anette',
     * }, {
     *   $set: { car: 'Volvo v90' },
     * }, {
     *   upsert: true,
     * });
     * ```
     *
     * @remarks
     * This operation is not atomic. Depending on the amount of matching documents, it can keep running (in a blocking
     * way) for a macroscopic amount of time. In that case, new documents that are inserted from another concurrent process/
     * application at the same time may be updated during the execution of this method call. In other words, it cannot
     * easily be predicted whether a given newly-inserted document will be picked up by the updateMany command or not.
     *
     * @param filter - A filter to select the documents to update.
     * @param update - The update to apply to the selected documents.
     * @param options - The options for this operation.
     *
     * @returns The aggregated result of the operation.
     *
     * @see StrictFilter
     * @see StrictUpdateFilter
     */
    async updateMany(filter, update, options) {
        const command = {
            updateMany: {
                filter,
                update,
                options: {
                    upsert: options?.upsert,
                },
            },
        };
        const timeoutManager = this._httpClient.timeoutManager(options?.maxTimeMS);
        const commonResult = {
            modifiedCount: 0,
            matchedCount: 0,
            upsertedCount: 0,
        };
        let resp;
        try {
            while (!resp || resp.status?.nextPageState) {
                resp = await this._httpClient.executeCommand(command, { timeoutManager });
                command.updateMany.options.pagingState = resp.status?.nextPageState;
                commonResult.modifiedCount += resp.status?.modifiedCount ?? 0;
                commonResult.matchedCount += resp.status?.matchedCount ?? 0;
            }
        }
        catch (e) {
            if (!(e instanceof errors_1.DataAPIResponseError)) {
                throw e;
            }
            const desc = e.detailedErrorDescriptors[0];
            commonResult.modifiedCount += desc.rawResponse?.status?.modifiedCount ?? 0;
            commonResult.matchedCount += desc.rawResponse?.status?.matchedCount ?? 0;
            commonResult.upsertedCount = desc.rawResponse?.status?.upsertedCount ?? 0;
            throw (0, errors_1.mkRespErrorFromResponse)(errors_1.UpdateManyError, command, desc.rawResponse, commonResult);
        }
        return (resp.status?.upsertedId)
            ? {
                ...commonResult,
                upsertedId: resp.status?.upsertedId,
                upsertedCount: 1,
            }
            : commonResult;
    }
    /**
     * Replaces a single document in the collection.
     *
     * If `upsert` is set to true, it will insert the replacement regardless of if no match is found.
     *
     * See {@link ReplaceOneOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * await collection.insertOne({
     *   _id: '1',
     *   name: 'John Doe',
     *   $vector: [.12, .52, .32],
     * });
     *
     * // Replace by ID
     * await collection.replaceOne({ _id: '1' }, { name: 'Jane Doe' });
     *
     * // Replace by name
     * await collection.replaceOne({
     *   name: 'John Doe',
     * }, {
     *   name: 'Jane Doe',
     * });
     *
     * // Replace by vector
     * await collection.replaceOne({}, {
     *   name: 'Jane Doe'
     * }, {
     *   vector: [.09, .58, .22],
     * });
     *
     * // Upsert if no match
     * await collection.replaceOne({
     *   name: 'Lynyrd Skynyrd',
     * }, {
     *   name: 'Lenerd Skinerd',
     * }, {
     *   upsert: true,
     * });
     * ```
     *
     * @param filter - A filter to select the document to replace.
     * @param replacement - The replacement document, which contains no `_id` field.
     * @param options - The options for this operation.
     *
     * @returns The result of the operation.
     *
     * @see StrictFilter
     */
    async replaceOne(filter, replacement, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            findOneAndReplace: {
                filter,
                replacement,
                options: {
                    returnDocument: 'before',
                    upsert: options?.upsert,
                },
                // projection: { '*': 0 },
            },
        };
        if (options?.sort) {
            command.findOneAndReplace.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        const resp = await this._httpClient.executeCommand(command, options);
        const commonResult = {
            modifiedCount: resp.status?.modifiedCount,
            matchedCount: resp.status?.matchedCount,
        };
        return (resp.status?.upsertedId)
            ? {
                ...commonResult,
                upsertedId: resp.status?.upsertedId,
                upsertedCount: 1,
            }
            : {
                ...commonResult,
                upsertedCount: 0,
            };
    }
    /**
     * Atomically deletes a single document from the collection.
     *
     * You can specify a `sort` option to determine which document to delete if multiple documents match the filter.
     *
     * See {@link DeleteOneOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * // Delete by _id
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.deleteOne({ _id: '1' });
     *
     * // Delete by name
     * await collection.insertOne({ name: 'Jane Doe', age: 25 });
     * await collection.insertOne({ name: 'Jane Doe', age: 33 });
     * await collection.deleteOne({ name: 'Jane Doe' }, { sort: { age: -1 } });
     *
     * // Delete by vector
     * await collection.insertOne({ name: 'Jane Doe', $vector: [.12, .52, .32] });
     * await collection.deleteOne({}, { vector: [.09, .58, .42] });
     * ```
     *
     * @param filter - A filter to select the document to delete.
     * @param options - The options for this operation.
     *
     * @returns The result of the operation.
     *
     * @see StrictFilter
     */
    async deleteOne(filter = {}, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            deleteOne: { filter },
        };
        if (options?.sort) {
            command.deleteOne.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        const deleteOneResp = await this._httpClient.executeCommand(command, options);
        return {
            deletedCount: deleteOneResp.status?.deletedCount,
        };
    }
    /**
     * Deletes many documents from the collection.
     *
     * **NB. This function paginates the deletion of documents in chunks to avoid running into insertion limits. This
     * means multiple requests may be made to the server, and the operation may not be atomic.**
     *
     * If an empty filter is passed, an error will be thrown, asking you to use {@link Collection.deleteAll} instead for your safety.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { _id: '1', name: 'John Doe' },
     *   { name: 'John Doe' },
     * ]);
     *
     * await collection.deleteMany({ name: 'John Doe' });
     * ```
     *
     * @remarks
     * This operation is not atomic. Depending on the amount of matching documents, it can keep running (in a blocking
     * way) for a macroscopic amount of time. In that case, new documents that are inserted from another concurrent process/
     * application at the same time may be deleted during the execution of this method call. In other words, it cannot
     * easily be predicted whether a given newly-inserted document will be picked up by the deleteMany command or not.
     *
     * @param filter - A filter to select the documents to delete.
     * @param options - The options for this operation.
     *
     * @returns The aggregated result of the operation.
     *
     * @throws Error - If an empty filter is passed.
     *
     * @see StrictFilter
     */
    async deleteMany(filter = {}, options) {
        if (Object.keys(filter).length === 0) {
            throw new Error('Can\'t pass an empty filter to deleteMany, use deleteAll instead if you really want to delete everything');
        }
        const command = {
            deleteMany: { filter },
        };
        const timeoutManager = this._httpClient.timeoutManager(options?.maxTimeMS);
        let resp;
        let numDeleted = 0;
        try {
            while (!resp || resp.status?.moreData) {
                resp = await this._httpClient.executeCommand(command, { timeoutManager });
                numDeleted += resp.status?.deletedCount ?? 0;
            }
        }
        catch (e) {
            if (!(e instanceof errors_1.DataAPIResponseError)) {
                throw e;
            }
            const desc = e.detailedErrorDescriptors[0];
            throw (0, errors_1.mkRespErrorFromResponse)(errors_1.DeleteManyError, command, desc.rawResponse, { deletedCount: numDeleted + (desc.rawResponse?.status?.deletedCount ?? 0) });
        }
        return {
            deletedCount: numDeleted,
        };
    }
    /**
     * Deletes all documents from the collection.
     *
     * Unlike {@link Collection.deleteMany}, this method is atomic and will delete all documents in the collection in one go,
     * without making multiple network requests to the server.
     *
     * @remarks Use with caution. Wear a helmet. Don't say I didn't warn you.
     *
     * @param options - The options for this operation.
     *
     * @returns A promise that resolves when the operation is complete.
     */
    async deleteAll(options) {
        const command = {
            deleteMany: { filter: {} },
        };
        await this._httpClient.executeCommand(command, options);
    }
    /**
     * Find documents on the collection, optionally matching the provided filter.
     *
     * Also accepts `sort`, `limit`, `skip`, `includeSimilarity`, and `projection` options.
     *
     * The method returns a {@link FindCursor} that can then be iterated over.
     *
     * **NB. If a *non-vector-sort* `sort` option is provided, the iteration of all documents may not be atomic**—it will
     * iterate over cursors in an approximate way, exhibiting occasional skipped or duplicate documents, with real-time
     * collection insertions/mutations being displayed.
     *
     * See {@link FindOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     *   { name: 'Dane Joe' },
     * ], {
     *   vectors: [
     *     [.12, .52, .32],
     *     [.32, .52, .12],
     *     [.52, .32, .12],
     *   ],
     * });
     *
     * // Find by name
     * const cursor1 = collection.find({ name: 'John Doe' });
     *
     * // Returns ['John Doe']
     * console.log(await cursor1.toArray());
     *
     * // Match all docs, sorting by name
     * const cursor2 = collection.find({}, {
     *   sort: { name: 1 },
     * });
     *
     * // Returns 'Dane Joe', 'Jane Doe', 'John Doe'
     * for await (const doc of cursor2) {
     *   console.log(doc);
     * }
     *
     * // Find by vector
     * const cursor3 = collection.find({}, {
     *   vector: [.12, .52, .32],
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor3.next());
     * ```
     *
     * @remarks
     * Some combinations of arguments impose an implicit upper bound on the number of documents that are returned by the
     * Data API. Namely:
     *
     * (a) Vector ANN searches cannot return more than a number of documents
     * that at the time of writing is set to 1000 items.
     *
     * (b) When using a sort criterion of the ascending/descending type,
     * the Data API will return a smaller number of documents, set to 20
     * at the time of writing, and stop there. The returned documents are
     * the top results across the whole collection according to the requested
     * criterion.
     *
     * --
     *
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of documents as
     * the Data API and the client periodically exchange new chunks of documents.
     * It should be noted that the behavior of the cursor in the case documents
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns A FindCursor which can be iterated over.
     *
     * @see StrictFilter
     */
    find(filter, options) {
        return new cursor_1.FindCursor(this.namespace, this._httpClient, filter, coalesceVectorSpecialsIntoSort(options));
    }
    /**
     * Return a list of the unique values of `key` across the documents in the collection that match the provided filter.
     *
     * **NB. This is a *client-side* operation**—this effectively browses all matching documents (albeit with a
     * projection) using the logic of the {@link Collection.find} method, and collects the unique value for the
     * given `key` manually. As such, there may be performance, latency and ultimately billing implications if the
     * amount of matching documents is large.
     *
     * The key may use dot-notation to access nested fields, such as `'field'`, `'field.subfield'`, `'field.3'`,
     * `'field.3.subfield'`, etc. If lists are encountered and no numeric index is specified, all items in the list are
     * pulled.
     *
     * **Note that on complex extractions, the return type may be not as expected.** In that case, it's on the user to
     * cast the return type to the correct one.
     *
     * Distinct works with arbitrary objects as well, by creating a deterministic hash of the object and comparing it
     * with the hashes of the objects already seen. This, unsurprisingly, may not be great for performance if you have
     * a lot of records that match, so it's recommended to use distinct on simple values whenever performance or number
     * of records is a concern.
     *
     * For details on the behaviour of "distinct" in conjunction with real-time changes in the collection contents, see
     * the remarks on the `find` command.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { letter: { value: 'a' }, car: [1] },
     *   { letter: { value: 'b' }, car: [2, 3] },
     *   { letter: { value: 'a' }, car: [2], bus: 'no' },
     * ]);
     *
     * // ['a', 'b']
     * const distinct = await collection.distinct('letter.value');
     *
     * await collection.insertOne({
     *   x: [{ y: 'Y', 0: 'ZERO' }],
     * });
     *
     * // ['Y']
     * await collection.distinct('x.y');
     *
     * // [{ y: 'Y', 0: 'ZERO' }]
     * await collection.distinct('x.0');
     *
     * // ['Y']
     * await collection.distinct('x.0.y');
     *
     * // ['ZERO']
     * await collection.distinct('x.0.0');
     * ```
     *
     * @param key - The dot-notation key to pick which values to retrieve unique
     * @param filter - A filter to select the documents to find. If not provided, all documents will be matched.
     *
     * @returns A list of all the unique values selected by the given `key`
     *
     * @see StrictFilter
     */
    async distinct(key, filter = {}) {
        assertPathSafe4Distinct(key);
        const projection = pullSafeProjection4Distinct(key);
        const cursor = this.find(filter, { projection: { _id: 0, [projection]: 1 } });
        const seen = new Set();
        const ret = [];
        const extract = mkDistinctPathExtractor(key);
        for await (const doc of cursor) {
            const values = extract(doc);
            for (let i = 0, n = values.length; i < n; i++) {
                if (typeof values[i] === 'object') {
                    const hash = (0, object_hash_1.default)(values[i]);
                    if (!seen.has(hash)) {
                        seen.add(hash);
                        ret.push(values[i]);
                    }
                }
                else {
                    if (!seen.has(values[i])) {
                        seen.add(values[i]);
                        ret.push(values[i]);
                    }
                }
            }
        }
        return ret;
    }
    /**
     * Finds a single document in the collection, if it exists.
     *
     * You can specify a `sort` option to determine which document to find if multiple documents match the filter.
     *
     * You can also specify a `projection` option to determine which fields to include in the returned document.
     *
     * If performing a vector search, you can set the `includeSimilarity` option to `true` to include the similarity score
     * in the returned document as `$similarity: number`.
     *
     * See {@link FindOneOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const doc1 = await collection.findOne({
     *   name: 'John Doe',
     * });
     *
     * // Will be undefined
     * console.log(doc1?.$similarity);
     *
     * const doc2 = await collection.findOne({}, {
     *   sort: {
     *     $vector: [.12, .52, .32],
     *   },
     *   includeSimilarity: true,
     * });
     *
     * // Will be a number
     * console.log(doc2?.$similarity);
     * ```
     *
     * @remarks
     * If you really need `limit` or `skip`, prefer using the {@link Collection.find} method instead.
     *
     * @param filter - A filter to select the document to find.
     * @param options - The options for this operation.
     *
     * @returns The found document, or `null` if no document was found.
     *
     * @see StrictFilter
     */
    async findOne(filter, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            findOne: {
                filter,
                options: {
                    includeSimilarity: options?.includeSimilarity,
                }
            },
        };
        if (options?.sort) {
            command.findOne.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        if (options?.projection && Object.keys(options.projection).length > 0) {
            command.findOne.projection = options.projection;
        }
        const resp = await this._httpClient.executeCommand(command, options);
        return resp.data?.document;
    }
    /**
     * Counts the number of documents in the collection, optionally with a filter.
     *
     * Takes in a `limit` option which dictates the maximum number of documents that may be present before a
     * {@link TooManyDocumentsToCountError} is thrown. If the limit is higher than the highest limit accepted by the
     * Data API, a {@link TooManyDocumentsToCountError} will be thrown anyway (i.e. `1000`).
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { _id: '1', name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * const count = await collection.countDocuments({ name: 'John Doe' }, 1000);
     * console.log(count); // 1
     *
     * // Will throw a TooManyDocumentsToCountError as it counts 1, but the limit is 0
     * const count = await collection.countDocuments({ name: 'John Doe' }, 0);
     * ```
     *
     * @remarks
     * Count operations are expensive: for this reason, the best practice is to provide a reasonable `upperBound`
     * according to the caller expectations. Moreover, indiscriminate usage of count operations for sizeable amounts
     * of documents (i.e. in the thousands and more) is discouraged in favor of alternative application-specific
     * solutions. Keep in mind that the Data API has a hard upper limit on the amount of documents it will count,
     * and that an exception will be thrown by this method if this limit is encountered.
     *
     * @param filter - A filter to select the documents to count. If not provided, all documents will be counted.
     * @param upperBound - The maximum number of documents to count.
     * @param options - The options for this operation.
     *
     * @returns The number of counted documents, if below the provided limit
     *
     * @throws TooManyDocumentsToCountError - If the number of documents counted exceeds the provided limit.
     *
     * @see StrictFilter
     */
    async countDocuments(filter, upperBound, options) {
        const command = {
            countDocuments: { filter },
        };
        if (!upperBound) {
            throw new Error('options.limit is required');
        }
        const resp = await this._httpClient.executeCommand(command, options);
        if (resp.status?.moreData) {
            throw new errors_1.TooManyDocumentsToCountError(resp.status.count, true);
        }
        if (resp.status?.count > upperBound) {
            throw new errors_1.TooManyDocumentsToCountError(upperBound, false);
        }
        return resp.status?.count;
    }
    /**
     * Gets an estimate of the count of documents in a collection.
     *
     * This operation is faster than {@link Collection.countDocuments} but may not be as accurate, and doesn't
     * accept a filter. Unlike the former, **It can handle more than 1000 documents.**
     *
     * @remarks
     * This gives a very rough estimate of the number of documents in the collection. It is not guaranteed to be
     * accurate, and should not be used as a source of truth for the number of documents in the collection.
     *
     * @param options - The options for this operation.
     *
     * @returns The estimated number of documents in the collection
     */
    async estimatedDocumentCount(options) {
        const command = {
            estimatedDocumentCount: {},
        };
        const resp = await this._httpClient.executeCommand(command, options);
        return resp.status?.count;
    }
    async findOneAndReplace(filter, replacement, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            findOneAndReplace: {
                filter,
                replacement,
                options: {
                    returnDocument: options.returnDocument,
                    upsert: options.upsert,
                },
            },
        };
        if (options?.sort) {
            command.findOneAndReplace.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        if (options?.projection && Object.keys(options.projection).length > 0) {
            command.findOneAndReplace.projection = options.projection;
        }
        const resp = await this._httpClient.executeCommand(command, options);
        const document = resp.data?.document || null;
        return (options.includeResultMetadata)
            ? {
                value: document,
                ok: 1,
            }
            : document;
    }
    async findOneAndDelete(filter, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            findOneAndDelete: { filter },
        };
        if (options?.sort) {
            command.findOneAndDelete.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        if (options?.projection && Object.keys(options.projection).length > 0) {
            command.findOneAndDelete.projection = options.projection;
        }
        const resp = await this._httpClient.executeCommand(command, options);
        const document = resp.data?.document || null;
        return (options?.includeResultMetadata)
            ? {
                value: document,
                ok: 1,
            }
            : document;
    }
    async findOneAndUpdate(filter, update, options) {
        options = coalesceVectorSpecialsIntoSort(options);
        const command = {
            findOneAndUpdate: {
                filter,
                update,
                options: {
                    returnDocument: options.returnDocument,
                    upsert: options.upsert,
                },
            },
        };
        if (options?.sort) {
            command.findOneAndUpdate.sort = (0, utils_1.normalizeSort)(options.sort);
        }
        if (options?.projection && Object.keys(options.projection).length > 0) {
            command.findOneAndUpdate.projection = options.projection;
        }
        const resp = await this._httpClient.executeCommand(command, options);
        const document = resp.data?.document || null;
        return (options.includeResultMetadata)
            ? {
                value: document,
                ok: 1,
            }
            : document;
    }
    /**
     * Execute arbitrary operations sequentially/concurrently on the collection, such as insertions, updates, replaces,
     * & deletions, **non-atomically**
     *
     * Each operation is treated as a separate, unrelated request to the server; it is not performed in a transaction.
     *
     * You can set the `ordered` option to `true` to stop the operations after the first error, otherwise all operations
     * may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
     *
     * *Note that the bulkWrite being ordered has nothing to do with if the operations themselves are ordered or not.*
     *
     * If an operational error occurs, the operation will throw a {@link BulkWriteError} containing the partial result.
     *
     * *If the exception is not due to a soft `2XX` error, e.g. a `5xx` error or network error, the operation will throw
     * the underlying error.*
     *
     * *In case of an unordered request, if the error was a simple operational error, a `BulkWriteError` will be thrown
     * after every operation has been attempted. If it was a `5xx` or similar, the error will be thrown immediately.*
     *
     * You can set the `parallel` option to control how many network requests are made in parallel on unordered
     * insertions. Defaults to `8`.
     *
     * @example
     * ```typescript
     * try {
     *   // Insert a document, then delete it
     *   await collection.bulkWrite([
     *     { insertOne: { document: { _id: '1', name: 'John Doe' } } },
     *     { deleteOne: { filter: { name: 'John Doe' } } },
     *   ]);
     *
     *   // Insert and delete operations, will cause a data race
     *   await collection.bulkWrite([
     *     { insertOne: { document: { _id: '1', name: 'John Doe' } } },
     *     { deleteOne: { filter: { name: 'John Doe' } } },
     *   ]);
     * } catch (e) {
     *   if (e instanceof BulkWriteError) {
     *     console.log(e.insertedCount);
     *     console.log(e.deletedCount);
     *   }
     * }
     * ```
     *
     * @param operations - The operations to perform.
     * @param options - The options for this operation.
     *
     * @returns The aggregated result of the operations.
     *
     * @throws BulkWriteError - If the operation fails
     */
    async bulkWrite(operations, options) {
        const timeoutManager = this._httpClient.timeoutManager(options?.maxTimeMS);
        return (options?.ordered)
            ? await bulkWriteOrdered(this._httpClient, operations, timeoutManager)
            : await bulkWriteUnordered(this._httpClient, operations, options?.concurrency ?? 8, timeoutManager);
    }
    /**
     * Get the collection options, i.e. its configuration as read from the database.
     *
     * The method issues a request to the Data API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```typescript
     * const options = await collection.info();
     * console.log(options.vector);
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The options that the collection was created with (i.e. the `vector` and `indexing` operations).
     */
    async options(options) {
        const results = await this._db.listCollections({ nameOnly: false, maxTimeMS: options?.maxTimeMS });
        const collection = results.find((c) => c.name === this.collectionName);
        if (!collection) {
            throw new errors_1.CollectionNotFoundError(this.namespace, this.collectionName);
        }
        return collection.options ?? {};
    }
    /**
     * Drops the collection from the database, including all the documents it contains.
     *
     * Once the collection is dropped, this object is still technically "usable", but any further operations on it
     * will fail at the Data API level; thus, it's the user's responsibility to make sure that the collection object
     * is no longer used.
     *
     * @example
     * ```typescript
     * const collection = await db.createCollection('my_collection');
     * await collection.drop();
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns `true` if the collection was dropped okay.
     *
     * @remarks Use with caution. Wear your safety goggles. Don't say I didn't warn you.
     */
    async drop(options) {
        return await this._db.dropCollection(this.collectionName, options);
    }
}
exports.Collection = Collection;
const coalesceVectorSpecialsIntoSort = (options) => {
    if (options?.vector && options?.vectorize) {
        throw new Error('Cannot set both vectors and vectorize options');
    }
    if (options?.vector) {
        if (options.sort) {
            throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object');
        }
        return { ...options, sort: { $vector: options.vector } };
    }
    if (options?.vectorize) {
        if (options.sort) {
            throw new Error('Can\'t use both `sort` and `vectorize` options at once; if you need both, include a $vectorize key in the sort object');
        }
        return { ...options, sort: { $vectorize: options.vectorize } };
    }
    return options;
};
// -- Insert Many ------------------------------------------------------------------------------------------
const insertManyOrdered = async (httpClient, documents, chunkSize, timeoutManager) => {
    const insertedIds = [];
    for (let i = 0, n = documents.length; i < n; i += chunkSize) {
        const slice = documents.slice(i, i + chunkSize);
        try {
            const inserted = await insertMany(httpClient, slice, true, timeoutManager);
            insertedIds.push(...inserted);
        }
        catch (e) {
            if (!(e instanceof errors_1.DataAPIResponseError)) {
                throw e;
            }
            const desc = e.detailedErrorDescriptors[0];
            insertedIds.push(...desc.rawResponse.status?.insertedIds ?? []);
            throw (0, errors_1.mkRespErrorFromResponse)(errors_1.InsertManyError, desc.command, desc.rawResponse, { insertedIds: insertedIds, insertedCount: insertedIds.length });
        }
    }
    return insertedIds;
};
const insertManyUnordered = async (httpClient, documents, concurrency, chunkSize, timeoutManager) => {
    const insertedIds = [];
    let masterIndex = 0;
    const failCommands = [];
    const failRaw = [];
    const workers = Array.from({ length: concurrency }, async () => {
        while (masterIndex < documents.length) {
            const localI = masterIndex;
            const endIdx = Math.min(localI + chunkSize, documents.length);
            masterIndex += chunkSize;
            if (localI >= endIdx) {
                break;
            }
            const slice = documents.slice(localI, endIdx);
            try {
                const inserted = await insertMany(httpClient, slice, false, timeoutManager);
                insertedIds.push(...inserted);
            }
            catch (e) {
                if (!(e instanceof errors_1.DataAPIResponseError)) {
                    throw e;
                }
                const desc = e.detailedErrorDescriptors[0];
                const justInserted = desc.rawResponse.status?.insertedIds ?? [];
                insertedIds.push(...justInserted);
                failCommands.push(desc.command);
                failRaw.push(desc.rawResponse);
            }
        }
    });
    await Promise.all(workers);
    if (failCommands.length > 0) {
        throw (0, errors_1.mkRespErrorFromResponses)(errors_1.InsertManyError, failCommands, failRaw, { insertedIds: insertedIds, insertedCount: insertedIds.length });
    }
    return insertedIds;
};
const insertMany = async (httpClient, documents, ordered, timeoutManager) => {
    const command = {
        insertMany: {
            documents,
            options: { ordered },
        }
    };
    const resp = await httpClient.executeCommand(command, { timeoutManager });
    return resp.status?.insertedIds ?? [];
};
// -- Bulk Write ------------------------------------------------------------------------------------------
const bulkWriteOrdered = async (httpClient, operations, timeoutManager) => {
    const results = new types_1.BulkWriteResult();
    let i = 0;
    try {
        for (let n = operations.length; i < n; i++) {
            await bulkWrite(httpClient, operations[i], results, i, timeoutManager);
        }
    }
    catch (e) {
        if (!(e instanceof errors_1.DataAPIResponseError)) {
            throw e;
        }
        const desc = e.detailedErrorDescriptors[0];
        if (desc.rawResponse.status) {
            addToBulkWriteResult(results, desc.rawResponse.status, i);
        }
        throw (0, errors_1.mkRespErrorFromResponse)(errors_1.BulkWriteError, desc.command, desc.rawResponse, results);
    }
    return results;
};
const bulkWriteUnordered = async (httpClient, operations, concurrency, timeoutManager) => {
    const results = new types_1.BulkWriteResult();
    let masterIndex = 0;
    const failCommands = [];
    const failRaw = [];
    const workers = Array.from({ length: concurrency }, async () => {
        while (masterIndex < operations.length) {
            const localI = masterIndex;
            masterIndex++;
            try {
                await bulkWrite(httpClient, operations[localI], results, localI, timeoutManager);
            }
            catch (e) {
                if (!(e instanceof errors_1.DataAPIResponseError)) {
                    throw e;
                }
                const desc = e.detailedErrorDescriptors[0];
                if (desc.rawResponse.status) {
                    addToBulkWriteResult(results, desc.rawResponse.status, localI);
                }
                failCommands.push(desc.command);
                failRaw.push(desc.rawResponse);
            }
        }
    });
    await Promise.all(workers);
    if (failCommands.length > 0) {
        throw (0, errors_1.mkRespErrorFromResponses)(errors_1.BulkWriteError, failCommands, failRaw, results);
    }
    return results;
};
const bulkWrite = async (httpClient, operation, results, i, timeoutManager) => {
    const command = buildBulkWriteCommand(operation);
    const resp = await httpClient.executeCommand(command, { timeoutManager });
    addToBulkWriteResult(results, resp.status, i);
};
const buildBulkWriteCommand = (operation) => {
    switch (true) {
        case 'insertOne' in operation:
            return { insertOne: { document: operation.insertOne.document } };
        case 'updateOne' in operation:
            return { updateOne: { filter: operation.updateOne.filter, update: operation.updateOne.update, options: { upsert: operation.updateOne.upsert ?? false } } };
        case 'updateMany' in operation:
            return { updateMany: { filter: operation.updateMany.filter, update: operation.updateMany.update, options: { upsert: operation.updateMany.upsert ?? false } } };
        case 'replaceOne' in operation:
            return { findOneAndReplace: { filter: operation.replaceOne.filter, replacement: operation.replaceOne.replacement, options: { upsert: operation.replaceOne.upsert ?? false } } };
        case 'deleteOne' in operation:
            return { deleteOne: { filter: operation.deleteOne.filter } };
        case 'deleteMany' in operation:
            return { deleteMany: { filter: operation.deleteMany.filter } };
        default:
            throw new Error(`Unknown bulk write operation: ${JSON.stringify(operation)}`);
    }
};
const addToBulkWriteResult = (result, resp, i) => {
    const asMutable = result;
    asMutable.insertedCount += resp.insertedIds?.length ?? 0;
    asMutable.modifiedCount += resp.modifiedCount ?? 0;
    asMutable.matchedCount += resp.matchedCount ?? 0;
    asMutable.deletedCount += resp.deletedCount ?? 0;
    if (resp.upsertedId) {
        asMutable.upsertedCount++;
        asMutable.upsertedIds[i] = resp.upsertedId;
    }
    asMutable.getRawResponse().push(resp);
};
// -- Distinct --------------------------------------------------------------------------------------------
const assertPathSafe4Distinct = (path) => {
    const split = path.split('.');
    if (split.some(p => !p)) {
        throw new Error('Path cannot contain empty segments');
    }
};
const pullSafeProjection4Distinct = (path) => {
    return (0, utils_1.takeWhile)(path.split('.'), p => isNaN(p)).join('.');
};
const mkDistinctPathExtractor = (path) => {
    const values = [];
    const extract = (path, index, value) => {
        if (value === undefined) {
            return;
        }
        if (index === path.length) {
            if (Array.isArray(value)) {
                values.push(...value);
            }
            else {
                values.push(value);
            }
            return;
        }
        const prop = path[index];
        if (Array.isArray(value)) {
            const asInt = parseInt(prop, 10);
            if (isNaN(asInt)) {
                for (let i = 0, n = value.length; i < n; i++) {
                    extract(path, index, value[i]);
                }
            }
            else if (asInt < value.length) {
                extract(path, index + 1, value[asInt]);
            }
        }
        else if (value && typeof value === 'object') {
            extract(path, index + 1, value[prop]);
        }
    };
    return (doc) => {
        extract(path.split('.'), 0, doc);
        return values;
    };
};
//# sourceMappingURL=collection.js.map