"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Db_defaultOpts;
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDbOpts = exports.mkDb = exports.Db = void 0;
const data_api_1 = require("../data-api");
const api_1 = require("../api");
const astra_db_admin_1 = require("../devops/astra-db-admin");
const utils_1 = require("../data-api/utils");
/**
 * Represents an interface to some Astra database instance. This is the entrypoint for database-level DML, such as
 * creating/deleting collections, connecting to collections, and executing arbitrary commands.
 *
 * **Shouldn't be instantiated directly; use {@link DataAPIClient.db} to obtain an instance of this class.**
 *
 * Note that creating an instance of a `Db` doesn't trigger actual database creation; the database must have already
 * existed beforehand. If you need to create a new database, use the {@link AstraAdmin} class.
 *
 * Db spawning methods let you pass in the default namespace for the database, which is used for all subsequent db
 * operations in that object, but each method lets you override the namespace if necessary in its options.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('AstraCS:...');
 *
 * // Connect to a database using a direct endpoint
 * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
 *
 * // Overrides default options from the DataAPIClient
 * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
 *   namespace: 'my_namespace',
 *   useHttp2: false,
 * });
 *
 * // Lets you connect using a database ID and region
 * const db3 = client.db('a6a1d8d6-31bc-4af8-be57-377566f345bf', 'us-east1');
 * ```
 *
 * @see DataAPIClient.db
 * @see AstraAdmin.db
 *
 * @public
 */
class Db {
    /**
     * Use {@link DataAPIClient.db} to obtain an instance of this class.
     *
     * @internal
     */
    constructor(endpoint, options) {
        _Db_defaultOpts.set(this, void 0);
        Object.defineProperty(this, "_httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The default namespace to use for all operations in this database, unless overridden in a method call.
         *
         * @example
         * ```typescript
         *
         * // Uses 'default_keyspace' as the default namespace for all future db spawns
         * const client1 = new DataAPIClient('*TOKEN*');
         *
         * // Overrides the default namespace for all future db spawns
         * const client2 = new DataAPIClient('*TOKEN*', {
         *   dbOptions: { namespace: 'my_namespace' }
         * });
         *
         * // Created with 'default_keyspace' as the default namespace
         * const db1 = client1.db('*ENDPOINT*');
         *
         * // Created with 'my_namespace' as the default namespace
         * const db2 = client1.db('*ENDPOINT*', {
         *   namespace: 'my_namespace'
         * });
         *
         * // Uses 'default_keyspace'
         * const coll1 = db1.collection('users');
         *
         * // Uses 'my_namespace'
         * const coll2 = db1.collection('users', {
         *   namespace: 'my_namespace'
         * });
         * ```
         */
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const dbOpts = options.dbOptions;
        Object.defineProperty(this, 'namespace', {
            value: dbOpts.namespace ?? api_1.DEFAULT_NAMESPACE,
            writable: false,
        });
        __classPrivateFieldSet(this, _Db_defaultOpts, options, "f");
        Object.defineProperty(this, '_httpClient', {
            value: new api_1.DataAPIHttpClient({
                baseUrl: endpoint,
                applicationToken: dbOpts.token,
                baseApiPath: dbOpts?.dataApiPath || api_1.DEFAULT_DATA_API_PATH,
                emitter: options.emitter,
                monitorCommands: dbOpts.monitorCommands,
                fetchCtx: options.fetchCtx,
                namespace: this.namespace,
            }),
            enumerable: false,
        });
        Object.defineProperty(this, '_id', {
            value: (0, utils_1.extractDbIdFromUrl)(endpoint),
            enumerable: false,
        });
    }
    /**
     * The ID of the database, if it's an Astra database. If it's not an Astra database, this will throw an error.
     *
     * @throws Error - if the database is not an Astra database.
     */
    get id() {
        if (!this._id) {
            throw new Error('Non-Astra databases do not have an appropriate ID');
        }
        return this._id;
    }
    /**
     * Spawns a new {@link AstraDbAdmin} instance for this database, used for performing administrative operations
     * on the database, such as managing namespaces, or getting database information.
     *
     * **NB. Only available for Astra databases.**
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin1 = db.admin();
     * const admin2 = db.admin({ adminToken: '<stronger-token>' });
     *
     * const namespaces = await admin1.listNamespaces();
     * console.log(namespaces);
     * ```
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraDbAdmin} instance for this database instance.
     *
     * @throws Error - if the database is not an Astra database.
     */
    admin(options) {
        if (!this._id) {
            throw new Error('Admin operations are only supported on Astra databases');
        }
        return (0, astra_db_admin_1.mkDbAdmin)(this, __classPrivateFieldGet(this, _Db_defaultOpts, "f"), options);
    }
    /**
     * Fetches information about the database, such as the database name, region, and other metadata.
     *
     * **NB. Only available for Astra databases.**
     *
     * For the full, complete, information, see {@link AstraDbAdmin.info}.
     *
     * The method issues a request to the DevOps API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```typescript
     * const info = await db.info();
     * console.log(info.name);
     * ```
     *
     * @returns A promise that resolves to the database information.
     *
     * @throws Error - if the database is not an Astra database.
     */
    async info(options) {
        return await this.admin().info(options).then(i => i.info);
    }
    /**
     * Establishes a reference to a collection in the database. This method does not perform any I/O.
     *
     * **NB. This method does not validate the existence of the collection—it simply creates a reference.**
     *
     * **Unlike the MongoDB driver, this method does not create a collection if it doesn't exist.**
     *
     * Use {@link Db.createCollection} to create a new collection instead.
     *
     * Typed as `Collection<SomeDoc>` by default, but you can specify a schema type to get a typed collection. If left
     * as `SomeDoc`, the collection will be untyped.
     *
     * You can also specify a namespace in the options parameter, which will override the default namespace for this database.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string,
     *   age?: number,
     * }
     *
     * const users1 = db.collection<User>("users");
     * users1.insertOne({ name: "John" });
     *
     * // Untyped collection from different namespace
     * const users2 = db.collection("users", {
     *   namespace: "my_namespace"
     * });
     * users2.insertOne({ nam3: "John" });
     * ```
     *
     * @param name - The name of the collection.
     * @param options - Options for the connection.
     *
     * @returns A new, unvalidated, reference to the collection.
     *
     * @see SomeDoc
     * @see VectorDoc
     */
    collection(name, options) {
        return new data_api_1.Collection(this, this._httpClient, name, options?.namespace);
    }
    /**
     * Establishes references to all the collections in the working/given namespace.
     *
     * You can specify a namespace in the options parameter, which will override the default namespace for this `Db` instance.
     *
     * @example
     * ```typescript
     * // Uses db's default namespace
     * const collections1 = await db.collections();
     * console.log(collections1); // [Collection<SomeDoc>, Collection<SomeDoc>]
     *
     * // Overrides db's default namespace
     * const collections2 = await db.collections({ namespace: 'my_namespace' });
     * console.log(collections2); // [Collection<SomeDoc>]
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of references to the working Db's collections.
     */
    async collections(options) {
        const collections = await this.listCollections({
            namespace: options?.namespace,
            maxTimeMS: options?.maxTimeMS,
            nameOnly: true,
        });
        return collections.map(c => this.collection(c, options));
    }
    /**
     * Creates a new collection in the database, and establishes a reference to it.
     *
     * **NB. You are limited in the amount of collections you can create, so be wary when using this command.**
     *
     * This is a blocking command which performs actual I/O unlike {@link Db.collection}, which simply creates an
     * unvalidated reference to a collection.
     *
     * If `checkExists: false`, creation is idempotent, so if the collection already exists with the same options,
     * this method will not throw an error. If the options mismatch, it will throw a {@link DataAPIResponseError}.
     *
     * Typed as `Collection<SomeDoc>` by default, but you can specify a schema type to get a typed collection. If left
     * as `SomeDoc`, the collection will be untyped.
     *
     * *If vector options are not specified, the collection will not support vector search.*
     *
     * You can also specify a namespace in the options parameter, which will override the default namespace for this database.
     *
     * See {@link CreateCollectionOptions} for *much* more information on the options available.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string,
     *   age?: number,
     * }
     *
     * const users = await db.createCollection<User>("users");
     * users.insertOne({ name: "John" });
     *
     * // Untyped collection with custom options in a different namespace
     * const users2 = await db.createCollection("users", {
     *   namespace: "my_namespace",
     *   defaultId: {
     *     type: "objectId",
     *   },
     *   checkExists: false,
     * });
     * ```
     *
     * @param collectionName - The name of the collection to create.
     * @param options - Options for the collection.
     *
     * @returns A promised reference to the newly created collection.
     *
     * @throws CollectionAlreadyExistsError - if the collection already exists and `checkExists` is `true` or unset.
     *
     * @see SomeDoc
     * @see VectorDoc
     */
    async createCollection(collectionName, options) {
        const command = {
            createCollection: {
                name: collectionName,
                options: {
                    defaultId: options?.defaultId,
                    indexing: options?.indexing,
                    vector: options?.vector,
                },
            },
        };
        const timeoutManager = this._httpClient.timeoutManager(options?.maxTimeMS);
        const namespace = options?.namespace ?? this.namespace;
        if (options?.checkExists !== false) {
            const collections = await this.listCollections({ namespace, maxTimeMS: timeoutManager.msRemaining });
            if (collections.some(c => c.name === collectionName)) {
                throw new data_api_1.CollectionAlreadyExistsError(options?.namespace ?? this.namespace, collectionName);
            }
        }
        await this._httpClient.executeCommand(command, { namespace, timeoutManager });
        return this.collection(collectionName, options);
    }
    /**
     * Drops a collection from the database, including all the contained documents.
     *
     * You can also specify a namespace in the options parameter, which will override the default namespace for this database.
     *
     * @example
     * ```typescript
     * // Uses db's default namespace
     * const success1 = await db.dropCollection("users");
     * console.log(success1); // true
     *
     * // Overrides db's default namespace
     * const success2 = await db.dropCollection("users", {
     *   namespace: "my_namespace"
     * });
     * console.log(success2); // true
     * ```
     *
     * @param name - The name of the collection to drop.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to `true` if the collection was dropped successfully.
     *
     * @remarks Use with caution. Have steel-toe boots on. Don't say I didn't warn you.
     */
    async dropCollection(name, options) {
        const command = {
            deleteCollection: { name },
        };
        const resp = await this._httpClient.executeCommand(command, options);
        return resp.status?.ok === 1 && !resp.errors;
    }
    async listCollections(options) {
        const command = {
            findCollections: {
                options: {
                    // Is 'nameOnly' instead of 'explain' for Mongo-compatibility reasons
                    explain: options?.nameOnly !== true,
                },
            },
        };
        const resp = await this._httpClient.executeCommand(command, options);
        return resp.status.collections;
    }
    /**
     * Send a POST request to the Data API for this database with an arbitrary, caller-provided payload.
     *
     * You can specify a collection to target in the options parameter, thereby allowing you to perform
     * arbitrary collection-level operations as well.
     *
     * You're also able to specify a namespace in the options parameter, which will override the default namespace
     * for this database.
     *
     * If no collection is specified, the command will be executed at the database level.
     *
     * @example
     * ```typescript
     * const colls = await db.command({ findCollections: {} });
     * console.log(colls); // { status: { collections: [] } }
     *
     * const users = await db.command({ findOne: {} }, { collection: 'users' });
     * console.log(users); // { data: { document: null } }
     * ```
     *
     * @param command - The command to send to the Data API.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to the raw response from the Data API.
     */
    async command(command, options) {
        return await this._httpClient.executeCommand(command, options);
    }
}
exports.Db = Db;
_Db_defaultOpts = new WeakMap();
/**
 * @internal
 */
function mkDb(rootOpts, endpointOrId, regionOrOptions, maybeOptions) {
    const options = (typeof regionOrOptions === 'string')
        ? maybeOptions
        : regionOrOptions;
    validateDbOpts(options);
    const endpoint = (typeof regionOrOptions === 'string')
        ? 'https://' + endpointOrId + '-' + regionOrOptions + '.apps.astra.datastax.com'
        : endpointOrId;
    return new Db(endpoint, {
        ...rootOpts,
        dbOptions: {
            ...rootOpts?.dbOptions,
            ...options,
        },
    });
}
exports.mkDb = mkDb;
/**
 * @internal
 */
function validateDbOpts(opts) {
    (0, utils_1.validateOption)('db options', opts, 'object');
    if (!opts) {
        return;
    }
    (0, utils_1.validateOption)('namespace option', opts.namespace, 'string', (namespace) => {
        if (!namespace.match(/^\w{1,48}$/)) {
            throw new Error('Invalid namespace option; expected a string of 1-48 alphanumeric characters');
        }
    });
    (0, utils_1.validateOption)('monitorCommands option', opts.monitorCommands, 'boolean');
    (0, utils_1.validateOption)('token option', opts.token, 'string');
    (0, utils_1.validateOption)('dataApiPath option', opts.dataApiPath, 'string');
}
exports.validateDbOpts = validateDbOpts;
//# sourceMappingURL=db.js.map