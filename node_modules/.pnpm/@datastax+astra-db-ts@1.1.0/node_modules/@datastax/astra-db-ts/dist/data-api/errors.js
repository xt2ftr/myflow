"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkRespErrorFromResponses = exports.mkRespErrorFromResponse = exports.BulkWriteError = exports.UpdateManyError = exports.DeleteManyError = exports.InsertManyError = exports.CumulativeDataAPIError = exports.DataAPIResponseError = exports.CollectionAlreadyExistsError = exports.CollectionNotFoundError = exports.CursorIsStartedError = exports.TooManyDocumentsToCountError = exports.DataAPITimeoutError = exports.DataAPIHttpError = exports.DataAPIError = void 0;
const utils_1 = require("../api/utils");
/**
 * An abstract class representing *some* exception that occurred related to the Data API. This is the base class for all
 * Data API errors, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * This is *only* for Data API related errors, such as a non-existent collection, or a duplicate key error. It
 * is *not*, however, for errors such as an HTTP network error, or a malformed request. The exception being timeouts,
 * which are represented by the {@link DataAPITimeoutError} class.
 *
 * @public
 */
class DataAPIError extends Error {
}
exports.DataAPIError = DataAPIError;
/**
 * An error thrown on non-2XX status codes from the Data API, such as 4XX or 5XX errors.
 */
class DataAPIHttpError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(resp) {
        super(`HTTP error: ${resp.status}`);
        /**
         * The error descriptors returned by the API to describe what went wrong.
         */
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The HTTP status code of the response, if available.
         */
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The "raw", errored response from the API.
         */
        Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.status = resp.status;
        this.body = resp.body;
        this.raw = (0, utils_1.toCuratedApiResponse)(resp);
        this.name = 'DataAPIHttpError';
    }
}
exports.DataAPIHttpError = DataAPIHttpError;
/**
 * An error thrown when a Data API operation timed out.
 *
 * Depending on the method, this may be a request timeout occurring during a specific HTTP request, or can happen over
 * the course of a method involving several requests in a row, such as a paginated `insertMany`.
 *
 * @public
 */
class DataAPITimeoutError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(timeout) {
        super(`Command timed out after ${timeout}ms`);
        /**
         * The timeout that was set for the operation, in milliseconds.
         */
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.timeout = timeout;
        this.name = 'DataAPITimeoutError';
    }
}
exports.DataAPITimeoutError = DataAPITimeoutError;
/**
 * Caused by a `countDocuments` operation that failed because the resulting number of documents exceeded *either*
 * the upper bound set by the caller, or the hard limit imposed by the Data API.
 *
 * @example
 * ```typescript
 * await collection.insertMany('<100_length_array>');
 *
 * try {
 *   await collection.countDocuments({}, 50);
 * } catch (e) {
 *   if (e instanceof TooManyDocumentsToCountError) {
 *     console.log(e.limit); // 50
 *     console.log(e.hitServerLimit); // false
 *   }
 * }
 * ```
 *
 * @field limit - The limit that was set by the caller
 * @field hitServerLimit - Whether the server-imposed limit was hit
 *
 * @public
 */
class TooManyDocumentsToCountError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(limit, hitServerLimit) {
        const message = (hitServerLimit)
            ? `Too many documents to count (server limit of ${limit} reached)`
            : `Too many documents to count (provided limit is ${limit})`;
        super(message);
        /**
         * The limit that was specified by the caller, or the server-imposed limit if the caller's limit was too high.
         */
        Object.defineProperty(this, "limit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Specifies if the server-imposed limit was hit. If this is `true`, the `limit` field will contain the server's
         * limit; otherwise it will contain the caller's limit.
         */
        Object.defineProperty(this, "hitServerLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.limit = limit;
        this.hitServerLimit = hitServerLimit;
        this.name = 'TooManyDocumentsToCountError';
    }
}
exports.TooManyDocumentsToCountError = TooManyDocumentsToCountError;
/**
 * Caused by trying to perform an operation on an already-initialized {@link FindCursor} that requires it to be
 * uninitialized.
 *
 * If you run into this error, and you really do need to change an option on the cursor, you can rewind the cursor
 * using {@link FindCursor.rewind}, or clone it using {@link FindCursor.clone}.
 *
 * @example
 * ```typescript
 * await collection.find({}).toArray();
 *
 * try {
 *   await cursor.limit(10);
 * } catch (e) {
 *   if (e instanceof CursorAlreadyInitializedError) {
 *     console.log(e.message); // "Cursor is already initialized..."
 *   }
 * }
 * ```
 *
 * @public
 */
class CursorIsStartedError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(message) {
        super(message);
        this.name = 'CursorAlreadyInitializedError';
    }
}
exports.CursorIsStartedError = CursorIsStartedError;
/**
 * An exception thrown when certain operations are attempted on a collection that does not exist.
 *
 * @field namespace - The namespace that the collection was not found in
 * @field collectionName - The name of the collection that was not found
 *
 * @public
 */
class CollectionNotFoundError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(namespace, collectionName) {
        super(`Collection '${namespace}.${collectionName}' not found`);
        /**
         * The namespace where the collection already exists
         */
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The name of the collection that already exists
         */
        Object.defineProperty(this, "collectionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.namespace = namespace;
        this.collectionName = collectionName;
        this.name = 'CollectionNotFoundError';
    }
}
exports.CollectionNotFoundError = CollectionNotFoundError;
/**
 * An exception thrown when an operation that expects a collection not to exist is attempted on a collection that
 * already exists.
 *
 * @field namespace - The namespace where the collection already exists
 * @field collectionName - The name of the collection that already exists
 *
 * @public
 */
class CollectionAlreadyExistsError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(namespace, collectionName) {
        super(`Collection '${namespace}.${collectionName}' already exists`);
        /**
         * The namespace where the collection already exists
         */
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The name of the collection that already exists
         */
        Object.defineProperty(this, "collectionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.namespace = namespace;
        this.collectionName = collectionName;
        this.name = 'CollectionAlreadyExistsError';
    }
}
exports.CollectionAlreadyExistsError = CollectionAlreadyExistsError;
/**
 * An error representing the *complete* errors for an operation. This is a cohesive error that represents all the
 * errors that occurred during a single operation, and should not be thought of as *always* 1:1 with the number of
 * API requests—rather it's 1:1 with the number of *logical* operations performed by the user (i.e. the methods
 * on the {@link Collection} class).
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 *
 * @public
 */
class DataAPIResponseError extends DataAPIError {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(message, errorDescriptors, detailedErrorDescriptors) {
        super(message);
        /**
         * A human-readable message describing the *first* error.
         *
         * This is *always* equal to `errorDescriptors[0]?.message` if it exists, otherwise it's given a generic
         * default message.
         */
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A list of error descriptors representing the individual errors returned by the API.
         *
         * This is *always* equal to `detailedErrorDescriptors.flatMap(d => d.errorDescriptors)`, for the user's
         * convenience.
         */
        Object.defineProperty(this, "errorDescriptors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A list of errors 1:1 with the number of errorful API requests made to the server. Each element contains the
         * original command, the raw response, and the error descriptors for that request.
         *
         * For operations that only make one request, this will be a singleton list (i.e. `insertOne`).
         */
        Object.defineProperty(this, "detailedErrorDescriptors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.message = message;
        this.errorDescriptors = errorDescriptors;
        this.detailedErrorDescriptors = detailedErrorDescriptors;
        this.name = 'DataAPIResponseError';
    }
}
exports.DataAPIResponseError = DataAPIResponseError;
/**
 * An abstract class representing an exception that occurred due to a *cumulative* operation on the Data API. This is
 * the base class for all Data API errors that represent a paginated operation, such as `insertMany`, `deleteMany`,
 * `updateMany`, and `bulkWrite`, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * This is *only* for Data API related errors, such as a non-existent collection, or a duplicate key error. It
 * is *not*, however, for errors such as an HTTP network error, or a malformed request. The exception being timeouts,
 * which are represented by the {@link DataAPITimeoutError} class.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the operation that was performed
 *
 * @public
 */
class CumulativeDataAPIError extends DataAPIResponseError {
    constructor() {
        super(...arguments);
        /**
         * The partial result of the operation that was performed. This is *always* defined, and is
         * the result of the operation up to the point of the first error. For example, if you're inserting 100 documents
         * ordered and the 50th document fails, the `partialResult` will contain the first 49 documents that were
         * successfully inserted.
         */
        Object.defineProperty(this, "partialResult", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.CumulativeDataAPIError = CumulativeDataAPIError;
/**
 * Represents an error that occurred during an `insertMany` operation (which is, generally, paginated).
 *
 * Contains the inserted IDs of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `InsertMany` operation that was performed
 *
 * @public
 */
class InsertManyError extends CumulativeDataAPIError {
    constructor() {
        super(...arguments);
        /**
         * The name of the error. This is always 'InsertManyError'.
         */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InsertManyError'
        });
    }
}
exports.InsertManyError = InsertManyError;
/**
 * Represents an error that occurred during a `deleteMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully deleted, as well as the cumulative errors that occurred
 * during the operation.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `DeleteMany` operation that was performed
 *
 * @public
 */
class DeleteManyError extends CumulativeDataAPIError {
    constructor() {
        super(...arguments);
        /**
         * The name of the error. This is always 'DeleteManyError'.
         */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DeleteManyError'
        });
    }
}
exports.DeleteManyError = DeleteManyError;
/**
 * Represents an error that occurred during an `updateMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully matched and/or modified, as well as the cumulative errors
 * that occurred during the operation.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `UpdateMany` operation that was performed
 *
 * @public
 */
class UpdateManyError extends CumulativeDataAPIError {
    constructor() {
        super(...arguments);
        /**
         * The name of the error. This is always 'UpdateManyError'.
         */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UpdateManyError'
        });
    }
}
exports.UpdateManyError = UpdateManyError;
/**
 * Represents an error that occurred during a `bulkWrite` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully inserted, updated, deleted, etc., as well as the cumulative
 * errors that occurred during the operation.
 *
 * If the operation was ordered, the results will be in the same order as the operations that were attempted to be
 * performed.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `BulkWrite` operation that was performed
 *
 * @public
 */
class BulkWriteError extends CumulativeDataAPIError {
    constructor() {
        super(...arguments);
        /**
         * The name of the error. This is always 'BulkWriteError'.
         */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BulkWriteError'
        });
    }
}
exports.BulkWriteError = BulkWriteError;
/**
 * @internal
 */
const mkRespErrorFromResponse = (err, command, raw, partialResult) => {
    return (0, exports.mkRespErrorFromResponses)(err, [command], [raw], partialResult);
};
exports.mkRespErrorFromResponse = mkRespErrorFromResponse;
/**
 * @internal
 */
const mkRespErrorFromResponses = (err, commands, raw, partialResult) => {
    const detailedDescriptors = [];
    for (let i = 0, n = commands.length; i < n; i++) {
        const command = commands[i], response = raw[i];
        if (response.errors) {
            const descriptors = response.errors.map((error) => {
                const attributes = { ...error };
                delete attributes.message;
                delete attributes.errorCode;
                return { errorCode: error.errorCode, message: error.message, attributes };
            });
            const detailedDescriptor = { errorDescriptors: descriptors, command, rawResponse: response };
            detailedDescriptors.push(detailedDescriptor);
        }
    }
    const errorDescriptors = detailedDescriptors.flatMap(d => d.errorDescriptors);
    const message = errorDescriptors[0]?.message || 'Something unexpected occurred';
    const instance = new err(message, errorDescriptors, detailedDescriptors);
    if (partialResult) {
        // @ts-expect-error - If the lord wants a partialResult, the lord will get a partialResult.
        instance.partialResult = partialResult;
    }
    return instance;
};
exports.mkRespErrorFromResponses = mkRespErrorFromResponses;
//# sourceMappingURL=errors.js.map