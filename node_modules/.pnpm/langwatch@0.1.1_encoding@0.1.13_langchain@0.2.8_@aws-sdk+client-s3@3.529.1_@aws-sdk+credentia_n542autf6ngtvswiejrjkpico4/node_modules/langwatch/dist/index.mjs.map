{"version":3,"sources":["../src/index.ts","../src/typeUtils.ts","../src/langchain.ts"],"sourcesContent":["import EventEmitter from \"events\";\nimport { nanoid } from \"nanoid\";\nimport { ZodError } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { camelToSnakeCaseNested, type Strict } from \"./typeUtils\";\nimport {\n  type CollectorRESTParams,\n  type Span as ServerSpan,\n  type SpanTypes,\n} from \"./server/types/tracer\";\nimport {\n  collectorRESTParamsSchema,\n  spanSchema,\n} from \"./server/types/tracer.generated\";\nimport {\n  type BaseSpan,\n  type ChatMessage,\n  type ChatRichContent,\n  type LLMSpan,\n  type Metadata,\n  type PendingBaseSpan,\n  type PendingLLMSpan,\n  type PendingRAGSpan,\n  type RAGSpan,\n  type SpanInputOutput,\n} from \"./types\";\nimport { autoconvertTypedValues, captureError, convertFromVercelAIMessages } from \"./utils\";\nimport { LangWatchCallbackHandler } from \"./langchain\";\n\nexport type {\n  BaseSpan,\n  ChatMessage as ChatMessage,\n  ChatRichContent,\n  LLMSpan,\n  Metadata,\n  PendingBaseSpan,\n  PendingLLMSpan,\n  PendingRAGSpan,\n  RAGSpan,\n  SpanInputOutput,\n};\n\nexport { convertFromVercelAIMessages, captureError, autoconvertTypedValues };\n\nexport class LangWatch extends EventEmitter {\n  apiKey: string | undefined;\n  endpoint: string;\n\n  constructor({\n    apiKey,\n    endpoint = process.env.LANGWATCH_ENDPOINT ?? \"https://app.langwatch.ai\",\n  }: {\n    apiKey?: string;\n    endpoint?: string;\n  } = {}) {\n    super();\n    const apiKey_ = apiKey ?? process.env.LANGWATCH_API_KEY;\n    if (!apiKey_) {\n      const error = new Error(\n        \"LangWatch API key is not set, please set the LANGWATCH_API_KEY environment variable or pass it in the constructor. Traces will not be captured.\"\n      );\n      this.emit(\"error\", error);\n    }\n    this.apiKey = apiKey_;\n    this.endpoint = endpoint;\n  }\n\n  getTrace({\n    traceId,\n    metadata,\n  }: { traceId?: string; metadata?: Metadata } = {}) {\n    return new LangWatchTrace({\n      client: this,\n      traceId: traceId ?? `trace_${nanoid()}`,\n      metadata,\n    });\n  }\n\n  async sendTrace(params: CollectorRESTParams) {\n    const backoff = [1000, 2000, 4000, 8000, 16000];\n    for (const backoffTime of backoff) {\n      try {\n        await this._sendTrace(params);\n        return;\n      } catch (e) {\n        console.warn(\n          `[LangWatch] ⚠️ Failed to send trace, retrying in ${\n            backoffTime / 1000\n          }s`\n        );\n        await new Promise((resolve) => setTimeout(resolve, backoffTime));\n      }\n    }\n    console.warn(\"[LangWatch] ⚠️ Failed to send trace, giving up\");\n  }\n\n  async _sendTrace(params: CollectorRESTParams) {\n    if (params.spans.length === 0) {\n      return;\n    }\n\n    if (!this.apiKey) {\n      const error = new Error(\n        \"LangWatch API key is not set, LLMs traces will not be sent, go to https://langwatch.ai to set it up\"\n      );\n      this.emit(\"error\", error);\n      return;\n    }\n\n    const response = await fetch(`${this.endpoint}/api/collector`, {\n      method: \"POST\",\n      headers: {\n        \"X-Auth-Token\": this.apiKey,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(params),\n    });\n\n    if (response.status === 429) {\n      const error = new Error(\n        \"Rate limit exceeded, dropping message from being sent to LangWatch. Please check your dashboard to upgrade your plan.\"\n      );\n      this.emit(\"error\", error);\n      return;\n    }\n    if (!response.ok) {\n      const error = new Error(\n        `Failed to send trace, status: ${response.status}`\n      );\n      this.emit(\"error\", error);\n      throw error;\n    }\n  }\n}\n\nexport class LangWatchTrace {\n  client: LangWatch;\n  traceId: string;\n  metadata?: Metadata;\n  finishedSpans: Record<string, ServerSpan> = {};\n  timeoutRef?: NodeJS.Timeout;\n  langchainCallback?: LangWatchCallbackHandler;\n\n  constructor({\n    client,\n    traceId,\n    metadata,\n  }: {\n    client: LangWatch;\n    traceId: string;\n    metadata?: Metadata;\n  }) {\n    this.client = client;\n    this.traceId = traceId;\n    this.metadata = metadata;\n  }\n\n  update({ metadata }: { metadata: Metadata }) {\n    this.metadata = {\n      ...this.metadata,\n      ...metadata,\n      ...(typeof metadata.labels !== \"undefined\"\n        ? { labels: [...(this.metadata?.labels ?? []), ...metadata.labels] }\n        : {}),\n    };\n  }\n\n  startSpan(params: Omit<Partial<PendingBaseSpan>, \"parentId\">) {\n    const span = new LangWatchSpan({\n      trace: this,\n      ...params,\n    });\n    return span;\n  }\n\n  startLLMSpan(params: Omit<Partial<PendingLLMSpan>, \"parentId\">) {\n    const span = new LangWatchLLMSpan({\n      trace: this,\n      ...params,\n    });\n    return span;\n  }\n\n  startRAGSpan(params: Omit<Partial<PendingRAGSpan>, \"parentId\">) {\n    const span = new LangWatchRAGSpan({\n      trace: this,\n      ...params,\n    });\n    return span;\n  }\n\n  getLangChainCallback() {\n    if (!this.langchainCallback) {\n      this.langchainCallback = new LangWatchCallbackHandler({ trace: this });\n    }\n    return this.langchainCallback;\n  }\n\n  onEnd(span: ServerSpan) {\n    this.finishedSpans[span.span_id] = span;\n    this.delayedSendSpans();\n  }\n\n  delayedSendSpans() {\n    clearTimeout(this.timeoutRef);\n    this.timeoutRef = setTimeout(() => {\n      void this.sendSpans();\n    }, 1000);\n  }\n\n  async sendSpans() {\n    clearTimeout(this.timeoutRef);\n\n    let trace: CollectorRESTParams | undefined = undefined;\n    try {\n      trace = collectorRESTParamsSchema.parse({\n        trace_id: this.traceId,\n        metadata: camelToSnakeCaseNested(this.metadata),\n        spans: Object.values(this.finishedSpans),\n      } as Strict<CollectorRESTParams>);\n    } catch (error) {\n      if (error instanceof ZodError) {\n        console.warn(\"[LangWatch] ⚠️ Failed to parse trace\");\n        console.warn(fromZodError(error).message);\n      }\n      this.client.emit(\"error\", error);\n    }\n\n    if (trace) {\n      await this.client.sendTrace(trace);\n    }\n  }\n}\n\nexport class LangWatchSpan implements PendingBaseSpan {\n  trace: LangWatchTrace;\n\n  spanId: string;\n  parentId?: string | null;\n  type: SpanTypes;\n  name?: string | null;\n  input?: PendingBaseSpan[\"input\"];\n  output?: PendingBaseSpan[\"output\"];\n  error?: PendingBaseSpan[\"error\"];\n  timestamps: PendingBaseSpan[\"timestamps\"];\n  metrics: PendingBaseSpan[\"metrics\"];\n\n  constructor({\n    trace,\n    spanId,\n    parentId,\n    type,\n    name,\n    input,\n    output,\n    error,\n    timestamps,\n    metrics,\n  }: Partial<PendingBaseSpan> & { trace: LangWatchTrace }) {\n    this.spanId = spanId ?? `span_${nanoid()}`;\n    this.parentId = parentId;\n    this.trace = trace;\n    this.type = type ?? \"span\";\n    this.name = name;\n    this.input = input;\n    this.output = output;\n    this.error = error;\n    this.timestamps = timestamps ?? {\n      startedAt: Date.now(),\n    };\n    this.metrics = metrics;\n  }\n\n  update(params: Partial<Omit<PendingBaseSpan, \"spanId\" | \"parentId\">>) {\n    if (Object.isFrozen(this)) {\n      const error = new Error(\n        `Tried to update span ${this.spanId}, but the span is already finished, discarding update`\n      );\n      this.trace.client.emit(\"error\", error);\n      return;\n    }\n\n    if (params.type) {\n      this.type = params.type;\n    }\n    if (\"name\" in params) {\n      this.name = params.name;\n    }\n    if (\"input\" in params) {\n      this.input = params.input;\n    }\n    if (\"output\" in params) {\n      this.output = params.output;\n    }\n    if (\"error\" in params) {\n      this.error = params.error;\n    }\n    if (params.timestamps) {\n      this.timestamps = params.timestamps;\n    }\n    if (\"metrics\" in params) {\n      this.metrics = params.metrics;\n    }\n  }\n\n  startSpan(params: Omit<Partial<PendingBaseSpan>, \"parentId\">) {\n    const span = new LangWatchSpan({\n      trace: this.trace,\n      parentId: this.spanId,\n      ...params,\n    });\n    return span;\n  }\n\n  startLLMSpan(params: Omit<Partial<PendingLLMSpan>, \"parentId\">) {\n    const span = new LangWatchLLMSpan({\n      trace: this.trace,\n      parentId: this.spanId,\n      ...params,\n    });\n    return span;\n  }\n\n  startRAGSpan(params: Omit<Partial<PendingRAGSpan>, \"parentId\">) {\n    const span = new LangWatchRAGSpan({\n      trace: this.trace,\n      parentId: this.spanId,\n      ...params,\n    });\n    return span;\n  }\n\n  end(params?: Partial<Omit<PendingBaseSpan, \"spanId\" | \"parentId\">>) {\n    this.timestamps.finishedAt = Date.now();\n    if (params) {\n      this.update(params);\n    }\n\n    Object.freeze(this);\n\n    try {\n      const finalSpan = spanSchema.parse(\n        camelToSnakeCaseNested({\n          ...this,\n          trace: undefined,\n          traceId: this.trace.traceId,\n          timestamps: {\n            ...this.timestamps,\n            finishedAt: this.timestamps.finishedAt,\n          },\n          ...(this.error && { error: captureError(this.error) }),\n        }) as ServerSpan\n      );\n      this.trace.onEnd(finalSpan);\n    } catch (error) {\n      if (error instanceof ZodError) {\n        console.warn(\"[LangWatch] ⚠️ Failed to parse span\");\n        console.warn(fromZodError(error).message);\n      }\n      this.trace.client.emit(\"error\", error);\n    }\n  }\n}\n\nexport class LangWatchLLMSpan extends LangWatchSpan implements PendingLLMSpan {\n  type: \"llm\";\n  model: PendingLLMSpan[\"model\"];\n  params: PendingLLMSpan[\"params\"];\n\n  constructor(params: Partial<PendingLLMSpan> & { trace: LangWatchTrace }) {\n    super({ ...params });\n    this.type = \"llm\";\n    this.model = params.model ?? \"unknown\";\n    this.params = params.params ?? {};\n  }\n\n  update(params: Partial<PendingLLMSpan>) {\n    super.update(params);\n    if (params.model) {\n      this.model = params.model;\n    }\n    if (params.params) {\n      this.params = params.params;\n    }\n  }\n\n  end(params?: Partial<PendingLLMSpan>) {\n    super.end(params);\n  }\n}\n\nexport class LangWatchRAGSpan extends LangWatchSpan implements PendingRAGSpan {\n  type: \"rag\";\n  contexts: PendingRAGSpan[\"contexts\"];\n\n  constructor(params: Partial<PendingRAGSpan> & { trace: LangWatchTrace }) {\n    super({ ...params });\n    this.type = \"rag\";\n    this.contexts = params.contexts ?? [];\n  }\n\n  update(params: Partial<PendingRAGSpan>) {\n    super.update(params);\n    if (params.contexts) {\n      this.contexts = params.contexts;\n    }\n  }\n\n  end(params?: Partial<PendingRAGSpan>) {\n    super.end(params);\n  }\n}\n","export type Strict<T> = T & { [K in Exclude<keyof any, keyof T>]: never };\n\ntype SnakeToCamelCase<S extends string> = S extends `${infer T}_${infer U}`\n  ? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n  : S;\n\nexport type SnakeToCamelCaseNested<T> = T extends object\n  ? T extends (infer U)[]\n    ? U extends object\n      ? {\n          [K in keyof U as SnakeToCamelCase<\n            K & string\n          >]: SnakeToCamelCaseNested<U[K]>;\n        }[]\n      : T\n    : {\n        [K in keyof T as SnakeToCamelCase<K & string>]: SnakeToCamelCaseNested<\n          T[K]\n        >;\n      }\n  : T;\n\ntype CamelToSnakeCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? \"_\" : \"\"}${Lowercase<T>}${CamelToSnakeCase<U>}`\n  : S;\n\nexport type CamelToSnakeCaseNested<T> = T extends object\n  ? T extends (infer U)[]\n    ? U extends object\n      ? {\n          [K in keyof U as CamelToSnakeCase<\n            K & string\n          >]: CamelToSnakeCaseNested<U[K]>;\n        }[]\n      : T\n    : {\n        [K in keyof T as CamelToSnakeCase<K & string>]: CamelToSnakeCaseNested<\n          T[K]\n        >;\n      }\n  : T;\n\nfunction camelToSnakeCase(str: string): string {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\nexport function camelToSnakeCaseNested<T>(obj: T): CamelToSnakeCaseNested<T> {\n  if (Array.isArray(obj)) {\n    return obj.map((item) =>\n      camelToSnakeCaseNested(item)\n    ) as CamelToSnakeCaseNested<T>;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    const newObj: any = {};\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const newKey = camelToSnakeCase(key);\n        newObj[newKey] = camelToSnakeCaseNested((obj as any)[key]);\n      }\n    }\n    return newObj as CamelToSnakeCaseNested<T>;\n  } else {\n    return obj as CamelToSnakeCaseNested<T>;\n  }\n}\n","import type { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseCallbackHandler } from \"@langchain/core/callbacks/base\";\nimport { type DocumentInterface } from \"@langchain/core/documents\";\nimport type { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  FunctionMessage,\n  FunctionMessageChunk,\n  HumanMessage,\n  HumanMessageChunk,\n  SystemMessage,\n  SystemMessageChunk,\n  ToolMessage,\n  ToolMessageChunk,\n  mapChatMessagesToStoredMessages,\n  type BaseMessage,\n  type StoredMessage,\n} from \"@langchain/core/messages\";\nimport type { ChatGeneration, LLMResult } from \"@langchain/core/outputs\";\nimport type { ChainValues } from \"@langchain/core/utils/types\";\nimport { stringify } from \"javascript-stringify\";\nimport {\n  type LangWatchRAGSpan,\n  type LangWatchSpan,\n  type LangWatchTrace,\n} from \".\";\nimport {\n  type RAGSpan,\n  type BaseSpan,\n  type ChatMessage,\n  type ChatRichContent,\n  type SpanInputOutput,\n} from \"./types\";\n\nexport class LangWatchCallbackHandler extends BaseCallbackHandler {\n  name = \"LangWatchCallbackHandler\";\n  trace: LangWatchTrace;\n  spans: Record<string, LangWatchSpan> = {};\n\n  constructor({ trace }: { trace: LangWatchTrace }) {\n    super();\n    this.trace = trace;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    _tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildLLMSpan({\n      llm,\n      runId,\n      parentRunId,\n      input: {\n        type: \"json\",\n        value: prompts,\n      },\n      extraParams,\n      metadata,\n      name,\n    });\n  }\n\n  private buildLLMSpan({\n    llm,\n    runId,\n    parentRunId,\n    input,\n    extraParams,\n    metadata,\n    name,\n  }: {\n    llm: Serialized;\n    runId: string;\n    parentRunId?: string | undefined;\n    input: SpanInputOutput;\n    extraParams?: Record<string, unknown> | undefined;\n    metadata?: Record<string, unknown> | undefined;\n    name?: string | undefined;\n  }) {\n    try {\n      const parent = this.getParent(parentRunId);\n\n      const vendor = metadata?.ls_provider ?? llm.id.at(-2)?.toString();\n      const model =\n        metadata?.ls_model_name ?? (llm as any).kwargs?.model ?? \"unknown\";\n\n      const span = parent.startLLMSpan({\n        spanId: runId,\n        name: name ?? llm.id.at(-1)?.toString(),\n        input,\n        model: [vendor, model].filter((x) => x).join(\"/\"),\n        params: {\n          temperature: (extraParams?.invocation_params as any)?.temperature,\n          ...((extraParams?.invocation_params as any)?.functions\n            ? { functions: (extraParams?.invocation_params as any)?.functions }\n            : {}),\n        },\n      });\n\n      return span;\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildLLMSpan({\n      name,\n      llm,\n      runId,\n      parentRunId,\n      input: {\n        type: \"chat_messages\",\n        value: messages.flatMap(convertFromLangChainMessages),\n      },\n      extraParams,\n      metadata,\n    });\n  }\n\n  async handleNewToken(_token: string, runId: string): Promise<void> {\n    const span = this.spans[runId];\n    if (runId && span && !span.timestamps.firstTokenAt) {\n      span.update({\n        timestamps: { ...span.timestamps, firstTokenAt: Date.now() },\n      });\n    }\n  }\n\n  async handleLLMEnd(\n    response: LLMResult,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      const span = this.spans[runId];\n      if (!span) {\n        return;\n      }\n\n      const outputs: SpanInputOutput[] = [];\n      for (const generation of response.generations) {\n        // TODO: again, why the twice loop? Can OpenAI generate multiple chat outputs?\n        for (const generation_ of generation) {\n          if (\"message\" in generation_) {\n            outputs.push({\n              type: \"chat_messages\",\n              value: convertFromLangChainMessages([\n                (generation_ as ChatGeneration).message,\n              ]),\n            });\n          } else if (\"text\" in generation_) {\n            outputs.push({\n              type: \"text\",\n              value: generation_.text,\n            });\n          } else {\n            outputs.push({\n              type: \"text\",\n              value: JSON.stringify(generation_),\n            });\n          }\n        }\n      }\n\n      const output: SpanInputOutput | undefined =\n        outputs.length === 1\n          ? outputs[0]\n          : { type: \"list\", value: outputs as any };\n\n      // Commenting it out because LangChain.js prompt and completion tokens is broken, this one doesn't work as it should with python,\n      // and response_metadata.prompt and response_metadata.completion is there but it's always 0. Better let our server count.\n      // const metrics = response.llmOutput?.token_usage\n      //   ? {\n      //       promptTokens: response.llmOutput.token_usage.prompt_tokens,\n      //       completionTokens: response.llmOutput.token_usage.completion_tokens,\n      //     }\n      //   : undefined;\n\n      span.end({\n        output,\n        // ...(metrics ? { metrics } : {}),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleLLMError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _metadata?: Record<string, unknown> | undefined,\n    _runType?: string,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildSpan({\n      type: \"chain\",\n      serialized: chain,\n      runId,\n      parentRunId,\n      input: inputs,\n      name,\n    });\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    this.endSpan({\n      runId,\n      output,\n    });\n  }\n\n  async handleChainError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _kwargs?: { inputs?: Record<string, unknown> | undefined } | undefined\n  ): Promise<void> {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildSpan({\n      type: \"tool\",\n      serialized: tool,\n      runId,\n      parentRunId,\n      input,\n      name,\n    });\n  }\n\n  async handleToolEnd(\n    output: string,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    this.endSpan({ runId, output });\n  }\n\n  async handleToolError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ): Promise<void> {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _metadata?: Record<string, unknown> | undefined,\n    name?: string | undefined\n  ) {\n    try {\n      const parent = this.getParent(parentRunId);\n\n      this.spans[runId] = parent.startRAGSpan({\n        spanId: runId,\n        name: name ?? retriever.name ?? retriever.id.at(-1)?.toString(),\n        input: this.autoconvertTypedValues(query),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleRetrieverEnd(\n    documents: DocumentInterface<Record<string, any>>[],\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ) {\n    try {\n      const contexts: RAGSpan[\"contexts\"] = documents.map((doc) => ({\n        content: doc.pageContent,\n        ...(doc.metadata.source ? { documentId: doc.metadata.source } : {}),\n      }));\n\n      const span = this.spans[runId] as LangWatchRAGSpan;\n      if (!span) {\n        return;\n      }\n\n      span.end({\n        contexts,\n        output: this.autoconvertTypedValues(documents),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleRetrieverError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ) {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleAgentAction(\n    _action: AgentAction,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ): Promise<void> {\n    const span = this.spans[runId];\n    if (!span) {\n      return;\n    }\n\n    span.update({\n      type: \"agent\",\n    });\n  }\n\n  async handleAgentEnd(\n    action: AgentFinish,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ): Promise<void> {\n    this.endSpan({\n      runId,\n      output: action.returnValues,\n    });\n  }\n\n  private buildSpan({\n    type,\n    serialized,\n    runId,\n    parentRunId,\n    input,\n    name,\n  }: {\n    type: BaseSpan[\"type\"];\n    serialized: Serialized;\n    runId: string;\n    parentRunId?: string | undefined;\n    input: unknown;\n    name?: string | undefined;\n  }) {\n    try {\n      const parent = this.getParent(parentRunId);\n\n      const span = parent.startSpan({\n        spanId: runId,\n        type,\n        name: name ?? serialized.name ?? serialized.id.at(-1)?.toString(),\n        input: this.autoconvertTypedValues(input),\n      });\n\n      return span;\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  private endSpan({ runId, output }: { runId: string; output: unknown }): void {\n    try {\n      const span = this.spans[runId];\n      if (!span) {\n        return;\n      }\n\n      span.end({\n        output: this.autoconvertTypedValues(output),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  private errorSpan({ runId, error }: { runId: string; error: Error }): void {\n    const span = this.spans[runId];\n    if (!span) {\n      return;\n    }\n\n    span.end({\n      error,\n    });\n  }\n\n  private autoconvertTypedValues(value: any): SpanInputOutput | undefined {\n    if (\n      !value ||\n      (typeof value === \"object\" && Object.keys(value).length === 0)\n    ) {\n      return undefined;\n    }\n    if (typeof value === \"string\") {\n      return { type: \"text\", value };\n    }\n    try {\n      JSON.stringify(value);\n      return { type: \"json\", value };\n    } catch (e) {\n      return { type: \"text\", value: stringify(value) ?? value.toString() };\n    }\n  }\n\n  private getParent(\n    parentRunId?: string | undefined\n  ): LangWatchSpan | LangWatchTrace {\n    return (\n      (parentRunId\n        ? this.spans[parentRunId]\n        : this.spans[Object.keys(this.spans).at(-1) ?? \"\"]) ?? this.trace\n    );\n  }\n}\n\nexport const convertFromLangChainMessages = (\n  messages: BaseMessage[]\n): ChatMessage[] => {\n  const chatMessages: ChatMessage[] = [];\n  for (const message of messages) {\n    chatMessages.push(convertFromLangChainMessage(message));\n  }\n  return chatMessages;\n};\n\nconst convertFromLangChainMessage = (\n  message: BaseMessage & { id?: string[] }\n): ChatMessage => {\n  let role: ChatMessage[\"role\"] = \"user\";\n\n  const message_: (BaseMessage | StoredMessage) & {\n    id?: string[];\n    type?: string;\n  } = message.lc_serializable\n    ? mapChatMessagesToStoredMessages([message])[0]!\n    : message;\n\n  // Dang this is so hard, langchain.js has 3 ways of representing the same thing...\n  if (\n    message_ instanceof HumanMessage ||\n    message_ instanceof HumanMessageChunk ||\n    message_.id?.at(-1) === \"HumanMessage\" ||\n    message_.id?.at(-1) === \"HumanMessageChunk\" ||\n    message_.type === \"human\"\n  ) {\n    role = \"user\";\n  } else if (\n    message instanceof AIMessage ||\n    message instanceof AIMessageChunk ||\n    message.id?.at(-1) === \"AIMessage\" ||\n    message.id?.at(-1) === \"AIMessageChunk\" ||\n    message_.type === \"ai\"\n  ) {\n    role = \"assistant\";\n  } else if (\n    message instanceof SystemMessage ||\n    message instanceof SystemMessageChunk ||\n    message.id?.at(-1) === \"SystemMessage\" ||\n    message.id?.at(-1) === \"SystemMessageChunk\" ||\n    message_.type === \"system\"\n  ) {\n    role = \"system\";\n  } else if (\n    message instanceof FunctionMessage ||\n    message instanceof FunctionMessageChunk ||\n    message.id?.at(-1) === \"FunctionMessage\" ||\n    message.id?.at(-1) === \"FunctionMessageChunk\" ||\n    message_.type === \"function\"\n  ) {\n    role = \"function\";\n  } else if (\n    message instanceof ToolMessage ||\n    message instanceof ToolMessageChunk ||\n    message.id?.at(-1) === \"ToolMessage\" ||\n    message.id?.at(-1) === \"ToolMessageChunk\" ||\n    message_.type === \"tool\"\n  ) {\n    role = \"tool\";\n  }\n\n  const content =\n    typeof message.content === \"string\"\n      ? message.content\n      : message.content.map(\n          (content): ChatRichContent =>\n            content.type === \"text\"\n              ? { type: \"text\", text: content.text }\n              : content.type == \"image_url\"\n              ? { type: \"image_url\", image_url: content.image_url }\n              : { type: \"text\", text: JSON.stringify(content) }\n        );\n\n  const functionCall = message.additional_kwargs as\n    | ChatMessage[\"function_call\"]\n    | undefined;\n\n  return {\n    role,\n    content,\n    ...(functionCall &&\n    typeof functionCall === \"object\" &&\n    Object.keys(functionCall).length > 0\n      ? { function_call: functionCall }\n      : {}),\n  };\n};\n"],"mappings":"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","names":["content"]}