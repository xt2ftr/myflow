import { CoreMessage } from 'ai';
import modelPrices from 'llm-cost/model_prices_and_context_window.json';

type ChatRole = "system" | "user" | "assistant" | "function" | "tool" | "unknown";
interface FunctionCall {
    name?: string;
    arguments?: string;
}
interface ToolCall {
    id: string;
    type: string;
    function: FunctionCall;
}
interface ChatMessage$1 {
    role?: ChatRole;
    content?: string | ChatRichContent$1[] | null;
    function_call?: FunctionCall | null;
    tool_calls?: ToolCall[] | null;
    tool_call_id?: string | null;
}
type ChatRichContent$1 = {
    type: "text";
    text?: string;
} | {
    type: "image_url";
    image_url?: {
        url: string;
        detail?: "auto" | "low" | "high";
    };
};
interface TypedValueChatMessages {
    type: "chat_messages";
    value: ChatMessage$1[];
}
interface TypedValueText {
    type: "text";
    value: string;
}
interface TypedValueRaw {
    type: "raw";
    value: string;
}
type JSONSerializable = string | number | boolean | null | Record<string, any> | any[];
interface TypedValueJson {
    type: "json";
    value: JSONSerializable;
}
type Money = {
    currency: string;
    amount: number;
};
interface GuardrailResult {
    status: "processed" | "skipped" | "error";
    passed: boolean;
    score?: number | null;
    details?: string | null;
    cost?: Money | null;
}
interface TypedValueGuardrailResult {
    type: "guardrail_result";
    value: GuardrailResult;
}
type SpanInputOutput$1 = TypedValueText | TypedValueChatMessages | TypedValueGuardrailResult | TypedValueJson | TypedValueRaw | {
    type: "list";
    value: SpanInputOutput$1[];
};
interface ErrorCapture {
    has_error: true;
    message: string;
    stacktrace: string[];
}
interface SpanMetrics {
    prompt_tokens?: number | null;
    completion_tokens?: number | null;
    tokens_estimated?: boolean | null;
    cost?: number | null;
}
interface SpanParams {
    temperature?: number;
    stream?: boolean;
    functions?: Record<string, any>[];
    tools?: Record<string, any>[];
    tool_choice?: string;
}
interface SpanTimestamps {
    started_at: number;
    first_token_at?: number | null;
    finished_at: number;
}
type SpanTypes = "span" | "llm" | "chain" | "tool" | "agent" | "rag" | "guardrail" | "unknown";
interface BaseSpan$1 {
    span_id: string;
    parent_id?: string | null;
    trace_id: string;
    type: SpanTypes;
    name?: string | null;
    input?: SpanInputOutput$1 | null;
    output?: SpanInputOutput$1 | null;
    error?: ErrorCapture | null;
    timestamps: SpanTimestamps;
    metrics?: SpanMetrics | null;
}
interface LLMSpan$1 extends BaseSpan$1 {
    type: "llm";
    vendor?: string | null;
    model?: string;
    params?: SpanParams;
}
interface RAGChunk {
    document_id?: string | null;
    chunk_id?: string | null;
    content: string | Record<string, any> | any[];
}
interface RAGSpan$1 extends BaseSpan$1 {
    type: "rag";
    contexts: RAGChunk[];
}
type Span = LLMSpan$1 | RAGSpan$1 | BaseSpan$1;
type TraceInput = {
    value: string;
    embeddings?: {
        model: string;
        embeddings: number[];
    };
    satisfaction_score?: number;
};
type TraceOutput = {
    value: string;
    embeddings?: {
        model: string;
        embeddings: number[];
    };
};
type Trace = {
    trace_id: string;
    project_id: string;
    metadata: {
        thread_id?: string;
        user_id?: string;
        customer_id?: string;
        labels?: string[];
        topic_id?: string;
        subtopic_id?: string;
    };
    timestamps: {
        started_at: number;
        inserted_at: number;
        updated_at: number;
    };
    input: TraceInput;
    output?: TraceOutput;
    metrics: {
        first_token_ms?: number | null;
        total_time_ms?: number | null;
        prompt_tokens?: number | null;
        completion_tokens?: number | null;
        total_cost?: number | null;
        tokens_estimated?: boolean | null;
    };
    error?: ErrorCapture | null;
    indexing_md5s?: string[];
};
type Experiment = {
    experiment_id: string;
    variant: number;
};
type CollectorRESTParams = {
    trace_id?: string | null | undefined;
    spans: Span[];
    metadata?: {
        user_id?: string | null | undefined;
        thread_id?: string | null | undefined;
        customer_id?: string | null | undefined;
        labels?: string[] | null | undefined;
        experiments?: Experiment[] | null | undefined;
    };
};

type SnakeToCamelCase<S extends string> = S extends `${infer T}_${infer U}` ? `${T}${Capitalize<SnakeToCamelCase<U>>}` : S;
type SnakeToCamelCaseNested<T> = T extends object ? T extends (infer U)[] ? U extends object ? {
    [K in keyof U as SnakeToCamelCase<K & string>]: SnakeToCamelCaseNested<U[K]>;
}[] : T : {
    [K in keyof T as SnakeToCamelCase<K & string>]: SnakeToCamelCaseNested<T[K]>;
} : T;

type Metadata = SnakeToCamelCaseNested<Trace["metadata"]>;
type ChatMessage = ChatMessage$1;
type ChatRichContent = ChatRichContent$1;
type SpanInputOutput = SnakeToCamelCaseNested<Exclude<SpanInputOutput$1, TypedValueChatMessages>> | (TypedValueChatMessages & {
    type: ChatMessage;
});
type ConvertServerSpan<T extends BaseSpan$1> = SnakeToCamelCaseNested<Omit<T, "input" | "output" | "error">> & {
    input?: SpanInputOutput | null;
    output?: SpanInputOutput | null;
    error?: T["error"] | NonNullable<unknown>;
};
type PendingSpan<T extends BaseSpan> = Omit<T, "traceId" | "timestamps"> & {
    timestamps: Omit<T["timestamps"], "finishedAt"> & {
        finishedAt?: number | null;
    };
};
type BaseSpan = ConvertServerSpan<BaseSpan$1>;
type PendingBaseSpan = PendingSpan<BaseSpan>;
type LLMSpan = ConvertServerSpan<Omit<LLMSpan$1, "vendor" | "model">> & {
    model: keyof typeof modelPrices | (string & NonNullable<unknown>);
};
type PendingLLMSpan = PendingSpan<LLMSpan>;
type RAGSpan = ConvertServerSpan<RAGSpan$1>;
type PendingRAGSpan = PendingSpan<RAGSpan>;

declare function convertFromVercelAIMessages(messages: CoreMessage[]): ChatMessage[];
declare const captureError: (error: unknown) => ErrorCapture;
declare const autoconvertTypedValues: (value: unknown) => SpanInputOutput;

export { type BaseSpan as B, type CollectorRESTParams as C, type LLMSpan as L, type Metadata as M, type PendingBaseSpan as P, type RAGSpan as R, type Span as S, type PendingLLMSpan as a, type PendingRAGSpan as b, type SpanTypes as c, type ChatMessage as d, type ChatRichContent as e, type SpanInputOutput as f, convertFromVercelAIMessages as g, captureError as h, autoconvertTypedValues as i };
