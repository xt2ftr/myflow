import EventEmitter from 'events';
import { M as Metadata, C as CollectorRESTParams, S as Span, P as PendingBaseSpan, a as PendingLLMSpan, b as PendingRAGSpan, c as SpanTypes } from './utils-K-jSEpnZ.mjs';
export { B as BaseSpan, d as ChatMessage, e as ChatRichContent, L as LLMSpan, R as RAGSpan, f as SpanInputOutput, i as autoconvertTypedValues, h as captureError, g as convertFromVercelAIMessages } from './utils-K-jSEpnZ.mjs';
import { AgentAction, AgentFinish } from '@langchain/core/agents';
import { BaseCallbackHandler } from '@langchain/core/callbacks/base';
import { DocumentInterface } from '@langchain/core/documents';
import { Serialized } from '@langchain/core/load/serializable';
import { BaseMessage } from '@langchain/core/messages';
import { LLMResult } from '@langchain/core/outputs';
import { ChainValues } from '@langchain/core/utils/types';
import 'ai';
import 'llm-cost/model_prices_and_context_window.json';

declare class LangWatchCallbackHandler extends BaseCallbackHandler {
    name: string;
    trace: LangWatchTrace;
    spans: Record<string, LangWatchSpan>;
    constructor({ trace }: {
        trace: LangWatchTrace;
    });
    handleLLMStart(llm: Serialized, prompts: string[], runId: string, parentRunId?: string | undefined, extraParams?: Record<string, unknown> | undefined, _tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, name?: string): Promise<void>;
    private buildLLMSpan;
    handleChatModelStart(llm: Serialized, messages: BaseMessage[][], runId: string, parentRunId?: string | undefined, extraParams?: Record<string, unknown> | undefined, tags?: string[] | undefined, metadata?: Record<string, unknown> | undefined, name?: string): Promise<void>;
    handleNewToken(_token: string, runId: string): Promise<void>;
    handleLLMEnd(response: LLMResult, runId: string, _parentRunId?: string | undefined): Promise<void>;
    handleLLMError(err: Error, runId: string, _parentRunId?: string | undefined): Promise<void>;
    handleChainStart(chain: Serialized, inputs: ChainValues, runId: string, parentRunId?: string | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, _runType?: string, name?: string): Promise<void>;
    handleChainEnd(output: ChainValues, runId: string, _parentRunId?: string | undefined): Promise<void>;
    handleChainError(err: Error, runId: string, _parentRunId?: string | undefined, _tags?: string[] | undefined, _kwargs?: {
        inputs?: Record<string, unknown> | undefined;
    } | undefined): Promise<void>;
    handleToolStart(tool: Serialized, input: string, runId: string, parentRunId?: string | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, name?: string): Promise<void>;
    handleToolEnd(output: string, runId: string, _parentRunId?: string | undefined): Promise<void>;
    handleToolError(err: Error, runId: string, _parentRunId?: string | undefined, _tags?: string[] | undefined): Promise<void>;
    handleRetrieverStart(retriever: Serialized, query: string, runId: string, parentRunId?: string | undefined, _tags?: string[] | undefined, _metadata?: Record<string, unknown> | undefined, name?: string | undefined): Promise<void>;
    handleRetrieverEnd(documents: DocumentInterface<Record<string, any>>[], runId: string, _parentRunId?: string | undefined, _tags?: string[] | undefined): Promise<void>;
    handleRetrieverError(err: Error, runId: string, _parentRunId?: string | undefined, _tags?: string[] | undefined): Promise<void>;
    handleAgentAction(_action: AgentAction, runId: string, _parentRunId?: string | undefined, _tags?: string[] | undefined): Promise<void>;
    handleAgentEnd(action: AgentFinish, runId: string, _parentRunId?: string | undefined, _tags?: string[] | undefined): Promise<void>;
    private buildSpan;
    private endSpan;
    private errorSpan;
    private autoconvertTypedValues;
    private getParent;
}

declare class LangWatch extends EventEmitter {
    apiKey: string | undefined;
    endpoint: string;
    constructor({ apiKey, endpoint, }?: {
        apiKey?: string;
        endpoint?: string;
    });
    getTrace({ traceId, metadata, }?: {
        traceId?: string;
        metadata?: Metadata;
    }): LangWatchTrace;
    sendTrace(params: CollectorRESTParams): Promise<void>;
    _sendTrace(params: CollectorRESTParams): Promise<void>;
}
declare class LangWatchTrace {
    client: LangWatch;
    traceId: string;
    metadata?: Metadata;
    finishedSpans: Record<string, Span>;
    timeoutRef?: NodeJS.Timeout;
    langchainCallback?: LangWatchCallbackHandler;
    constructor({ client, traceId, metadata, }: {
        client: LangWatch;
        traceId: string;
        metadata?: Metadata;
    });
    update({ metadata }: {
        metadata: Metadata;
    }): void;
    startSpan(params: Omit<Partial<PendingBaseSpan>, "parentId">): LangWatchSpan;
    startLLMSpan(params: Omit<Partial<PendingLLMSpan>, "parentId">): LangWatchLLMSpan;
    startRAGSpan(params: Omit<Partial<PendingRAGSpan>, "parentId">): LangWatchRAGSpan;
    getLangChainCallback(): LangWatchCallbackHandler;
    onEnd(span: Span): void;
    delayedSendSpans(): void;
    sendSpans(): Promise<void>;
}
declare class LangWatchSpan implements PendingBaseSpan {
    trace: LangWatchTrace;
    spanId: string;
    parentId?: string | null;
    type: SpanTypes;
    name?: string | null;
    input?: PendingBaseSpan["input"];
    output?: PendingBaseSpan["output"];
    error?: PendingBaseSpan["error"];
    timestamps: PendingBaseSpan["timestamps"];
    metrics: PendingBaseSpan["metrics"];
    constructor({ trace, spanId, parentId, type, name, input, output, error, timestamps, metrics, }: Partial<PendingBaseSpan> & {
        trace: LangWatchTrace;
    });
    update(params: Partial<Omit<PendingBaseSpan, "spanId" | "parentId">>): void;
    startSpan(params: Omit<Partial<PendingBaseSpan>, "parentId">): LangWatchSpan;
    startLLMSpan(params: Omit<Partial<PendingLLMSpan>, "parentId">): LangWatchLLMSpan;
    startRAGSpan(params: Omit<Partial<PendingRAGSpan>, "parentId">): LangWatchRAGSpan;
    end(params?: Partial<Omit<PendingBaseSpan, "spanId" | "parentId">>): void;
}
declare class LangWatchLLMSpan extends LangWatchSpan implements PendingLLMSpan {
    type: "llm";
    model: PendingLLMSpan["model"];
    params: PendingLLMSpan["params"];
    constructor(params: Partial<PendingLLMSpan> & {
        trace: LangWatchTrace;
    });
    update(params: Partial<PendingLLMSpan>): void;
    end(params?: Partial<PendingLLMSpan>): void;
}
declare class LangWatchRAGSpan extends LangWatchSpan implements PendingRAGSpan {
    type: "rag";
    contexts: PendingRAGSpan["contexts"];
    constructor(params: Partial<PendingRAGSpan> & {
        trace: LangWatchTrace;
    });
    update(params: Partial<PendingRAGSpan>): void;
    end(params?: Partial<PendingRAGSpan>): void;
}

export { LangWatch, LangWatchLLMSpan, LangWatchRAGSpan, LangWatchSpan, LangWatchTrace, Metadata, PendingBaseSpan, PendingLLMSpan, PendingRAGSpan };
