"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/secure-json-parse/index.js"(exports2, module2) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module2.exports = parse;
    module2.exports.default = parse;
    module2.exports.parse = parse;
    module2.exports.safeParse = safeParse;
    module2.exports.scan = filter;
  }
});

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  autoconvertTypedValues: () => autoconvertTypedValues,
  captureError: () => captureError,
  convertFromVercelAIMessages: () => convertFromVercelAIMessages
});
module.exports = __toCommonJS(utils_exports);

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_non_secure = require("nanoid/non-secure");
var import_secure_json_parse = __toESM(require_secure_json_parse(), 1);
var generateId = (0, import_non_secure.customAlphabet)(
  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  7
);
function convertUint8ArrayToBase64(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return globalThis.btoa(latin1string);
}

// src/server/types/tracer.generated.ts
var import_zod = require("zod");
var chatRoleSchema = import_zod.z.union([
  import_zod.z.literal("system"),
  import_zod.z.literal("user"),
  import_zod.z.literal("assistant"),
  import_zod.z.literal("function"),
  import_zod.z.literal("tool"),
  import_zod.z.literal("unknown")
]);
var functionCallSchema = import_zod.z.object({
  name: import_zod.z.string().optional(),
  arguments: import_zod.z.string().optional()
});
var toolCallSchema = import_zod.z.object({
  id: import_zod.z.string(),
  type: import_zod.z.string(),
  function: functionCallSchema
});
var chatRichContentSchema = import_zod.z.union([
  import_zod.z.object({
    type: import_zod.z.literal("text"),
    text: import_zod.z.string().optional()
  }),
  import_zod.z.object({
    type: import_zod.z.literal("image_url"),
    image_url: import_zod.z.object({
      url: import_zod.z.string(),
      detail: import_zod.z.union([import_zod.z.literal("auto"), import_zod.z.literal("low"), import_zod.z.literal("high")]).optional()
    }).optional()
  })
]);
var typedValueTextSchema = import_zod.z.object({
  type: import_zod.z.literal("text"),
  value: import_zod.z.string()
});
var typedValueRawSchema = import_zod.z.object({
  type: import_zod.z.literal("raw"),
  value: import_zod.z.string()
});
var jSONSerializableSchema = import_zod.z.union([
  import_zod.z.string(),
  import_zod.z.number(),
  import_zod.z.boolean(),
  import_zod.z.record(import_zod.z.any()),
  import_zod.z.array(import_zod.z.any())
]).nullable();
var typedValueJsonSchema = import_zod.z.object({
  type: import_zod.z.literal("json"),
  value: jSONSerializableSchema
});
var moneySchema = import_zod.z.object({
  currency: import_zod.z.string(),
  amount: import_zod.z.number()
});
var guardrailResultSchema = import_zod.z.object({
  status: import_zod.z.union([
    import_zod.z.literal("processed"),
    import_zod.z.literal("skipped"),
    import_zod.z.literal("error")
  ]),
  passed: import_zod.z.boolean(),
  score: import_zod.z.number().optional().nullable(),
  details: import_zod.z.string().optional().nullable(),
  cost: moneySchema.optional().nullable()
});
var typedValueGuardrailResultSchema = import_zod.z.object({
  type: import_zod.z.literal("guardrail_result"),
  value: guardrailResultSchema
});
var errorCaptureSchema = import_zod.z.object({
  has_error: import_zod.z.literal(true),
  message: import_zod.z.string(),
  stacktrace: import_zod.z.array(import_zod.z.string())
});
var spanMetricsSchema = import_zod.z.object({
  prompt_tokens: import_zod.z.number().optional().nullable(),
  completion_tokens: import_zod.z.number().optional().nullable(),
  tokens_estimated: import_zod.z.boolean().optional().nullable(),
  cost: import_zod.z.number().optional().nullable()
});
var spanParamsSchema = import_zod.z.object({
  temperature: import_zod.z.number().optional(),
  stream: import_zod.z.boolean().optional(),
  functions: import_zod.z.array(import_zod.z.record(import_zod.z.any())).optional(),
  tools: import_zod.z.array(import_zod.z.record(import_zod.z.any())).optional(),
  tool_choice: import_zod.z.string().optional()
});
var spanTimestampsSchema = import_zod.z.object({
  started_at: import_zod.z.number(),
  first_token_at: import_zod.z.number().optional().nullable(),
  finished_at: import_zod.z.number()
});
var spanTypesSchema = import_zod.z.union([
  import_zod.z.literal("span"),
  import_zod.z.literal("llm"),
  import_zod.z.literal("chain"),
  import_zod.z.literal("tool"),
  import_zod.z.literal("agent"),
  import_zod.z.literal("rag"),
  import_zod.z.literal("guardrail"),
  import_zod.z.literal("unknown")
]);
var rAGChunkSchema = import_zod.z.object({
  document_id: import_zod.z.string().optional().nullable(),
  chunk_id: import_zod.z.string().optional().nullable(),
  content: import_zod.z.union([import_zod.z.string(), import_zod.z.record(import_zod.z.any()), import_zod.z.array(import_zod.z.any())])
});
var traceInputSchema = import_zod.z.object({
  value: import_zod.z.string(),
  embeddings: import_zod.z.object({
    model: import_zod.z.string(),
    embeddings: import_zod.z.array(import_zod.z.number())
  }).optional(),
  satisfaction_score: import_zod.z.number().optional()
});
var traceOutputSchema = import_zod.z.object({
  value: import_zod.z.string(),
  embeddings: import_zod.z.object({
    model: import_zod.z.string(),
    embeddings: import_zod.z.array(import_zod.z.number())
  }).optional()
});
var traceSchema = import_zod.z.object({
  trace_id: import_zod.z.string(),
  project_id: import_zod.z.string(),
  metadata: import_zod.z.object({
    thread_id: import_zod.z.string().optional(),
    user_id: import_zod.z.string().optional(),
    customer_id: import_zod.z.string().optional(),
    labels: import_zod.z.array(import_zod.z.string()).optional(),
    topic_id: import_zod.z.string().optional(),
    subtopic_id: import_zod.z.string().optional()
  }),
  timestamps: import_zod.z.object({
    started_at: import_zod.z.number(),
    inserted_at: import_zod.z.number(),
    updated_at: import_zod.z.number()
  }),
  input: traceInputSchema,
  output: traceOutputSchema.optional(),
  metrics: import_zod.z.object({
    first_token_ms: import_zod.z.number().optional().nullable(),
    total_time_ms: import_zod.z.number().optional().nullable(),
    prompt_tokens: import_zod.z.number().optional().nullable(),
    completion_tokens: import_zod.z.number().optional().nullable(),
    total_cost: import_zod.z.number().optional().nullable(),
    tokens_estimated: import_zod.z.boolean().optional().nullable()
  }),
  error: errorCaptureSchema.optional().nullable(),
  indexing_md5s: import_zod.z.array(import_zod.z.string()).optional()
});
var elasticSearchTraceSchema = traceSchema.and(
  import_zod.z.object({
    timestamps: traceSchema.shape.timestamps.and(
      import_zod.z.object({
        updated_at: import_zod.z.number()
      })
    )
  })
);
var traceCheckSchema = import_zod.z.object({
  trace_id: import_zod.z.string(),
  check_id: import_zod.z.string(),
  project_id: import_zod.z.string(),
  check_type: import_zod.z.string(),
  check_name: import_zod.z.string(),
  is_guardrail: import_zod.z.boolean(),
  status: import_zod.z.union([
    import_zod.z.literal("scheduled"),
    import_zod.z.literal("in_progress"),
    import_zod.z.literal("error"),
    import_zod.z.literal("skipped"),
    import_zod.z.literal("processed")
  ]),
  passed: import_zod.z.boolean().optional(),
  score: import_zod.z.number().optional(),
  details: import_zod.z.string().optional(),
  error: errorCaptureSchema.optional().nullable(),
  retries: import_zod.z.number().optional(),
  timestamps: import_zod.z.object({
    inserted_at: import_zod.z.number().optional(),
    started_at: import_zod.z.number().optional(),
    finished_at: import_zod.z.number().optional(),
    updated_at: import_zod.z.number()
  }),
  trace_metadata: import_zod.z.object({
    thread_id: import_zod.z.string().optional(),
    user_id: import_zod.z.string().optional(),
    customer_id: import_zod.z.string().optional(),
    labels: import_zod.z.array(import_zod.z.string()).optional(),
    topics: import_zod.z.array(import_zod.z.string()).optional()
  })
});
var experimentSchema = import_zod.z.object({
  experiment_id: import_zod.z.string(),
  variant: import_zod.z.number()
});
var eventSchema = import_zod.z.object({
  event_id: import_zod.z.string(),
  event_type: import_zod.z.string(),
  project_id: import_zod.z.string(),
  metrics: import_zod.z.record(import_zod.z.number()),
  event_details: import_zod.z.record(import_zod.z.string()),
  trace_id: import_zod.z.string().optional(),
  trace_metadata: import_zod.z.object({
    thread_id: import_zod.z.string().optional(),
    user_id: import_zod.z.string().optional(),
    customer_id: import_zod.z.string().optional(),
    labels: import_zod.z.array(import_zod.z.string()).optional(),
    topics: import_zod.z.array(import_zod.z.string()).optional()
  }),
  timestamps: import_zod.z.object({
    started_at: import_zod.z.number(),
    inserted_at: import_zod.z.number(),
    updated_at: import_zod.z.number()
  })
});
var elasticSearchEventSchema = eventSchema.omit({ metrics: true, event_details: true }).and(
  import_zod.z.object({
    metrics: import_zod.z.array(
      import_zod.z.object({
        key: import_zod.z.string(),
        value: import_zod.z.number()
      })
    ),
    event_details: import_zod.z.array(
      import_zod.z.object({
        key: import_zod.z.string(),
        value: import_zod.z.string()
      })
    )
  })
);
var trackEventRESTParamsValidatorSchema = eventSchema.omit({
  event_id: true,
  project_id: true,
  timestamps: true,
  event_details: true,
  trace_metadata: true
}).and(
  import_zod.z.object({
    event_id: import_zod.z.string().optional(),
    event_details: import_zod.z.record(import_zod.z.string()).optional(),
    timestamp: import_zod.z.number().optional()
  })
);
var chatMessageSchema = import_zod.z.object({
  role: chatRoleSchema.optional(),
  content: import_zod.z.union([import_zod.z.string(), import_zod.z.array(chatRichContentSchema)]).optional().nullable(),
  function_call: functionCallSchema.optional().nullable(),
  tool_calls: import_zod.z.array(toolCallSchema).optional().nullable(),
  tool_call_id: import_zod.z.string().optional().nullable()
});
var typedValueChatMessagesSchema = import_zod.z.object({
  type: import_zod.z.literal("chat_messages"),
  value: import_zod.z.array(chatMessageSchema)
});
var spanInputOutputSchema = import_zod.z.lazy(
  () => import_zod.z.union([
    typedValueTextSchema,
    typedValueChatMessagesSchema,
    typedValueGuardrailResultSchema,
    typedValueJsonSchema,
    typedValueRawSchema,
    import_zod.z.object({
      type: import_zod.z.literal("list"),
      value: import_zod.z.array(spanInputOutputSchema)
    })
  ])
);
var baseSpanSchema = import_zod.z.object({
  span_id: import_zod.z.string(),
  parent_id: import_zod.z.string().optional().nullable(),
  trace_id: import_zod.z.string(),
  type: spanTypesSchema,
  name: import_zod.z.string().optional().nullable(),
  input: spanInputOutputSchema.optional().nullable(),
  output: spanInputOutputSchema.optional().nullable(),
  error: errorCaptureSchema.optional().nullable(),
  timestamps: spanTimestampsSchema,
  metrics: spanMetricsSchema.optional().nullable()
});
var lLMSpanSchema = baseSpanSchema.extend({
  type: import_zod.z.literal("llm"),
  vendor: import_zod.z.string().optional().nullable(),
  model: import_zod.z.string().optional(),
  params: spanParamsSchema.optional()
});
var rAGSpanSchema = baseSpanSchema.extend({
  type: import_zod.z.literal("rag"),
  contexts: import_zod.z.array(rAGChunkSchema)
});
var spanSchema = import_zod.z.union([
  lLMSpanSchema,
  rAGSpanSchema,
  baseSpanSchema
]);
var spanInputOutputValidatorSchema = spanInputOutputSchema.and(
  import_zod.z.object({
    value: import_zod.z.any()
  })
);
var spanValidatorSchema = import_zod.z.union([
  lLMSpanSchema.omit({ input: true, output: true }),
  rAGSpanSchema.omit({ input: true, output: true }),
  baseSpanSchema.omit({ input: true, output: true })
]).and(
  import_zod.z.object({
    input: spanInputOutputValidatorSchema.optional().nullable(),
    output: spanInputOutputValidatorSchema.optional().nullable()
  })
);
var collectorRESTParamsSchema = import_zod.z.object({
  trace_id: import_zod.z.union([import_zod.z.string(), import_zod.z.undefined()]).optional().nullable(),
  spans: import_zod.z.array(spanSchema),
  metadata: import_zod.z.object({
    user_id: import_zod.z.union([import_zod.z.string(), import_zod.z.undefined()]).optional().nullable(),
    thread_id: import_zod.z.union([import_zod.z.string(), import_zod.z.undefined()]).optional().nullable(),
    customer_id: import_zod.z.union([import_zod.z.string(), import_zod.z.undefined()]).optional().nullable(),
    labels: import_zod.z.union([import_zod.z.array(import_zod.z.string()), import_zod.z.undefined()]).optional().nullable(),
    experiments: import_zod.z.union([import_zod.z.array(experimentSchema), import_zod.z.undefined()]).optional().nullable()
  }).optional()
});
var collectorRESTParamsValidatorSchema = collectorRESTParamsSchema.omit({ spans: true });
var datasetSpanSchema = import_zod.z.union([
  baseSpanSchema.omit({
    project_id: true,
    trace_id: true,
    id: true,
    timestamps: true,
    metrics: true
  }),
  lLMSpanSchema.omit({
    project_id: true,
    trace_id: true,
    id: true,
    timestamps: true,
    metrics: true
  }),
  rAGSpanSchema.omit({
    project_id: true,
    trace_id: true,
    id: true,
    timestamps: true,
    metrics: true
  })
]);

// src/utils.ts
var import_zod2 = require("zod");
var convertImageToUrl = (image, mimeType) => {
  try {
    return image instanceof URL ? image.toString() : typeof image === "string" ? image : `data:${mimeType != null ? mimeType : "image/jpeg"};base64,${convertUint8ArrayToBase64(
      image
    )}`;
  } catch (e) {
    console.error("[LangWatch] error converting vercel ui image to url:", e);
    return "";
  }
};
function convertFromVercelAIMessages(messages) {
  var _a;
  const lwMessages = [];
  for (const { role, content } of messages) {
    switch (role) {
      case "system": {
        lwMessages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (Array.isArray(content) && content.length === 1 && ((_a = content[0]) == null ? void 0 : _a.type) === "text") {
          lwMessages.push({ role: "user", content: content[0].text });
          break;
        }
        lwMessages.push({
          role: "user",
          content: Array.isArray(content) ? content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "image": {
                return {
                  type: "image_url",
                  image_url: {
                    url: convertImageToUrl(part.image, part.mimeType)
                  }
                };
              }
            }
          }) : content
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        if (Array.isArray(content)) {
          for (const part of content) {
            switch (part.type) {
              case "text": {
                text += part.text;
                break;
              }
              case "tool-call": {
                toolCalls.push({
                  id: part.toolCallId,
                  type: "function",
                  function: {
                    name: part.toolName,
                    arguments: JSON.stringify(part.args)
                  }
                });
                break;
              }
              default: {
                const _exhaustiveCheck = part;
                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
              }
            }
          }
        } else {
          text = content;
        }
        lwMessages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          lwMessages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: JSON.stringify(toolResponse.result)
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return lwMessages;
}
var captureError = (error) => {
  if (error && typeof error === "object" && "has_error" in error && "message" in error && "stacktrace" in error) {
    return error;
  } else if (error instanceof Error) {
    return {
      has_error: true,
      message: error.message,
      stacktrace: error.stack ? error.stack.split("\n") : []
    };
  } else if (typeof error === "object" && error !== null) {
    const err = error;
    const message = typeof err.message === "string" ? err.message : "An unknown error occurred";
    const stacktrace = typeof err.stack === "string" ? err.stack.split("\n") : Array.isArray(err.stack) && err.stack.length > 0 && typeof err.stack[0] === "string" ? err.stack : ["No stack trace available"];
    return {
      has_error: true,
      message,
      stacktrace
    };
  } else {
    return {
      has_error: true,
      message: String(error),
      stacktrace: []
    };
  }
};
var autoconvertTypedValues = (value) => {
  if (typeof value === "string") {
    return { type: "text", value };
  }
  const chatMessages = import_zod2.z.array(chatMessageSchema).safeParse(value);
  if (Array.isArray(value) && chatMessages.success) {
    return {
      type: "chat_messages",
      value: chatMessages.data
    };
  }
  try {
    JSON.stringify(value);
    return { type: "json", value };
  } catch (e) {
    return { type: "raw", value };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  autoconvertTypedValues,
  captureError,
  convertFromVercelAIMessages
});
//# sourceMappingURL=utils.js.map