import {
  __spreadProps,
  __spreadValues,
  autoconvertTypedValues,
  captureError,
  collectorRESTParamsSchema,
  convertFromVercelAIMessages,
  spanSchema
} from "./chunk-OVS4NSDE.mjs";

// src/index.ts
import EventEmitter from "events";
import { nanoid } from "nanoid";
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";

// src/typeUtils.ts
function camelToSnakeCase(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function camelToSnakeCaseNested(obj) {
  if (Array.isArray(obj)) {
    return obj.map(
      (item) => camelToSnakeCaseNested(item)
    );
  } else if (typeof obj === "object" && obj !== null) {
    const newObj = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const newKey = camelToSnakeCase(key);
        newObj[newKey] = camelToSnakeCaseNested(obj[key]);
      }
    }
    return newObj;
  } else {
    return obj;
  }
}

// src/langchain.ts
import { BaseCallbackHandler } from "@langchain/core/callbacks/base";
import {
  AIMessage,
  AIMessageChunk,
  FunctionMessage,
  FunctionMessageChunk,
  HumanMessage,
  HumanMessageChunk,
  SystemMessage,
  SystemMessageChunk,
  ToolMessage,
  ToolMessageChunk,
  mapChatMessagesToStoredMessages
} from "@langchain/core/messages";
import { stringify } from "javascript-stringify";
var LangWatchCallbackHandler = class extends BaseCallbackHandler {
  constructor({ trace }) {
    super();
    this.name = "LangWatchCallbackHandler";
    this.spans = {};
    this.trace = trace;
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, _tags, metadata, name) {
    this.spans[runId] = this.buildLLMSpan({
      llm,
      runId,
      parentRunId,
      input: {
        type: "json",
        value: prompts
      },
      extraParams,
      metadata,
      name
    });
  }
  buildLLMSpan({
    llm,
    runId,
    parentRunId,
    input,
    extraParams,
    metadata,
    name
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    try {
      const parent = this.getParent(parentRunId);
      const vendor = (_b = metadata == null ? void 0 : metadata.ls_provider) != null ? _b : (_a = llm.id.at(-2)) == null ? void 0 : _a.toString();
      const model = (_e = (_d = metadata == null ? void 0 : metadata.ls_model_name) != null ? _d : (_c = llm.kwargs) == null ? void 0 : _c.model) != null ? _e : "unknown";
      const span = parent.startLLMSpan({
        spanId: runId,
        name: name != null ? name : (_f = llm.id.at(-1)) == null ? void 0 : _f.toString(),
        input,
        model: [vendor, model].filter((x) => x).join("/"),
        params: __spreadValues({
          temperature: (_g = extraParams == null ? void 0 : extraParams.invocation_params) == null ? void 0 : _g.temperature
        }, ((_h = extraParams == null ? void 0 : extraParams.invocation_params) == null ? void 0 : _h.functions) ? { functions: (_i = extraParams == null ? void 0 : extraParams.invocation_params) == null ? void 0 : _i.functions } : {})
      });
      return span;
    } catch (e) {
      this.trace.client.emit("error", e);
      throw e;
    }
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    this.spans[runId] = this.buildLLMSpan({
      name,
      llm,
      runId,
      parentRunId,
      input: {
        type: "chat_messages",
        value: messages.flatMap(convertFromLangChainMessages)
      },
      extraParams,
      metadata
    });
  }
  async handleNewToken(_token, runId) {
    const span = this.spans[runId];
    if (runId && span && !span.timestamps.firstTokenAt) {
      span.update({
        timestamps: __spreadProps(__spreadValues({}, span.timestamps), { firstTokenAt: Date.now() })
      });
    }
  }
  async handleLLMEnd(response, runId, _parentRunId) {
    try {
      const span = this.spans[runId];
      if (!span) {
        return;
      }
      const outputs = [];
      for (const generation of response.generations) {
        for (const generation_ of generation) {
          if ("message" in generation_) {
            outputs.push({
              type: "chat_messages",
              value: convertFromLangChainMessages([
                generation_.message
              ])
            });
          } else if ("text" in generation_) {
            outputs.push({
              type: "text",
              value: generation_.text
            });
          } else {
            outputs.push({
              type: "text",
              value: JSON.stringify(generation_)
            });
          }
        }
      }
      const output = outputs.length === 1 ? outputs[0] : { type: "list", value: outputs };
      span.end({
        output
        // ...(metrics ? { metrics } : {}),
      });
    } catch (e) {
      this.trace.client.emit("error", e);
      throw e;
    }
  }
  async handleLLMError(err, runId, _parentRunId) {
    this.errorSpan({ runId, error: err });
  }
  async handleChainStart(chain, inputs, runId, parentRunId, _tags, _metadata, _runType, name) {
    this.spans[runId] = this.buildSpan({
      type: "chain",
      serialized: chain,
      runId,
      parentRunId,
      input: inputs,
      name
    });
  }
  async handleChainEnd(output, runId, _parentRunId) {
    this.endSpan({
      runId,
      output
    });
  }
  async handleChainError(err, runId, _parentRunId, _tags, _kwargs) {
    this.errorSpan({ runId, error: err });
  }
  async handleToolStart(tool, input, runId, parentRunId, _tags, _metadata, name) {
    this.spans[runId] = this.buildSpan({
      type: "tool",
      serialized: tool,
      runId,
      parentRunId,
      input,
      name
    });
  }
  async handleToolEnd(output, runId, _parentRunId) {
    this.endSpan({ runId, output });
  }
  async handleToolError(err, runId, _parentRunId, _tags) {
    this.errorSpan({ runId, error: err });
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, _tags, _metadata, name) {
    var _a, _b;
    try {
      const parent = this.getParent(parentRunId);
      this.spans[runId] = parent.startRAGSpan({
        spanId: runId,
        name: (_b = name != null ? name : retriever.name) != null ? _b : (_a = retriever.id.at(-1)) == null ? void 0 : _a.toString(),
        input: this.autoconvertTypedValues(query)
      });
    } catch (e) {
      this.trace.client.emit("error", e);
      throw e;
    }
  }
  async handleRetrieverEnd(documents, runId, _parentRunId, _tags) {
    try {
      const contexts = documents.map((doc) => __spreadValues({
        content: doc.pageContent
      }, doc.metadata.source ? { documentId: doc.metadata.source } : {}));
      const span = this.spans[runId];
      if (!span) {
        return;
      }
      span.end({
        contexts,
        output: this.autoconvertTypedValues(documents)
      });
    } catch (e) {
      this.trace.client.emit("error", e);
      throw e;
    }
  }
  async handleRetrieverError(err, runId, _parentRunId, _tags) {
    this.errorSpan({ runId, error: err });
  }
  async handleAgentAction(_action, runId, _parentRunId, _tags) {
    const span = this.spans[runId];
    if (!span) {
      return;
    }
    span.update({
      type: "agent"
    });
  }
  async handleAgentEnd(action, runId, _parentRunId, _tags) {
    this.endSpan({
      runId,
      output: action.returnValues
    });
  }
  buildSpan({
    type,
    serialized,
    runId,
    parentRunId,
    input,
    name
  }) {
    var _a, _b;
    try {
      const parent = this.getParent(parentRunId);
      const span = parent.startSpan({
        spanId: runId,
        type,
        name: (_b = name != null ? name : serialized.name) != null ? _b : (_a = serialized.id.at(-1)) == null ? void 0 : _a.toString(),
        input: this.autoconvertTypedValues(input)
      });
      return span;
    } catch (e) {
      this.trace.client.emit("error", e);
      throw e;
    }
  }
  endSpan({ runId, output }) {
    try {
      const span = this.spans[runId];
      if (!span) {
        return;
      }
      span.end({
        output: this.autoconvertTypedValues(output)
      });
    } catch (e) {
      this.trace.client.emit("error", e);
      throw e;
    }
  }
  errorSpan({ runId, error }) {
    const span = this.spans[runId];
    if (!span) {
      return;
    }
    span.end({
      error
    });
  }
  autoconvertTypedValues(value) {
    var _a;
    if (!value || typeof value === "object" && Object.keys(value).length === 0) {
      return void 0;
    }
    if (typeof value === "string") {
      return { type: "text", value };
    }
    try {
      JSON.stringify(value);
      return { type: "json", value };
    } catch (e) {
      return { type: "text", value: (_a = stringify(value)) != null ? _a : value.toString() };
    }
  }
  getParent(parentRunId) {
    var _a, _b;
    return (_b = parentRunId ? this.spans[parentRunId] : this.spans[(_a = Object.keys(this.spans).at(-1)) != null ? _a : ""]) != null ? _b : this.trace;
  }
};
var convertFromLangChainMessages = (messages) => {
  const chatMessages = [];
  for (const message of messages) {
    chatMessages.push(convertFromLangChainMessage(message));
  }
  return chatMessages;
};
var convertFromLangChainMessage = (message) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  let role = "user";
  const message_ = message.lc_serializable ? mapChatMessagesToStoredMessages([message])[0] : message;
  if (message_ instanceof HumanMessage || message_ instanceof HumanMessageChunk || ((_a = message_.id) == null ? void 0 : _a.at(-1)) === "HumanMessage" || ((_b = message_.id) == null ? void 0 : _b.at(-1)) === "HumanMessageChunk" || message_.type === "human") {
    role = "user";
  } else if (message instanceof AIMessage || message instanceof AIMessageChunk || ((_c = message.id) == null ? void 0 : _c.at(-1)) === "AIMessage" || ((_d = message.id) == null ? void 0 : _d.at(-1)) === "AIMessageChunk" || message_.type === "ai") {
    role = "assistant";
  } else if (message instanceof SystemMessage || message instanceof SystemMessageChunk || ((_e = message.id) == null ? void 0 : _e.at(-1)) === "SystemMessage" || ((_f = message.id) == null ? void 0 : _f.at(-1)) === "SystemMessageChunk" || message_.type === "system") {
    role = "system";
  } else if (message instanceof FunctionMessage || message instanceof FunctionMessageChunk || ((_g = message.id) == null ? void 0 : _g.at(-1)) === "FunctionMessage" || ((_h = message.id) == null ? void 0 : _h.at(-1)) === "FunctionMessageChunk" || message_.type === "function") {
    role = "function";
  } else if (message instanceof ToolMessage || message instanceof ToolMessageChunk || ((_i = message.id) == null ? void 0 : _i.at(-1)) === "ToolMessage" || ((_j = message.id) == null ? void 0 : _j.at(-1)) === "ToolMessageChunk" || message_.type === "tool") {
    role = "tool";
  }
  const content = typeof message.content === "string" ? message.content : message.content.map(
    (content2) => content2.type === "text" ? { type: "text", text: content2.text } : content2.type == "image_url" ? { type: "image_url", image_url: content2.image_url } : { type: "text", text: JSON.stringify(content2) }
  );
  const functionCall = message.additional_kwargs;
  return __spreadValues({
    role,
    content
  }, functionCall && typeof functionCall === "object" && Object.keys(functionCall).length > 0 ? { function_call: functionCall } : {});
};

// src/index.ts
var LangWatch = class extends EventEmitter {
  constructor({
    apiKey,
    endpoint = ((_a) => (_a = process.env.LANGWATCH_ENDPOINT) != null ? _a : "https://app.langwatch.ai")()
  } = {}) {
    super();
    const apiKey_ = apiKey != null ? apiKey : process.env.LANGWATCH_API_KEY;
    if (!apiKey_) {
      const error = new Error(
        "LangWatch API key is not set, please set the LANGWATCH_API_KEY environment variable or pass it in the constructor. Traces will not be captured."
      );
      this.emit("error", error);
    }
    this.apiKey = apiKey_;
    this.endpoint = endpoint;
  }
  getTrace({
    traceId,
    metadata
  } = {}) {
    return new LangWatchTrace({
      client: this,
      traceId: traceId != null ? traceId : `trace_${nanoid()}`,
      metadata
    });
  }
  async sendTrace(params) {
    const backoff = [1e3, 2e3, 4e3, 8e3, 16e3];
    for (const backoffTime of backoff) {
      try {
        await this._sendTrace(params);
        return;
      } catch (e) {
        console.warn(
          `[LangWatch] \u26A0\uFE0F Failed to send trace, retrying in ${backoffTime / 1e3}s`
        );
        await new Promise((resolve) => setTimeout(resolve, backoffTime));
      }
    }
    console.warn("[LangWatch] \u26A0\uFE0F Failed to send trace, giving up");
  }
  async _sendTrace(params) {
    if (params.spans.length === 0) {
      return;
    }
    if (!this.apiKey) {
      const error = new Error(
        "LangWatch API key is not set, LLMs traces will not be sent, go to https://langwatch.ai to set it up"
      );
      this.emit("error", error);
      return;
    }
    const response = await fetch(`${this.endpoint}/api/collector`, {
      method: "POST",
      headers: {
        "X-Auth-Token": this.apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(params)
    });
    if (response.status === 429) {
      const error = new Error(
        "Rate limit exceeded, dropping message from being sent to LangWatch. Please check your dashboard to upgrade your plan."
      );
      this.emit("error", error);
      return;
    }
    if (!response.ok) {
      const error = new Error(
        `Failed to send trace, status: ${response.status}`
      );
      this.emit("error", error);
      throw error;
    }
  }
};
var LangWatchTrace = class {
  constructor({
    client,
    traceId,
    metadata
  }) {
    this.finishedSpans = {};
    this.client = client;
    this.traceId = traceId;
    this.metadata = metadata;
  }
  update({ metadata }) {
    var _a, _b;
    this.metadata = __spreadValues(__spreadValues(__spreadValues({}, this.metadata), metadata), typeof metadata.labels !== "undefined" ? { labels: [...(_b = (_a = this.metadata) == null ? void 0 : _a.labels) != null ? _b : [], ...metadata.labels] } : {});
  }
  startSpan(params) {
    const span = new LangWatchSpan(__spreadValues({
      trace: this
    }, params));
    return span;
  }
  startLLMSpan(params) {
    const span = new LangWatchLLMSpan(__spreadValues({
      trace: this
    }, params));
    return span;
  }
  startRAGSpan(params) {
    const span = new LangWatchRAGSpan(__spreadValues({
      trace: this
    }, params));
    return span;
  }
  getLangChainCallback() {
    if (!this.langchainCallback) {
      this.langchainCallback = new LangWatchCallbackHandler({ trace: this });
    }
    return this.langchainCallback;
  }
  onEnd(span) {
    this.finishedSpans[span.span_id] = span;
    this.delayedSendSpans();
  }
  delayedSendSpans() {
    clearTimeout(this.timeoutRef);
    this.timeoutRef = setTimeout(() => {
      void this.sendSpans();
    }, 1e3);
  }
  async sendSpans() {
    clearTimeout(this.timeoutRef);
    let trace = void 0;
    try {
      trace = collectorRESTParamsSchema.parse({
        trace_id: this.traceId,
        metadata: camelToSnakeCaseNested(this.metadata),
        spans: Object.values(this.finishedSpans)
      });
    } catch (error) {
      if (error instanceof ZodError) {
        console.warn("[LangWatch] \u26A0\uFE0F Failed to parse trace");
        console.warn(fromZodError(error).message);
      }
      this.client.emit("error", error);
    }
    if (trace) {
      await this.client.sendTrace(trace);
    }
  }
};
var LangWatchSpan = class _LangWatchSpan {
  constructor({
    trace,
    spanId,
    parentId,
    type,
    name,
    input,
    output,
    error,
    timestamps,
    metrics
  }) {
    this.spanId = spanId != null ? spanId : `span_${nanoid()}`;
    this.parentId = parentId;
    this.trace = trace;
    this.type = type != null ? type : "span";
    this.name = name;
    this.input = input;
    this.output = output;
    this.error = error;
    this.timestamps = timestamps != null ? timestamps : {
      startedAt: Date.now()
    };
    this.metrics = metrics;
  }
  update(params) {
    if (Object.isFrozen(this)) {
      const error = new Error(
        `Tried to update span ${this.spanId}, but the span is already finished, discarding update`
      );
      this.trace.client.emit("error", error);
      return;
    }
    if (params.type) {
      this.type = params.type;
    }
    if ("name" in params) {
      this.name = params.name;
    }
    if ("input" in params) {
      this.input = params.input;
    }
    if ("output" in params) {
      this.output = params.output;
    }
    if ("error" in params) {
      this.error = params.error;
    }
    if (params.timestamps) {
      this.timestamps = params.timestamps;
    }
    if ("metrics" in params) {
      this.metrics = params.metrics;
    }
  }
  startSpan(params) {
    const span = new _LangWatchSpan(__spreadValues({
      trace: this.trace,
      parentId: this.spanId
    }, params));
    return span;
  }
  startLLMSpan(params) {
    const span = new LangWatchLLMSpan(__spreadValues({
      trace: this.trace,
      parentId: this.spanId
    }, params));
    return span;
  }
  startRAGSpan(params) {
    const span = new LangWatchRAGSpan(__spreadValues({
      trace: this.trace,
      parentId: this.spanId
    }, params));
    return span;
  }
  end(params) {
    this.timestamps.finishedAt = Date.now();
    if (params) {
      this.update(params);
    }
    Object.freeze(this);
    try {
      const finalSpan = spanSchema.parse(
        camelToSnakeCaseNested(__spreadValues(__spreadProps(__spreadValues({}, this), {
          trace: void 0,
          traceId: this.trace.traceId,
          timestamps: __spreadProps(__spreadValues({}, this.timestamps), {
            finishedAt: this.timestamps.finishedAt
          })
        }), this.error && { error: captureError(this.error) }))
      );
      this.trace.onEnd(finalSpan);
    } catch (error) {
      if (error instanceof ZodError) {
        console.warn("[LangWatch] \u26A0\uFE0F Failed to parse span");
        console.warn(fromZodError(error).message);
      }
      this.trace.client.emit("error", error);
    }
  }
};
var LangWatchLLMSpan = class extends LangWatchSpan {
  constructor(params) {
    var _a, _b;
    super(__spreadValues({}, params));
    this.type = "llm";
    this.model = (_a = params.model) != null ? _a : "unknown";
    this.params = (_b = params.params) != null ? _b : {};
  }
  update(params) {
    super.update(params);
    if (params.model) {
      this.model = params.model;
    }
    if (params.params) {
      this.params = params.params;
    }
  }
  end(params) {
    super.end(params);
  }
};
var LangWatchRAGSpan = class extends LangWatchSpan {
  constructor(params) {
    var _a;
    super(__spreadValues({}, params));
    this.type = "rag";
    this.contexts = (_a = params.contexts) != null ? _a : [];
  }
  update(params) {
    super.update(params);
    if (params.contexts) {
      this.contexts = params.contexts;
    }
  }
  end(params) {
    super.end(params);
  }
};
export {
  LangWatch,
  LangWatchLLMSpan,
  LangWatchRAGSpan,
  LangWatchSpan,
  LangWatchTrace,
  autoconvertTypedValues,
  captureError,
  convertFromVercelAIMessages
};
//# sourceMappingURL=index.mjs.map