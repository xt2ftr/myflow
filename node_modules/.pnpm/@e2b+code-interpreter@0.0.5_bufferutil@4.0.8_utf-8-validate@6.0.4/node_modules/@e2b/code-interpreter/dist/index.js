"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CodeInterpreter: () => CodeInterpreter,
  JupyterExtension: () => JupyterExtension,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/code-interpreter.ts
var import_e2b2 = require("e2b");

// src/messaging.ts
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_e2b = require("e2b");

// src/utils.ts
function createDeferredPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    reject,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    resolve
  };
}
function id(length) {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

// src/messaging.ts
var ExecutionError = class {
  constructor(name, value, tracebackRaw) {
    this.name = name;
    this.value = value;
    this.tracebackRaw = tracebackRaw;
  }
  /**
   * Returns the traceback of the error as a string.
   */
  get traceback() {
    return this.tracebackRaw.join("\n");
  }
};
var Result = class {
  constructor(data, isMainResult) {
    this.isMainResult = isMainResult;
    this.text = data["text/plain"];
    this.html = data["text/html"];
    this.markdown = data["text/markdown"];
    this.svg = data["image/svg+xml"];
    this.png = data["image/png"];
    this.jpeg = data["image/jpeg"];
    this.pdf = data["application/pdf"];
    this.latex = data["text/latex"];
    this.json = data["application/json"];
    this.javascript = data["application/javascript"];
    this.isMainResult = isMainResult;
    this.raw = data;
    this.extra = {};
    for (const key of Object.keys(data)) {
      if (![
        "text/plain",
        "text/html",
        "text/markdown",
        "image/svg+xml",
        "image/png",
        "image/jpeg",
        "application/pdf",
        "text/latex",
        "application/json",
        "application/javascript"
      ].includes(key)) {
        this.extra[key] = data[key];
      }
    }
  }
  /**
   * Returns all the formats available for the result.
   *
   * @returns Array of strings representing the formats available for the result.
   */
  formats() {
    const formats = [];
    if (this.html) {
      formats.push("html");
    }
    if (this.markdown) {
      formats.push("markdown");
    }
    if (this.svg) {
      formats.push("svg");
    }
    if (this.png) {
      formats.push("png");
    }
    if (this.jpeg) {
      formats.push("jpeg");
    }
    if (this.pdf) {
      formats.push("pdf");
    }
    if (this.latex) {
      formats.push("latex");
    }
    if (this.json) {
      formats.push("json");
    }
    if (this.javascript) {
      formats.push("javascript");
    }
    for (const key of Object.keys(this.extra)) {
      formats.push(key);
    }
    return formats;
  }
  /**
   * Returns the serializable representation of the result.
   */
  toJSON() {
    return __spreadValues({
      text: this.text,
      html: this.html,
      markdown: this.markdown,
      svg: this.svg,
      png: this.png,
      jpeg: this.jpeg,
      pdf: this.pdf,
      latex: this.latex,
      json: this.json,
      javascript: this.javascript
    }, Object.keys(this.extra).length > 0 ? { extra: this.extra } : {});
  }
};
var Execution = class {
  constructor(results, logs, error) {
    this.results = results;
    this.logs = logs;
    this.error = error;
  }
  /**
   * Returns the text representation of the main result of the cell.
   */
  get text() {
    for (const data of this.results) {
      if (data.isMainResult) {
        return data.text;
      }
    }
  }
  /**
   * Returns the serializable representation of the execution result.
   */
  toJSON() {
    return {
      results: this.results,
      logs: this.logs,
      error: this.error
    };
  }
};
var CellExecution = class {
  constructor(onStdout, onStderr, onResult) {
    this.inputAccepted = false;
    this.execution = new Execution([], { stdout: [], stderr: [] });
    this.onStdout = onStdout;
    this.onStderr = onStderr;
    this.onResult = onResult;
  }
};
var JupyterKernelWebSocket = class {
  // constructor
  /**
   * Does not start WebSocket connection!
   * You need to call connect() method first.
   */
  constructor(url) {
    this.url = url;
    this.idAwaiter = {};
    this.cells = {};
  }
  set ws(ws) {
    this._ws = ws;
  }
  get ws() {
    if (!this._ws) {
      throw new Error("WebSocket is not connected.");
    }
    return this._ws;
  }
  // public
  /**
   * Starts WebSocket connection.
   */
  connect() {
    this._ws = new import_isomorphic_ws.default(this.url);
    return this.listen();
  }
  // events
  /**
   * Listens for messages from WebSocket server.
   *
   * Message types:
   * https://jupyter-client.readthedocs.io/en/stable/messaging.html
   *
   */
  listenMessages() {
    this.ws.onmessage = (e) => {
      const message = JSON.parse(e.data.toString());
      const parentMsgId = message.parent_header.msg_id;
      const cell = this.cells[parentMsgId];
      if (!cell) {
        return;
      }
      const execution = cell.execution;
      if (message.msg_type == "error") {
        execution.error = new ExecutionError(
          message.content.ename,
          message.content.evalue,
          message.content.traceback
        );
      } else if (message.msg_type == "stream") {
        if (message.content.name == "stdout") {
          execution.logs.stdout.push(message.content.text);
          if (cell == null ? void 0 : cell.onStdout) {
            cell.onStdout(
              new import_e2b.ProcessMessage(
                message.content.text,
                (/* @__PURE__ */ new Date()).getTime() * 1e6,
                false
              )
            );
          }
        } else if (message.content.name == "stderr") {
          execution.logs.stderr.push(message.content.text);
          if (cell == null ? void 0 : cell.onStderr) {
            cell.onStderr(
              new import_e2b.ProcessMessage(
                message.content.text,
                (/* @__PURE__ */ new Date()).getTime() * 1e6,
                true
              )
            );
          }
        }
      } else if (message.msg_type == "display_data") {
        const result = new Result(message.content.data, false);
        execution.results.push(result);
        if (cell.onResult) {
          cell.onResult(result);
        }
      } else if (message.msg_type == "execute_result") {
        const result = new Result(message.content.data, true);
        execution.results.push(result);
        if (cell.onResult) {
          cell.onResult(result);
        }
      } else if (message.msg_type == "status") {
        if (message.content.execution_state == "idle") {
          if (cell.inputAccepted) {
            this.idAwaiter[parentMsgId](execution);
          }
        } else if (message.content.execution_state == "error") {
          execution.error = new ExecutionError(
            message.content.ename,
            message.content.evalue,
            message.content.traceback
          );
          this.idAwaiter[parentMsgId](execution);
        }
      } else if (message.msg_type == "execute_reply") {
        if (message.content.status == "error") {
          execution.error = new ExecutionError(
            message.content.ename,
            message.content.evalue,
            message.content.traceback
          );
        } else if (message.content.status == "ok") {
          return;
        }
      } else if (message.msg_type == "execute_input") {
        cell.inputAccepted = true;
      } else {
        console.warn("[UNHANDLED MESSAGE TYPE]:", message.msg_type);
      }
    };
  }
  // communication
  /**
   * Sends code to be executed by Jupyter kernel.
   * @param code Code to be executed.
   * @param onStdout Callback for stdout messages.
   * @param onStderr Callback for stderr messages.
   * @param onResult Callback function to handle the result and display calls of the code execution.
   * @param timeout Time in milliseconds to wait for response.
   * @returns Promise with execution result.
   */
  sendExecutionMessage(code, onStdout, onStderr, onResult, timeout) {
    return new Promise((resolve, reject) => {
      const msg_id = id(16);
      const data = this.sendExecuteRequest(msg_id, code);
      let timeoutSet;
      if (timeout) {
        timeoutSet = setTimeout(() => {
          delete this.idAwaiter[msg_id];
          reject(
            new Error(
              `Awaiting response to "${code}" with id: ${msg_id} timed out.`
            )
          );
        }, timeout);
      }
      this.cells[msg_id] = new CellExecution(onStdout, onStderr, onResult);
      this.idAwaiter[msg_id] = (responseData) => {
        clearInterval(timeoutSet);
        delete this.idAwaiter[msg_id];
        resolve(responseData);
      };
      const json = JSON.stringify(data);
      this.ws.send(json);
    });
  }
  /**
   * Listens for messages from WebSocket server.
   */
  listen() {
    return new Promise((resolve, reject) => {
      this.ws.onopen = (e) => {
        resolve(e);
      };
      this.listenMessages();
      this.ws.onclose = (e) => {
        reject(
          new Error(
            `WebSocket closed with code: ${e.code} and reason: ${e.reason}`
          )
        );
      };
    });
  }
  /**
   * Creates a websocket message for code execution.
   * @param msg_id Unique message id.
   * @param code Code to be executed.
   */
  sendExecuteRequest(msg_id, code) {
    const session = id(16);
    return {
      header: {
        msg_id,
        username: "e2b",
        session,
        msg_type: "execute_request",
        version: "5.3"
      },
      parent_header: {},
      metadata: {},
      content: {
        code,
        silent: false,
        store_history: false,
        user_expressions: {},
        allow_stdin: false
      }
    };
  }
  /**
   * Closes WebSocket connection.
   */
  close() {
    this.ws.close();
  }
};

// src/code-interpreter.ts
var _CodeInterpreter = class extends import_e2b2.Sandbox {
  constructor(opts, createCalled = false) {
    super(__spreadValues({ template: (opts == null ? void 0 : opts.template) || _CodeInterpreter.template }, opts), createCalled);
    this.notebook = new JupyterExtension(this);
  }
  _open(opts) {
    return __async(this, null, function* () {
      yield __superGet(_CodeInterpreter.prototype, this, "_open").call(this, { timeout: opts == null ? void 0 : opts.timeout });
      yield this.notebook.connect(opts == null ? void 0 : opts.timeout);
      return this;
    });
  }
  close() {
    return __async(this, null, function* () {
      yield this.notebook.close();
      yield __superGet(_CodeInterpreter.prototype, this, "close").call(this);
    });
  }
};
var CodeInterpreter = _CodeInterpreter;
CodeInterpreter.template = "code-interpreter-stateful";
var JupyterExtension = class {
  constructor(sandbox) {
    this.sandbox = sandbox;
    this.connectedKernels = {};
    this.kernelIDPromise = createDeferredPromise();
    this.setDefaultKernelID = this.kernelIDPromise.resolve;
  }
  get defaultKernelID() {
    return this.kernelIDPromise.promise;
  }
  connect(timeout) {
    return __async(this, null, function* () {
      return this.startConnectingToDefaultKernel(this.setDefaultKernelID, {
        timeout
      });
    });
  }
  /**
     * Executes a code cell in a notebool cell.
     *
     * This method sends the provided code to a specified kernel in a remote notebook for execution.
  
     * @param code The code to be executed in the notebook cell.
     * @param kernelID The ID of the kernel to execute the code on. If not provided, the default kernel is used.
     * @param onStdout A callback function to handle standard output messages from the code execution.
     * @param onStderr A callback function to handle standard error messages from the code execution.
     * @param onResult A callback function to handle display data messages from the code execution.
     * @param timeout The maximum time to wait for the code execution to complete, in milliseconds.
     * @returns A promise that resolves with the result of the code execution.
     */
  execCell(_0) {
    return __async(this, arguments, function* (code, {
      kernelID,
      onStdout,
      onStderr,
      onResult,
      timeout
    } = {}) {
      kernelID = kernelID || (yield this.defaultKernelID);
      const ws = this.connectedKernels[kernelID] || (yield this.connectToKernelWS(kernelID));
      return yield ws.sendExecutionMessage(
        code,
        onStdout,
        onStderr,
        onResult,
        timeout
      );
    });
  }
  startConnectingToDefaultKernel(resolve, opts) {
    return __async(this, null, function* () {
      const kernelID = (yield this.sandbox.filesystem.read("/root/.jupyter/kernel_id", opts)).trim();
      yield this.connectToKernelWS(kernelID);
      resolve(kernelID);
    });
  }
  /**
   * Connects to a kernel's WebSocket.
   *
   * This method establishes a WebSocket connection to the specified kernel. It is used internally
   * to facilitate real-time communication with the kernel, enabling operations such as executing
   * code and receiving output. The connection details are managed within the method, including
   * the retrieval of the necessary WebSocket URL from the kernel's information.
   *
   * @param kernelID The unique identifier of the kernel to connect to.
   * @throws {Error} Throws an error if the connection to the kernel's WebSocket cannot be established.
   */
  connectToKernelWS(kernelID) {
    return __async(this, null, function* () {
      const url = `${this.sandbox.getProtocol("ws")}://${this.sandbox.getHostname(
        8888
      )}/api/kernels/${kernelID}/channels`;
      const ws = new JupyterKernelWebSocket(url);
      yield ws.connect();
      this.connectedKernels[kernelID] = ws;
      return ws;
    });
  }
  /**
   * Creates a new Jupyter kernel. It can be useful if you want to have multiple independent code execution environments.
   *
   * The kernel can be optionally configured to start in a specific working directory and/or
   * with a specific kernel name. If no kernel name is provided, the default kernel will be used.
   * Once the kernel is created, this method establishes a WebSocket connection to the new kernel for
   * real-time communication.
   *
   * @param cwd Sets the current working directory where the kernel should start. Defaults to "/home/user".
   * @param kernelName The name of the kernel to create, useful if you have multiple kernel types. If not provided, the default kernel will be used.
   * @returns A promise that resolves with the ID of the newly created kernel.
   * @throws {Error} Throws an error if the kernel creation fails.
   */
  createKernel(cwd = "/home/user", kernelName) {
    return __async(this, null, function* () {
      const data = { cwd };
      if (kernelName) {
        data.kernelName = kernelName;
      }
      const response = yield fetch(
        `${this.sandbox.getProtocol()}://${this.sandbox.getHostname(
          8888
        )}/api/kernels`,
        {
          method: "POST",
          body: JSON.stringify(data)
        }
      );
      if (!response.ok) {
        throw new Error(`Failed to create kernel: ${response.statusText}`);
      }
      const kernelID = (yield response.json()).id;
      yield this.connectToKernelWS(kernelID);
      return kernelID;
    });
  }
  /**
   * Restarts an existing Jupyter kernel. This can be useful to reset the kernel's state or to recover from errors.
   *
   * @param kernelID The unique identifier of the kernel to restart. If not provided, the default kernel is restarted.
   * @throws {Error} Throws an error if the kernel restart fails or if the operation times out.
   */
  restartKernel(kernelID) {
    return __async(this, null, function* () {
      kernelID = kernelID || (yield this.defaultKernelID);
      this.connectedKernels[kernelID].close();
      delete this.connectedKernels[kernelID];
      const response = yield fetch(
        `${this.sandbox.getProtocol()}://${this.sandbox.getHostname(
          8888
        )}/api/kernels/${kernelID}/restart`,
        {
          method: "POST"
        }
      );
      if (!response.ok) {
        throw new Error(`Failed to restart kernel ${kernelID}`);
      }
      yield this.connectToKernelWS(kernelID);
    });
  }
  /**
     * Shuts down an existing Jupyter kernel. This method is used to gracefully terminate a kernel's process.
  
     * @param kernelID The unique identifier of the kernel to shutdown. If not provided, the default kernel is shutdown.
     * @throws {Error} Throws an error if the kernel shutdown fails or if the operation times out.
     */
  shutdownKernel(kernelID) {
    return __async(this, null, function* () {
      kernelID = kernelID || (yield this.defaultKernelID);
      this.connectedKernels[kernelID].close();
      delete this.connectedKernels[kernelID];
      const response = yield fetch(
        `${this.sandbox.getProtocol()}://${this.sandbox.getHostname(
          8888
        )}/api/kernels/${kernelID}`,
        {
          method: "DELETE"
        }
      );
      if (!response.ok) {
        throw new Error(`Failed to shutdown kernel ${kernelID}`);
      }
    });
  }
  /**
   * Lists all available Jupyter kernels.
   *
   * This method fetches a list of all currently available Jupyter kernels from the server. It can be used
   * to retrieve the IDs of all kernels that are currently running or available for connection.
   *
   * @returns A promise that resolves to an array of kernel IDs.
   * @throws {Error} Throws an error if the request to list kernels fails.
   */
  listKernels() {
    return __async(this, null, function* () {
      const response = yield fetch(
        `${this.sandbox.getProtocol()}://${this.sandbox.getHostname(
          8888
        )}/api/kernels`,
        {
          method: "GET"
        }
      );
      if (!response.ok) {
        throw new Error(`Failed to list kernels: ${response.statusText}`);
      }
      return (yield response.json()).map((kernel) => kernel.id);
    });
  }
  /**
   * Close all the websocket connections to the kernels. It doesn't shutdown the kernels.
   */
  close() {
    return __async(this, null, function* () {
      for (const kernelID of Object.keys(this.connectedKernels)) {
        this.connectedKernels[kernelID].close();
      }
    });
  }
};

// src/index.ts
__reExport(src_exports, require("e2b"), module.exports);
var src_default = CodeInterpreter;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CodeInterpreter,
  JupyterExtension,
  ...require("e2b")
});
//# sourceMappingURL=index.js.map