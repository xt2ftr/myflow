import { Sandbox, SandboxOpts, ProcessMessage } from 'e2b';
export * from 'e2b';

/**
 * Represents an error that occurred during the execution of a cell.
 * The error contains the name of the error, the value of the error, and the traceback.
 */
declare class ExecutionError {
    /**
     * Name of the error.
     **/
    name: string;
    /**
     * Value of the error.
     **/
    value: string;
    /**
     * The raw traceback of the error.
     **/
    tracebackRaw: string[];
    constructor(
    /**
     * Name of the error.
     **/
    name: string, 
    /**
     * Value of the error.
     **/
    value: string, 
    /**
     * The raw traceback of the error.
     **/
    tracebackRaw: string[]);
    /**
     * Returns the traceback of the error as a string.
     */
    get traceback(): string;
}
/**
 * Represents a MIME type.
 */
type MIMEType = string;
/**
 * Dictionary that maps MIME types to their corresponding string representations of the data.
 */
type RawData = {
    [key: MIMEType]: string;
};
/**
 * Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
 * The result is similar to the structure returned by ipython kernel: https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics
 *
 *
 * The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
 * as a string, and the result can contain multiple types of data. The display calls don't have to have text representation,
 * for the actual result the representation is always present for the result, the other representations are always optional.
 */
declare class Result {
    readonly isMainResult: boolean;
    /**
     * Text representation of the result.
     */
    readonly text?: string;
    /**
     * HTML representation of the data.
     */
    readonly html?: string;
    /**
     * Markdown representation of the data.
     */
    readonly markdown?: string;
    /**
     * SVG representation of the data.
     */
    readonly svg?: string;
    /**
     * PNG representation of the data.
     */
    readonly png?: string;
    /**
     * JPEG representation of the data.
     */
    readonly jpeg?: string;
    /**
     * PDF representation of the data.
     */
    readonly pdf?: string;
    /**
     * LaTeX representation of the data.
     */
    readonly latex?: string;
    /**
     * JSON representation of the data.
     */
    readonly json?: string;
    /**
     * JavaScript representation of the data.
     */
    readonly javascript?: string;
    /**
     * Extra data that can be included. Not part of the standard types.
     */
    readonly extra?: any;
    readonly raw: RawData;
    constructor(data: RawData, isMainResult: boolean);
    /**
     * Returns all the formats available for the result.
     *
     * @returns Array of strings representing the formats available for the result.
     */
    formats(): string[];
    /**
     * Returns the serializable representation of the result.
     */
    toJSON(): {
        extra?: any;
        text: string | undefined;
        html: string | undefined;
        markdown: string | undefined;
        svg: string | undefined;
        png: string | undefined;
        jpeg: string | undefined;
        pdf: string | undefined;
        latex: string | undefined;
        json: string | undefined;
        javascript: string | undefined;
    };
}
/**
 * Data printed to stdout and stderr during execution, usually by print statements, logs, warnings, subprocesses, etc.
 */
type Logs = {
    /**
     * List of strings printed to stdout by prints, subprocesses, etc.
     */
    stdout: string[];
    /**
     * List of strings printed to stderr by prints, subprocesses, etc.
     */
    stderr: string[];
};
/**
 * Represents the result of a cell execution.
 */
declare class Execution {
    /**
     * List of result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots).
     */
    results: Result[];
    /**
     * Logs printed to stdout and stderr during execution.
     */
    logs: Logs;
    /**
     * An Error object if an error occurred, null otherwise.
     */
    error?: ExecutionError | undefined;
    constructor(
    /**
     * List of result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots).
     */
    results: Result[], 
    /**
     * Logs printed to stdout and stderr during execution.
     */
    logs: Logs, 
    /**
     * An Error object if an error occurred, null otherwise.
     */
    error?: ExecutionError | undefined);
    /**
     * Returns the text representation of the main result of the cell.
     */
    get text(): string | undefined;
    /**
     * Returns the serializable representation of the execution result.
     */
    toJSON(): {
        results: Result[];
        logs: Logs;
        error: ExecutionError | undefined;
    };
}

interface CreateKernelProps {
    cwd: string;
    kernelName?: string;
}
/**
 * E2B code interpreter sandbox extension.
 */
declare class CodeInterpreter extends Sandbox {
    private static template;
    readonly notebook: JupyterExtension;
    constructor(opts?: SandboxOpts, createCalled?: boolean);
    _open(opts?: {
        timeout?: number;
    }): Promise<this>;
    close(): Promise<void>;
}
declare class JupyterExtension {
    private sandbox;
    private readonly connectedKernels;
    private readonly kernelIDPromise;
    private readonly setDefaultKernelID;
    private get defaultKernelID();
    constructor(sandbox: CodeInterpreter);
    connect(timeout?: number): Promise<void>;
    /**
     * Executes a code cell in a notebool cell.
     *
     * This method sends the provided code to a specified kernel in a remote notebook for execution.
  
     * @param code The code to be executed in the notebook cell.
     * @param kernelID The ID of the kernel to execute the code on. If not provided, the default kernel is used.
     * @param onStdout A callback function to handle standard output messages from the code execution.
     * @param onStderr A callback function to handle standard error messages from the code execution.
     * @param onResult A callback function to handle display data messages from the code execution.
     * @param timeout The maximum time to wait for the code execution to complete, in milliseconds.
     * @returns A promise that resolves with the result of the code execution.
     */
    execCell(code: string, { kernelID, onStdout, onStderr, onResult, timeout }?: {
        kernelID?: string;
        onStdout?: (msg: ProcessMessage) => any;
        onStderr?: (msg: ProcessMessage) => any;
        onResult?: (data: Result) => any;
        timeout?: number;
    }): Promise<Execution>;
    private startConnectingToDefaultKernel;
    /**
     * Connects to a kernel's WebSocket.
     *
     * This method establishes a WebSocket connection to the specified kernel. It is used internally
     * to facilitate real-time communication with the kernel, enabling operations such as executing
     * code and receiving output. The connection details are managed within the method, including
     * the retrieval of the necessary WebSocket URL from the kernel's information.
     *
     * @param kernelID The unique identifier of the kernel to connect to.
     * @throws {Error} Throws an error if the connection to the kernel's WebSocket cannot be established.
     */
    private connectToKernelWS;
    /**
     * Creates a new Jupyter kernel. It can be useful if you want to have multiple independent code execution environments.
     *
     * The kernel can be optionally configured to start in a specific working directory and/or
     * with a specific kernel name. If no kernel name is provided, the default kernel will be used.
     * Once the kernel is created, this method establishes a WebSocket connection to the new kernel for
     * real-time communication.
     *
     * @param cwd Sets the current working directory where the kernel should start. Defaults to "/home/user".
     * @param kernelName The name of the kernel to create, useful if you have multiple kernel types. If not provided, the default kernel will be used.
     * @returns A promise that resolves with the ID of the newly created kernel.
     * @throws {Error} Throws an error if the kernel creation fails.
     */
    createKernel(cwd?: string, kernelName?: string): Promise<string>;
    /**
     * Restarts an existing Jupyter kernel. This can be useful to reset the kernel's state or to recover from errors.
     *
     * @param kernelID The unique identifier of the kernel to restart. If not provided, the default kernel is restarted.
     * @throws {Error} Throws an error if the kernel restart fails or if the operation times out.
     */
    restartKernel(kernelID?: string): Promise<void>;
    /**
     * Shuts down an existing Jupyter kernel. This method is used to gracefully terminate a kernel's process.
  
     * @param kernelID The unique identifier of the kernel to shutdown. If not provided, the default kernel is shutdown.
     * @throws {Error} Throws an error if the kernel shutdown fails or if the operation times out.
     */
    shutdownKernel(kernelID?: string): Promise<void>;
    /**
     * Lists all available Jupyter kernels.
     *
     * This method fetches a list of all currently available Jupyter kernels from the server. It can be used
     * to retrieve the IDs of all kernels that are currently running or available for connection.
     *
     * @returns A promise that resolves to an array of kernel IDs.
     * @throws {Error} Throws an error if the request to list kernels fails.
     */
    listKernels(): Promise<string[]>;
    /**
     * Close all the websocket connections to the kernels. It doesn't shutdown the kernels.
     */
    close(): Promise<void>;
}

export { CodeInterpreter, CreateKernelProps, Execution, ExecutionError, JupyterExtension, Logs, MIMEType, RawData, Result, CodeInterpreter as default };
