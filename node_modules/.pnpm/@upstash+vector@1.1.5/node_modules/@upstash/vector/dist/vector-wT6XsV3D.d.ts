type CacheSetting = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload" | false;
type UpstashRequest = {
    path?: string[];
    /**
     * Request body will be serialized to json
     */
    body?: unknown;
};
type UpstashResponse<TResult> = {
    result?: TResult;
    error?: string;
};
interface Requester {
    request: <TResult = unknown>(req: UpstashRequest) => Promise<UpstashResponse<TResult>>;
}
type RetryConfig = false | {
    /**
     * The number of retries to attempt before giving up.
     *
     * @default 5
     */
    retries?: number;
    /**
     * A backoff function receives the current retry cound and returns a number in milliseconds to wait before retrying.
     *
     * @default
     * ```ts
     * Math.exp(retryCount) * 50
     * ```
     */
    backoff?: (retryCount: number) => number;
};
type RequesterConfig = {
    /**
     * Configure the retry behaviour in case of network errors
     */
    retry?: RetryConfig;
    /**
     * Configure the cache behaviour
     * @default "no-store"
     */
    cache?: CacheSetting;
};

type Vector<TMetadata = Dict> = {
    id: string;
    vector?: number[];
    metadata?: TMetadata;
    data?: string;
};
type NAMESPACE = string;
type Dict = Record<string, unknown>;

declare const ENDPOINTS: readonly ["upsert", "update", "query", "delete", "fetch", "reset", "range", "info", "upsert-data", "query-data", "list-namespaces", "delete-namespace"];
type EndpointVariants = (typeof ENDPOINTS)[number] | `${(typeof ENDPOINTS)[number]}/${NAMESPACE}`;
/**
 * TResult is the raw data returned from upstash, which may need to be transformed or parsed.
 */
declare class Command<TResult> {
    readonly payload: Dict | unknown[];
    readonly endpoint: EndpointVariants;
    constructor(command: Dict | unknown[], endpoint: EndpointVariants);
    /**
     * Execute the command using a client.
     */
    exec(client: Requester): Promise<TResult>;
}

declare class DeleteCommand extends Command<{
    deleted: number;
}> {
    constructor(id: (number[] | string[]) | number | string, options?: {
        namespace?: string;
    });
}

type QueryCommandPayload = {
    topK: number;
    filter?: string;
    includeVectors?: boolean;
    includeMetadata?: boolean;
    includeData?: boolean;
} & ({
    vector: number[];
    data?: never;
} | {
    data: string;
    vector?: never;
});
type QueryResult<TMetadata = Dict> = {
    id: number | string;
    score: number;
    vector?: number[];
    metadata?: TMetadata;
    data?: string;
};
type QueryCommandOptions = {
    namespace?: string;
};

declare class QueryManyCommand<TMetadata> extends Command<QueryResult<TMetadata>[][]> {
    constructor(payload: QueryCommandPayload[], options?: QueryCommandOptions);
}

declare class QueryCommand<TMetadata> extends Command<QueryResult<TMetadata>[]> {
    constructor(payload: QueryCommandPayload, options?: QueryCommandOptions);
}

type FetchResult<TMetadata = Dict> = Vector<TMetadata> | null;

type RangeCommandPayload = {
    cursor: number | string;
    limit: number;
    includeVectors?: boolean;
    includeMetadata?: boolean;
    includeData?: boolean;
};
type RangeCommandOptions = {
    namespace?: string;
};
type RangeResult<TMetadata = Dict> = {
    nextCursor: string;
    vectors: Vector<TMetadata>[];
};
declare class RangeCommand<TMetadata> extends Command<RangeResult<TMetadata>> {
    constructor(payload: RangeCommandPayload, options?: RangeCommandOptions);
}

type NamespaceTitle = string;
type NamespaceInfo = {
    vectorCount: number;
    pendingVectorCount: number;
};
type InfoResult = {
    vectorCount: number;
    pendingVectorCount: number;
    indexSize: number;
    dimension: number;
    similarityFunction: "COSINE" | "EUCLIDEAN" | "DOT_PRODUCT";
    namespaces: Record<NamespaceTitle, NamespaceInfo>;
};

declare class Namespace<TIndexMetadata extends Dict = Dict> {
    protected client: Requester;
    protected namespace: string;
    /**
     * Create a new index namespace client
     *
     * @example
     * ```typescript
     * const index = new Index({
     *  url: "<UPSTASH_VECTOR_REST_URL>",
     *  token: "<UPSTASH_VECTOR_REST_TOKEN>",
     * });
     *
     * const namespace = index.namespace("ns");
     * ```
     */
    constructor(client: Requester, namespace: string);
    /**
     * Upserts (Updates and Inserts) specific items into the index namespace.
     * It's used for adding new items to the index namespace or updating existing ones.
     *
     * @example
     * ```js
     * const upsertArgs = {
     *   id: '123',
     *   vector: [0.42, 0.87, ...],
     *   metadata: { property1: 'value1', property2: 'value2' }
     * };
     * const upsertResult = await index.namespace("ns").upsert(upsertArgs);
     * console.log(upsertResult); // Outputs the result of the upsert operation
     * ```
     *
     * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.
     * @param {number|string} args.id - The unique identifier for the item being upserted.
     * @param {number[]} args.vector - The feature vector associated with the item.
     * @param {Dict} [args.metadata] - Optional metadata to be associated with the item.
     *
     * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.
     */
    upsert: <TMetadata extends Dict = TIndexMetadata>(args: {
        id: string | number;
        vector: number[];
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    } | {
        id: string | number;
        data: string;
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    } | {
        id: string | number;
        vector: number[];
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    }[] | {
        id: string | number;
        data: string;
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    }[]) => Promise<string>;
    update: <TMetadata extends Dict = TIndexMetadata>(args: {
        id: string | number;
        vector: number[];
    } | {
        id: string | number;
        data: string;
    } | {
        id: string | number;
        metadata: TMetadata extends infer U ? U : never;
        metadataUpdateMode?: "PATCH" | "OVERWRITE" | undefined;
    }) => Promise<{
        updated: number;
    }>;
    /**
     * It's used for retrieving specific items from the index namespace, optionally including
     * their metadata and feature vectors.
     *
     * @example
     * ```js
     * const fetchIds = ['123', '456'];
     * const fetchOptions = { includeMetadata: true, includeVectors: false };
     * const fetchResults = await index.namespace("ns").fetch(fetchIds, fetchOptions);
     * console.log(fetchResults); // Outputs the fetched items
     * ```
     *
     * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.
     * @param {(number[]|string[])} args[0] - An array of IDs of the items to be fetched.
     * @param {FetchCommandOptions} args[1] - Options for the fetch operation.
     * @param {boolean} [args[1].includeMetadata=false] - Optionally include metadata of the fetched items.
     * @param {boolean} [args[1].includeVectors=false] - Optionally include feature vectors of the fetched items.
     * @param {string} [args[1].namespace = ""] - The namespace of the index to fetch items from.
     *
     * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.
     */
    fetch: <TMetadata extends Dict = TIndexMetadata>(ids: number[] | string[], opts?: {
        includeMetadata?: boolean | undefined;
        includeVectors?: boolean | undefined;
        includeData?: boolean | undefined;
        namespace?: string | undefined;
    } | undefined) => Promise<FetchResult<TMetadata>[]>;
    /**
     * Queries an index namespace with specified parameters.
     * This method creates and executes a query command on an index based on the provided arguments.
     *
     * @example
     * ```js
     * await index.namespace("ns").query({
     *  topK: 3,
     *  vector: [ 0.22, 0.66 ],
     *  filter: "age >= 23 and (type = \'turtle\' OR type = \'cat\')"
     * });
     * ```
     *
     * @param {Object} args - The arguments for the query command.
     * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.
     *                                This vector is utilized to find the most relevant items in the index.
     * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.
     * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.
     * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.
     * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.
     *
     * @returns A promise that resolves with an array of query result objects when the request to query the index is completed.
     */
    query: <TMetadata extends Dict = TIndexMetadata>(args: CommandArgs<typeof QueryCommand>) => Promise<QueryResult<TMetadata>[]>;
    /**
     * Deletes a specific item or items from the index namespace by their ID(s).   *
     *
     * @example
     * ```js
     * await index.namespace("ns").delete('test-id')
     * ```
     *
     * @param id - List of ids or single id
     * @returns A promise that resolves when the request to delete the index is completed.
     */
    delete: (args: CommandArgs<typeof DeleteCommand>) => Promise<{
        deleted: number;
    }>;
    /**
     * Retrieves a range of items from the index.
     *
     * @example
     * ```js
     * const rangeArgs = {
     *   cursor: 0,
     *   limit: 10,
     *   includeVectors: true,
     *   includeMetadata: false
     * };
     * const rangeResults = await index.namespace("ns").range(rangeArgs);
     * console.log(rangeResults); // Outputs the result of the range operation
     * ```
     *
     * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.
     * @param {number|string} args.cursor - The starting point (cursor) for the range query.
     * @param {number} args.limit - The maximum number of items to return in this range.
     * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.
     * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.
     *
     * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.
     */
    range: <TMetadata extends Dict = TIndexMetadata>(args: CommandArgs<typeof RangeCommand>) => Promise<RangeResult<TMetadata>>;
    /**
     * It's used for wiping all the vectors in a index namespace.
     *
     * @example
     * ```js
     * await index.namespace("ns").reset();
     * console.log('Index namespace has been reset');
     * ```
     *
     * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.
     */
    reset: () => Promise<string>;
}

type CommandArgs<TCommand extends new (_args: any) => any> = ConstructorParameters<TCommand>[0];
/**
 * Serverless vector client for upstash vector db.
 */
declare class Index<TIndexMetadata extends Dict = Dict> {
    protected client: Requester;
    /**
     * Create a new vector db client
     *
     * @example
     * ```typescript
     * const index = new Index({
     *  url: "<UPSTASH_VECTOR_REST_URL>",
     *  token: "<UPSTASH_VECTOR_REST_TOKEN>",
     * });
     * ```
     */
    constructor(client: Requester);
    namespace: (namespace: string) => Namespace<TIndexMetadata>;
    /**
     * Deletes a specific item or items from the index by their ID(s).   *
     *
     * @example
     * ```js
     * await index.delete('test-id')
     * ```
     *
     * @param id - List of ids or single id
     * @returns A promise that resolves when the request to delete the index is completed.
     */
    delete: (args: CommandArgs<typeof DeleteCommand>, options?: {
        namespace?: string;
    }) => Promise<{
        deleted: number;
    }>;
    /**
     * Queries an index with specified parameters.
     * This method creates and executes a query command on an index based on the provided arguments.
     *
     * @example
     * ```js
     * await index.query({
     *  topK: 3,
     *  vector: [ 0.22, 0.66 ],
     *  filter: "age >= 23 and (type = \'turtle\' OR type = \'cat\')"
     * });
     * ```
     *
     * @param {Object} args - The arguments for the query command.
     * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.
     *                                This vector is utilized to find the most relevant items in the index.
     * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.
     * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.
     * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.
     * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.
     * @param {boolean} [args.includeData=false] - When set to true, includes data - string - of the returned items in the response.
     *
     *  A promise that resolves with an array of query result objects when the request to query the index is completed.
     */
    query: <TMetadata extends Dict = TIndexMetadata>(args: CommandArgs<typeof QueryCommand>, options?: {
        namespace?: string;
    }) => Promise<QueryResult<TMetadata>[]>;
    /**
     * Queries an index with specified parameters.
     * This method creates and executes a query command on an index based on the provided arguments.
     *
     * @example
     * ```js
     * await index.queryMany([
     * {
     *     topK: 3,
     *     vector: [0.22, 0.66],
     *     filter: "age >= 23 and (type = 'turtle' OR type = 'cat')",
     * },
     * {
     *     topK: 3,
     *     vector: [0.45, 0.52],
     *     filter: "age >= 27 and (type = 'rabbit' OR type = 'dog')",
     * },
     * ]);
     *
     * ```
     *
     * @param {Object} args - The arguments for the query command.
     * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.
     *                                This vector is utilized to find the most relevant items in the index.
     * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.
     * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.
     * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.
     * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.
     * @param {boolean} [args.includeData=false] - When set to true, includes data - string - of the returned items in the response.
     *
     *  A promise that resolves with an array of arrays of query result objects,
     *  where each inner array represents a group of results matching a specific query condition.
     */
    queryMany: <TMetadata extends Dict = TIndexMetadata>(args: CommandArgs<typeof QueryManyCommand>, options?: {
        namespace?: string;
    }) => Promise<QueryResult<TMetadata>[][]>;
    /**
     * Upserts (Updates and Inserts) specific items into the index.
     * It's used for adding new items to the index or updating existing ones.
     *
     * @example
     * ```js
     * const upsertArgs = {
     *   id: '123',
     *   vector: [0.42, 0.87, ...],
     *   metadata: { property1: 'value1', property2: 'value2' }
     * };
     * const upsertResult = await index.upsert(upsertArgs);
     * console.log(upsertResult); // Outputs the result of the upsert operation
     * ```
     *
     * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.
     * @param {number|string} args.id - The unique identifier for the item being upserted.
     * @param {number[]} args.vector - The feature vector associated with the item.
     * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.
     *
     * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.
     */
    upsert: <TMetadata extends Dict = TIndexMetadata>(args: {
        id: string | number;
        vector: number[];
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    } | {
        id: string | number;
        data: string;
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    } | {
        id: string | number;
        vector: number[];
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    }[] | {
        id: string | number;
        data: string;
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    }[], options?: {
        namespace?: string;
    }) => Promise<string>;
    update: <TMetadata extends Dict = TIndexMetadata>(args: {
        id: string | number;
        vector: number[];
    } | {
        id: string | number;
        data: string;
    } | {
        id: string | number;
        metadata: TMetadata extends infer U ? U : never;
        metadataUpdateMode?: "PATCH" | "OVERWRITE" | undefined;
    }, options?: {
        namespace?: string;
    }) => Promise<{
        updated: number;
    }>;
    /**
     * It's used for retrieving specific items from the index, optionally including
     * their metadata and feature vectors.
     *
     * @example
     * ```js
     * const fetchIds = ['123', '456'];
     * const fetchOptions = { includeMetadata: true, includeVectors: false };
     * const fetchResults = await index.fetch(fetchIds, fetchOptions);
     * console.log(fetchResults); // Outputs the fetched items
     * ```
     *
     * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.
     * @param {(number[]|string[])} args - An array of IDs of the items to be fetched.
     * @param {FetchCommandOptions} args - Options for the fetch operation.
     * @param {boolean} [args.includeMetadata=false] - Optionally include metadata of the fetched items.
     * @param {boolean} [args.includeVectors=false] - Optionally include feature vectors of the fetched items.
     * @param {boolean} [args.metadataUpdateMode="OVERWRITE"] - Specifies whether to overwrite or patch the metadata values.
     *
     * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.
     */
    fetch: <TMetadata extends Dict = TIndexMetadata>(ids: number[] | string[], opts?: {
        includeMetadata?: boolean | undefined;
        includeVectors?: boolean | undefined;
        includeData?: boolean | undefined;
        namespace?: string | undefined;
    } | undefined) => Promise<FetchResult<TMetadata>[]>;
    /**
     * It's used for wiping an entire index.
     *
     * @example
     * ```js
     * await index.reset();
     * console.log('Index has been reset');
     * ```
     *
     * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.
     */
    reset: (options?: {
        namespace?: string;
    }) => Promise<string>;
    /**
     * Retrieves a range of items from the index.
     *
     * @example
     * ```js
     * const rangeArgs = {
     *   cursor: 0,
     *   limit: 10,
     *   includeVectors: true,
     *   includeMetadata: false
     * };
     * const rangeResults = await index.range(rangeArgs);
     * console.log(rangeResults); // Outputs the result of the range operation
     * ```
     *
     * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.
     * @param {number|string} args.cursor - The starting point (cursor) for the range query.
     * @param {number} args.limit - The maximum number of items to return in this range.
     * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.
     * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.
     *
     * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.
     */
    range: <TMetadata extends Dict = TIndexMetadata>(args: CommandArgs<typeof RangeCommand>, options?: {
        namespace?: string;
    }) => Promise<RangeResult<TMetadata>>;
    /**
     * Retrieves info from the index.
     *
     * @example
     * ```js
     * const infoResults = await index.info();
     * console.log(infoResults); // Outputs the result of the info operation
     * ```
     *
     * @returns {Promise<InfoResult>} A promise that resolves with the response containing the vectorCount, pendingVectorCount, indexSize, dimension count and similarity algorithm after the command is executed.
     */
    info: () => Promise<InfoResult>;
    /**
     * List all namespaces in the vector database.
     *
     * @example
     * ```js
     * const namespaces = await index.listNamespaces();
     * console.log(namespaces); // Outputs the list of namespaces
     * ```
     *
     * @returns {Promise<string[]>} A promise that resolves with an array of namespaces after the command is executed.
     */
    listNamespaces: () => Promise<string[]>;
    /**
     * Deletes a namespace from the vector database.
     *
     * @example
     * ```js
     * await index.deleteNamespace('namespace');
     * console.log('Namespace has been deleted');
     * ```
     *
     * @param {string} namespace - The name of the namespace to be deleted.
     * @returns {Promise<string>} A promise that resolves with the result of the delete operation after the command is executed.
     */
    deleteNamespace: (namespace: string) => Promise<string>;
}

export { type Dict as D, type FetchResult as F, Index as I, type QueryResult as Q, type RequesterConfig as R, type UpstashRequest as U, type Vector as V, type Requester as a, type UpstashResponse as b, type RangeResult as c, type InfoResult as d };
